// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: OBF.proto

#ifndef PROTOBUF_OBF_2eproto__INCLUDED
#define PROTOBUF_OBF_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace OsmAnd {
namespace OBF {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_OBF_2eproto();
void protobuf_AssignDesc_OBF_2eproto();
void protobuf_ShutdownFile_OBF_2eproto();

class OsmAndStructure;
class OsmAndTileBox;
class StringTable;
class IndexedStringTable;
class OsmAndMapIndex;
class OsmAndMapIndex_MapEncodingRule;
class OsmAndMapIndex_MapRootLevel;
class OsmAndMapIndex_MapDataBox;
class MapDataBlock;
class MapData;
class OsmAndAddressIndex;
class OsmAndAddressIndex_CitiesIndex;
class OsmAndAddressNameIndexData;
class OsmAndAddressNameIndexData_AddressNameIndexData;
class AddressNameIndexDataAtom;
class CityIndex;
class CityBlockIndex;
class StreetIndex;
class StreetIntersection;
class BuildingIndex;
class TransportRoutes;
class TransportRoute;
class IncompleteTransportRoutes;
class IncompleteTransportRoute;
class TransportRouteSchedule;
class TransportRouteScheduleException;
class TransportRouteStop;
class TransportStop;
class TransportStopExit;
class TransportStopsTree;
class OsmAndTransportIndex;
class OsmAndPoiIndex;
class OsmAndPoiNameIndex;
class OsmAndPoiNameIndex_OsmAndPoiNameIndexData;
class OsmAndPoiNameIndexDataAtom;
class OsmAndCategoryTable;
class OsmAndSubtypesTable;
class OsmAndPoiSubtype;
class OsmAndPoiTagGroup;
class OsmAndPoiTagGroups;
class OsmAndPoiBox;
class OsmAndPoiCategories;
class OsmAndPoiBoxData;
class OsmAndPoiBoxDataAtom;
class IdTable;
class RestrictionData;
class RouteData;
class OsmAndRoutingIndex;
class OsmAndRoutingIndex_RouteEncodingRule;
class OsmAndRoutingIndex_RouteDataBox;
class OsmAndRoutingIndex_RouteDataBlock;
class OsmAndHHRoutingIndex;
class OsmAndHHRoutingIndex_HHRoutePointsBox;
class OsmAndHHRoutingIndex_HHRouteNetworkPoint;
class OsmAndHHRoutingIndex_HHRouteBlockSegments;
class OsmAndHHRoutingIndex_HHRoutePointSegments;
class OsmAndOwner;

enum OsmAndAddressIndex_CitiesIndex_CitiesType {
  OsmAndAddressIndex_CitiesIndex_CitiesType_CitiesOrTowns = 1,
  OsmAndAddressIndex_CitiesIndex_CitiesType_Postcodes = 2,
  OsmAndAddressIndex_CitiesIndex_CitiesType_Villages = 3
};
bool OsmAndAddressIndex_CitiesIndex_CitiesType_IsValid(int value);
const OsmAndAddressIndex_CitiesIndex_CitiesType OsmAndAddressIndex_CitiesIndex_CitiesType_CitiesType_MIN = OsmAndAddressIndex_CitiesIndex_CitiesType_CitiesOrTowns;
const OsmAndAddressIndex_CitiesIndex_CitiesType OsmAndAddressIndex_CitiesIndex_CitiesType_CitiesType_MAX = OsmAndAddressIndex_CitiesIndex_CitiesType_Villages;
const int OsmAndAddressIndex_CitiesIndex_CitiesType_CitiesType_ARRAYSIZE = OsmAndAddressIndex_CitiesIndex_CitiesType_CitiesType_MAX + 1;

const ::google::protobuf::EnumDescriptor* OsmAndAddressIndex_CitiesIndex_CitiesType_descriptor();
inline const ::std::string& OsmAndAddressIndex_CitiesIndex_CitiesType_Name(OsmAndAddressIndex_CitiesIndex_CitiesType value) {
  return ::google::protobuf::internal::NameOfEnum(
    OsmAndAddressIndex_CitiesIndex_CitiesType_descriptor(), value);
}
inline bool OsmAndAddressIndex_CitiesIndex_CitiesType_Parse(
    const ::std::string& name, OsmAndAddressIndex_CitiesIndex_CitiesType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OsmAndAddressIndex_CitiesIndex_CitiesType>(
    OsmAndAddressIndex_CitiesIndex_CitiesType_descriptor(), name, value);
}
// ===================================================================

class OsmAndStructure : public ::google::protobuf::Message {
 public:
  OsmAndStructure();
  virtual ~OsmAndStructure();

  OsmAndStructure(const OsmAndStructure& from);

  inline OsmAndStructure& operator=(const OsmAndStructure& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndStructure& default_instance();

  void Swap(OsmAndStructure* other);

  // implements Message ----------------------------------------------

  OsmAndStructure* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndStructure& from);
  void MergeFrom(const OsmAndStructure& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // required int64 dateCreated = 18;
  inline bool has_datecreated() const;
  inline void clear_datecreated();
  static const int kDateCreatedFieldNumber = 18;
  inline ::google::protobuf::int64 datecreated() const;
  inline void set_datecreated(::google::protobuf::int64 value);

  // optional .OsmAnd.OBF.OsmAndOwner owner = 33;
  inline bool has_owner() const;
  inline void clear_owner();
  static const int kOwnerFieldNumber = 33;
  inline const ::OsmAnd::OBF::OsmAndOwner& owner() const;
  inline ::OsmAnd::OBF::OsmAndOwner* mutable_owner();
  inline ::OsmAnd::OBF::OsmAndOwner* release_owner();
  inline void set_allocated_owner(::OsmAnd::OBF::OsmAndOwner* owner);

  // repeated .OsmAnd.OBF.OsmAndAddressIndex addressIndex = 7;
  inline int addressindex_size() const;
  inline void clear_addressindex();
  static const int kAddressIndexFieldNumber = 7;
  inline const ::OsmAnd::OBF::OsmAndAddressIndex& addressindex(int index) const;
  inline ::OsmAnd::OBF::OsmAndAddressIndex* mutable_addressindex(int index);
  inline ::OsmAnd::OBF::OsmAndAddressIndex* add_addressindex();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndAddressIndex >&
      addressindex() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndAddressIndex >*
      mutable_addressindex();

  // repeated .OsmAnd.OBF.OsmAndTransportIndex transportIndex = 4;
  inline int transportindex_size() const;
  inline void clear_transportindex();
  static const int kTransportIndexFieldNumber = 4;
  inline const ::OsmAnd::OBF::OsmAndTransportIndex& transportindex(int index) const;
  inline ::OsmAnd::OBF::OsmAndTransportIndex* mutable_transportindex(int index);
  inline ::OsmAnd::OBF::OsmAndTransportIndex* add_transportindex();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndTransportIndex >&
      transportindex() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndTransportIndex >*
      mutable_transportindex();

  // repeated .OsmAnd.OBF.OsmAndPoiIndex poiIndex = 8;
  inline int poiindex_size() const;
  inline void clear_poiindex();
  static const int kPoiIndexFieldNumber = 8;
  inline const ::OsmAnd::OBF::OsmAndPoiIndex& poiindex(int index) const;
  inline ::OsmAnd::OBF::OsmAndPoiIndex* mutable_poiindex(int index);
  inline ::OsmAnd::OBF::OsmAndPoiIndex* add_poiindex();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiIndex >&
      poiindex() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiIndex >*
      mutable_poiindex();

  // repeated .OsmAnd.OBF.OsmAndMapIndex mapIndex = 6;
  inline int mapindex_size() const;
  inline void clear_mapindex();
  static const int kMapIndexFieldNumber = 6;
  inline const ::OsmAnd::OBF::OsmAndMapIndex& mapindex(int index) const;
  inline ::OsmAnd::OBF::OsmAndMapIndex* mutable_mapindex(int index);
  inline ::OsmAnd::OBF::OsmAndMapIndex* add_mapindex();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndMapIndex >&
      mapindex() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndMapIndex >*
      mutable_mapindex();

  // repeated .OsmAnd.OBF.OsmAndRoutingIndex routingIndex = 9;
  inline int routingindex_size() const;
  inline void clear_routingindex();
  static const int kRoutingIndexFieldNumber = 9;
  inline const ::OsmAnd::OBF::OsmAndRoutingIndex& routingindex(int index) const;
  inline ::OsmAnd::OBF::OsmAndRoutingIndex* mutable_routingindex(int index);
  inline ::OsmAnd::OBF::OsmAndRoutingIndex* add_routingindex();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndRoutingIndex >&
      routingindex() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndRoutingIndex >*
      mutable_routingindex();

  // repeated .OsmAnd.OBF.OsmAndHHRoutingIndex hhRoutingIndex = 10;
  inline int hhroutingindex_size() const;
  inline void clear_hhroutingindex();
  static const int kHhRoutingIndexFieldNumber = 10;
  inline const ::OsmAnd::OBF::OsmAndHHRoutingIndex& hhroutingindex(int index) const;
  inline ::OsmAnd::OBF::OsmAndHHRoutingIndex* mutable_hhroutingindex(int index);
  inline ::OsmAnd::OBF::OsmAndHHRoutingIndex* add_hhroutingindex();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndHHRoutingIndex >&
      hhroutingindex() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndHHRoutingIndex >*
      mutable_hhroutingindex();

  // required uint32 versionConfirm = 32;
  inline bool has_versionconfirm() const;
  inline void clear_versionconfirm();
  static const int kVersionConfirmFieldNumber = 32;
  inline ::google::protobuf::uint32 versionconfirm() const;
  inline void set_versionconfirm(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndStructure)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_datecreated();
  inline void clear_has_datecreated();
  inline void set_has_owner();
  inline void clear_has_owner();
  inline void set_has_versionconfirm();
  inline void clear_has_versionconfirm();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 datecreated_;
  ::OsmAnd::OBF::OsmAndOwner* owner_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndAddressIndex > addressindex_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndTransportIndex > transportindex_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 versionconfirm_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiIndex > poiindex_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndMapIndex > mapindex_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndRoutingIndex > routingindex_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndHHRoutingIndex > hhroutingindex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndStructure* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndTileBox : public ::google::protobuf::Message {
 public:
  OsmAndTileBox();
  virtual ~OsmAndTileBox();

  OsmAndTileBox(const OsmAndTileBox& from);

  inline OsmAndTileBox& operator=(const OsmAndTileBox& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndTileBox& default_instance();

  void Swap(OsmAndTileBox* other);

  // implements Message ----------------------------------------------

  OsmAndTileBox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndTileBox& from);
  void MergeFrom(const OsmAndTileBox& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 left = 1;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 1;
  inline ::google::protobuf::uint32 left() const;
  inline void set_left(::google::protobuf::uint32 value);

  // required uint32 right = 2;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 2;
  inline ::google::protobuf::uint32 right() const;
  inline void set_right(::google::protobuf::uint32 value);

  // required uint32 top = 3;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 3;
  inline ::google::protobuf::uint32 top() const;
  inline void set_top(::google::protobuf::uint32 value);

  // required uint32 bottom = 4;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 4;
  inline ::google::protobuf::uint32 bottom() const;
  inline void set_bottom(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndTileBox)
 private:
  inline void set_has_left();
  inline void clear_has_left();
  inline void set_has_right();
  inline void clear_has_right();
  inline void set_has_top();
  inline void clear_has_top();
  inline void set_has_bottom();
  inline void clear_has_bottom();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 left_;
  ::google::protobuf::uint32 right_;
  ::google::protobuf::uint32 top_;
  ::google::protobuf::uint32 bottom_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndTileBox* default_instance_;
};
// -------------------------------------------------------------------

class StringTable : public ::google::protobuf::Message {
 public:
  StringTable();
  virtual ~StringTable();

  StringTable(const StringTable& from);

  inline StringTable& operator=(const StringTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StringTable& default_instance();

  void Swap(StringTable* other);

  // implements Message ----------------------------------------------

  StringTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StringTable& from);
  void MergeFrom(const StringTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string s = 1;
  inline int s_size() const;
  inline void clear_s();
  static const int kSFieldNumber = 1;
  inline const ::std::string& s(int index) const;
  inline ::std::string* mutable_s(int index);
  inline void set_s(int index, const ::std::string& value);
  inline void set_s(int index, const char* value);
  inline void set_s(int index, const char* value, size_t size);
  inline ::std::string* add_s();
  inline void add_s(const ::std::string& value);
  inline void add_s(const char* value);
  inline void add_s(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& s() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_s();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.StringTable)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> s_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static StringTable* default_instance_;
};
// -------------------------------------------------------------------

class IndexedStringTable : public ::google::protobuf::Message {
 public:
  IndexedStringTable();
  virtual ~IndexedStringTable();

  IndexedStringTable(const IndexedStringTable& from);

  inline IndexedStringTable& operator=(const IndexedStringTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IndexedStringTable& default_instance();

  void Swap(IndexedStringTable* other);

  // implements Message ----------------------------------------------

  IndexedStringTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IndexedStringTable& from);
  void MergeFrom(const IndexedStringTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string prefix = 1;
  inline bool has_prefix() const;
  inline void clear_prefix();
  static const int kPrefixFieldNumber = 1;
  inline const ::std::string& prefix() const;
  inline void set_prefix(const ::std::string& value);
  inline void set_prefix(const char* value);
  inline void set_prefix(const char* value, size_t size);
  inline ::std::string* mutable_prefix();
  inline ::std::string* release_prefix();
  inline void set_allocated_prefix(::std::string* prefix);

  // repeated string key = 3;
  inline int key_size() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 3;
  inline const ::std::string& key(int index) const;
  inline ::std::string* mutable_key(int index);
  inline void set_key(int index, const ::std::string& value);
  inline void set_key(int index, const char* value);
  inline void set_key(int index, const char* value, size_t size);
  inline ::std::string* add_key();
  inline void add_key(const ::std::string& value);
  inline void add_key(const char* value);
  inline void add_key(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& key() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_key();

  // repeated fixed32 val = 4;
  inline int val_size() const;
  inline void clear_val();
  static const int kValFieldNumber = 4;
  inline ::google::protobuf::uint32 val(int index) const;
  inline void set_val(int index, ::google::protobuf::uint32 value);
  inline void add_val(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      val() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_val();

  // repeated .OsmAnd.OBF.IndexedStringTable subtables = 5;
  inline int subtables_size() const;
  inline void clear_subtables();
  static const int kSubtablesFieldNumber = 5;
  inline const ::OsmAnd::OBF::IndexedStringTable& subtables(int index) const;
  inline ::OsmAnd::OBF::IndexedStringTable* mutable_subtables(int index);
  inline ::OsmAnd::OBF::IndexedStringTable* add_subtables();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::IndexedStringTable >&
      subtables() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::IndexedStringTable >*
      mutable_subtables();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.IndexedStringTable)
 private:
  inline void set_has_prefix();
  inline void clear_has_prefix();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* prefix_;
  ::google::protobuf::RepeatedPtrField< ::std::string> key_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > val_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::IndexedStringTable > subtables_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static IndexedStringTable* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndMapIndex_MapEncodingRule : public ::google::protobuf::Message {
 public:
  OsmAndMapIndex_MapEncodingRule();
  virtual ~OsmAndMapIndex_MapEncodingRule();

  OsmAndMapIndex_MapEncodingRule(const OsmAndMapIndex_MapEncodingRule& from);

  inline OsmAndMapIndex_MapEncodingRule& operator=(const OsmAndMapIndex_MapEncodingRule& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndMapIndex_MapEncodingRule& default_instance();

  void Swap(OsmAndMapIndex_MapEncodingRule* other);

  // implements Message ----------------------------------------------

  OsmAndMapIndex_MapEncodingRule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndMapIndex_MapEncodingRule& from);
  void MergeFrom(const OsmAndMapIndex_MapEncodingRule& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string tag = 3;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 3;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const char* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  inline void set_allocated_tag(::std::string* tag);

  // optional string value = 5;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 5;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional uint32 id = 7;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 7;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 minZoom = 9;
  inline bool has_minzoom() const;
  inline void clear_minzoom();
  static const int kMinZoomFieldNumber = 9;
  inline ::google::protobuf::uint32 minzoom() const;
  inline void set_minzoom(::google::protobuf::uint32 value);

  // optional uint32 type = 10;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 10;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndMapIndex.MapEncodingRule)
 private:
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_minzoom();
  inline void clear_has_minzoom();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* tag_;
  ::std::string* value_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 minzoom_;
  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndMapIndex_MapEncodingRule* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndMapIndex_MapRootLevel : public ::google::protobuf::Message {
 public:
  OsmAndMapIndex_MapRootLevel();
  virtual ~OsmAndMapIndex_MapRootLevel();

  OsmAndMapIndex_MapRootLevel(const OsmAndMapIndex_MapRootLevel& from);

  inline OsmAndMapIndex_MapRootLevel& operator=(const OsmAndMapIndex_MapRootLevel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndMapIndex_MapRootLevel& default_instance();

  void Swap(OsmAndMapIndex_MapRootLevel* other);

  // implements Message ----------------------------------------------

  OsmAndMapIndex_MapRootLevel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndMapIndex_MapRootLevel& from);
  void MergeFrom(const OsmAndMapIndex_MapRootLevel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 maxZoom = 1;
  inline bool has_maxzoom() const;
  inline void clear_maxzoom();
  static const int kMaxZoomFieldNumber = 1;
  inline ::google::protobuf::int32 maxzoom() const;
  inline void set_maxzoom(::google::protobuf::int32 value);

  // required int32 minZoom = 2;
  inline bool has_minzoom() const;
  inline void clear_minzoom();
  static const int kMinZoomFieldNumber = 2;
  inline ::google::protobuf::int32 minzoom() const;
  inline void set_minzoom(::google::protobuf::int32 value);

  // required int32 left = 3;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 3;
  inline ::google::protobuf::int32 left() const;
  inline void set_left(::google::protobuf::int32 value);

  // required int32 right = 4;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 4;
  inline ::google::protobuf::int32 right() const;
  inline void set_right(::google::protobuf::int32 value);

  // required int32 top = 5;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 5;
  inline ::google::protobuf::int32 top() const;
  inline void set_top(::google::protobuf::int32 value);

  // required int32 bottom = 6;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 6;
  inline ::google::protobuf::int32 bottom() const;
  inline void set_bottom(::google::protobuf::int32 value);

  // repeated .OsmAnd.OBF.OsmAndMapIndex.MapDataBox boxes = 7;
  inline int boxes_size() const;
  inline void clear_boxes();
  static const int kBoxesFieldNumber = 7;
  inline const ::OsmAnd::OBF::OsmAndMapIndex_MapDataBox& boxes(int index) const;
  inline ::OsmAnd::OBF::OsmAndMapIndex_MapDataBox* mutable_boxes(int index);
  inline ::OsmAnd::OBF::OsmAndMapIndex_MapDataBox* add_boxes();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndMapIndex_MapDataBox >&
      boxes() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndMapIndex_MapDataBox >*
      mutable_boxes();

  // repeated .OsmAnd.OBF.MapDataBlock blocks = 15;
  inline int blocks_size() const;
  inline void clear_blocks();
  static const int kBlocksFieldNumber = 15;
  inline const ::OsmAnd::OBF::MapDataBlock& blocks(int index) const;
  inline ::OsmAnd::OBF::MapDataBlock* mutable_blocks(int index);
  inline ::OsmAnd::OBF::MapDataBlock* add_blocks();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::MapDataBlock >&
      blocks() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::MapDataBlock >*
      mutable_blocks();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndMapIndex.MapRootLevel)
 private:
  inline void set_has_maxzoom();
  inline void clear_has_maxzoom();
  inline void set_has_minzoom();
  inline void clear_has_minzoom();
  inline void set_has_left();
  inline void clear_has_left();
  inline void set_has_right();
  inline void clear_has_right();
  inline void set_has_top();
  inline void clear_has_top();
  inline void set_has_bottom();
  inline void clear_has_bottom();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 maxzoom_;
  ::google::protobuf::int32 minzoom_;
  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 right_;
  ::google::protobuf::int32 top_;
  ::google::protobuf::int32 bottom_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndMapIndex_MapDataBox > boxes_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::MapDataBlock > blocks_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndMapIndex_MapRootLevel* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndMapIndex_MapDataBox : public ::google::protobuf::Message {
 public:
  OsmAndMapIndex_MapDataBox();
  virtual ~OsmAndMapIndex_MapDataBox();

  OsmAndMapIndex_MapDataBox(const OsmAndMapIndex_MapDataBox& from);

  inline OsmAndMapIndex_MapDataBox& operator=(const OsmAndMapIndex_MapDataBox& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndMapIndex_MapDataBox& default_instance();

  void Swap(OsmAndMapIndex_MapDataBox* other);

  // implements Message ----------------------------------------------

  OsmAndMapIndex_MapDataBox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndMapIndex_MapDataBox& from);
  void MergeFrom(const OsmAndMapIndex_MapDataBox& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required sint32 left = 1;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 1;
  inline ::google::protobuf::int32 left() const;
  inline void set_left(::google::protobuf::int32 value);

  // required sint32 right = 2;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 2;
  inline ::google::protobuf::int32 right() const;
  inline void set_right(::google::protobuf::int32 value);

  // required sint32 top = 3;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 3;
  inline ::google::protobuf::int32 top() const;
  inline void set_top(::google::protobuf::int32 value);

  // required sint32 bottom = 4;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 4;
  inline ::google::protobuf::int32 bottom() const;
  inline void set_bottom(::google::protobuf::int32 value);

  // optional fixed32 shiftToMapData = 5;
  inline bool has_shifttomapdata() const;
  inline void clear_shifttomapdata();
  static const int kShiftToMapDataFieldNumber = 5;
  inline ::google::protobuf::uint32 shifttomapdata() const;
  inline void set_shifttomapdata(::google::protobuf::uint32 value);

  // optional bool ocean = 6;
  inline bool has_ocean() const;
  inline void clear_ocean();
  static const int kOceanFieldNumber = 6;
  inline bool ocean() const;
  inline void set_ocean(bool value);

  // repeated .OsmAnd.OBF.OsmAndMapIndex.MapDataBox boxes = 7;
  inline int boxes_size() const;
  inline void clear_boxes();
  static const int kBoxesFieldNumber = 7;
  inline const ::OsmAnd::OBF::OsmAndMapIndex_MapDataBox& boxes(int index) const;
  inline ::OsmAnd::OBF::OsmAndMapIndex_MapDataBox* mutable_boxes(int index);
  inline ::OsmAnd::OBF::OsmAndMapIndex_MapDataBox* add_boxes();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndMapIndex_MapDataBox >&
      boxes() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndMapIndex_MapDataBox >*
      mutable_boxes();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndMapIndex.MapDataBox)
 private:
  inline void set_has_left();
  inline void clear_has_left();
  inline void set_has_right();
  inline void clear_has_right();
  inline void set_has_top();
  inline void clear_has_top();
  inline void set_has_bottom();
  inline void clear_has_bottom();
  inline void set_has_shifttomapdata();
  inline void clear_has_shifttomapdata();
  inline void set_has_ocean();
  inline void clear_has_ocean();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 right_;
  ::google::protobuf::int32 top_;
  ::google::protobuf::int32 bottom_;
  ::google::protobuf::uint32 shifttomapdata_;
  bool ocean_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndMapIndex_MapDataBox > boxes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndMapIndex_MapDataBox* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndMapIndex : public ::google::protobuf::Message {
 public:
  OsmAndMapIndex();
  virtual ~OsmAndMapIndex();

  OsmAndMapIndex(const OsmAndMapIndex& from);

  inline OsmAndMapIndex& operator=(const OsmAndMapIndex& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndMapIndex& default_instance();

  void Swap(OsmAndMapIndex* other);

  // implements Message ----------------------------------------------

  OsmAndMapIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndMapIndex& from);
  void MergeFrom(const OsmAndMapIndex& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef OsmAndMapIndex_MapEncodingRule MapEncodingRule;
  typedef OsmAndMapIndex_MapRootLevel MapRootLevel;
  typedef OsmAndMapIndex_MapDataBox MapDataBox;

  // accessors -------------------------------------------------------

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .OsmAnd.OBF.OsmAndMapIndex.MapEncodingRule rules = 4;
  inline int rules_size() const;
  inline void clear_rules();
  static const int kRulesFieldNumber = 4;
  inline const ::OsmAnd::OBF::OsmAndMapIndex_MapEncodingRule& rules(int index) const;
  inline ::OsmAnd::OBF::OsmAndMapIndex_MapEncodingRule* mutable_rules(int index);
  inline ::OsmAnd::OBF::OsmAndMapIndex_MapEncodingRule* add_rules();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndMapIndex_MapEncodingRule >&
      rules() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndMapIndex_MapEncodingRule >*
      mutable_rules();

  // repeated .OsmAnd.OBF.OsmAndMapIndex.MapRootLevel levels = 5;
  inline int levels_size() const;
  inline void clear_levels();
  static const int kLevelsFieldNumber = 5;
  inline const ::OsmAnd::OBF::OsmAndMapIndex_MapRootLevel& levels(int index) const;
  inline ::OsmAnd::OBF::OsmAndMapIndex_MapRootLevel* mutable_levels(int index);
  inline ::OsmAnd::OBF::OsmAndMapIndex_MapRootLevel* add_levels();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndMapIndex_MapRootLevel >&
      levels() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndMapIndex_MapRootLevel >*
      mutable_levels();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndMapIndex)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndMapIndex_MapEncodingRule > rules_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndMapIndex_MapRootLevel > levels_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndMapIndex* default_instance_;
};
// -------------------------------------------------------------------

class MapDataBlock : public ::google::protobuf::Message {
 public:
  MapDataBlock();
  virtual ~MapDataBlock();

  MapDataBlock(const MapDataBlock& from);

  inline MapDataBlock& operator=(const MapDataBlock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapDataBlock& default_instance();

  void Swap(MapDataBlock* other);

  // implements Message ----------------------------------------------

  MapDataBlock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapDataBlock& from);
  void MergeFrom(const MapDataBlock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 baseId = 10;
  inline bool has_baseid() const;
  inline void clear_baseid();
  static const int kBaseIdFieldNumber = 10;
  inline ::google::protobuf::uint64 baseid() const;
  inline void set_baseid(::google::protobuf::uint64 value);

  // repeated .OsmAnd.OBF.MapData dataObjects = 12;
  inline int dataobjects_size() const;
  inline void clear_dataobjects();
  static const int kDataObjectsFieldNumber = 12;
  inline const ::OsmAnd::OBF::MapData& dataobjects(int index) const;
  inline ::OsmAnd::OBF::MapData* mutable_dataobjects(int index);
  inline ::OsmAnd::OBF::MapData* add_dataobjects();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::MapData >&
      dataobjects() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::MapData >*
      mutable_dataobjects();

  // optional .OsmAnd.OBF.StringTable stringTable = 15;
  inline bool has_stringtable() const;
  inline void clear_stringtable();
  static const int kStringTableFieldNumber = 15;
  inline const ::OsmAnd::OBF::StringTable& stringtable() const;
  inline ::OsmAnd::OBF::StringTable* mutable_stringtable();
  inline ::OsmAnd::OBF::StringTable* release_stringtable();
  inline void set_allocated_stringtable(::OsmAnd::OBF::StringTable* stringtable);

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.MapDataBlock)
 private:
  inline void set_has_baseid();
  inline void clear_has_baseid();
  inline void set_has_stringtable();
  inline void clear_has_stringtable();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 baseid_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::MapData > dataobjects_;
  ::OsmAnd::OBF::StringTable* stringtable_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static MapDataBlock* default_instance_;
};
// -------------------------------------------------------------------

class MapData : public ::google::protobuf::Message {
 public:
  MapData();
  virtual ~MapData();

  MapData(const MapData& from);

  inline MapData& operator=(const MapData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapData& default_instance();

  void Swap(MapData* other);

  // implements Message ----------------------------------------------

  MapData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapData& from);
  void MergeFrom(const MapData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes coordinates = 1;
  inline bool has_coordinates() const;
  inline void clear_coordinates();
  static const int kCoordinatesFieldNumber = 1;
  inline const ::std::string& coordinates() const;
  inline void set_coordinates(const ::std::string& value);
  inline void set_coordinates(const char* value);
  inline void set_coordinates(const void* value, size_t size);
  inline ::std::string* mutable_coordinates();
  inline ::std::string* release_coordinates();
  inline void set_allocated_coordinates(::std::string* coordinates);

  // optional bytes areaCoordinates = 2;
  inline bool has_areacoordinates() const;
  inline void clear_areacoordinates();
  static const int kAreaCoordinatesFieldNumber = 2;
  inline const ::std::string& areacoordinates() const;
  inline void set_areacoordinates(const ::std::string& value);
  inline void set_areacoordinates(const char* value);
  inline void set_areacoordinates(const void* value, size_t size);
  inline ::std::string* mutable_areacoordinates();
  inline ::std::string* release_areacoordinates();
  inline void set_allocated_areacoordinates(::std::string* areacoordinates);

  // repeated bytes polygonInnerCoordinates = 4;
  inline int polygoninnercoordinates_size() const;
  inline void clear_polygoninnercoordinates();
  static const int kPolygonInnerCoordinatesFieldNumber = 4;
  inline const ::std::string& polygoninnercoordinates(int index) const;
  inline ::std::string* mutable_polygoninnercoordinates(int index);
  inline void set_polygoninnercoordinates(int index, const ::std::string& value);
  inline void set_polygoninnercoordinates(int index, const char* value);
  inline void set_polygoninnercoordinates(int index, const void* value, size_t size);
  inline ::std::string* add_polygoninnercoordinates();
  inline void add_polygoninnercoordinates(const ::std::string& value);
  inline void add_polygoninnercoordinates(const char* value);
  inline void add_polygoninnercoordinates(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& polygoninnercoordinates() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_polygoninnercoordinates();

  // optional bytes additionalTypes = 6;
  inline bool has_additionaltypes() const;
  inline void clear_additionaltypes();
  static const int kAdditionalTypesFieldNumber = 6;
  inline const ::std::string& additionaltypes() const;
  inline void set_additionaltypes(const ::std::string& value);
  inline void set_additionaltypes(const char* value);
  inline void set_additionaltypes(const void* value, size_t size);
  inline ::std::string* mutable_additionaltypes();
  inline ::std::string* release_additionaltypes();
  inline void set_allocated_additionaltypes(::std::string* additionaltypes);

  // required bytes types = 7;
  inline bool has_types() const;
  inline void clear_types();
  static const int kTypesFieldNumber = 7;
  inline const ::std::string& types() const;
  inline void set_types(const ::std::string& value);
  inline void set_types(const char* value);
  inline void set_types(const void* value, size_t size);
  inline ::std::string* mutable_types();
  inline ::std::string* release_types();
  inline void set_allocated_types(::std::string* types);

  // optional bytes labelcoordinates = 8;
  inline bool has_labelcoordinates() const;
  inline void clear_labelcoordinates();
  static const int kLabelcoordinatesFieldNumber = 8;
  inline const ::std::string& labelcoordinates() const;
  inline void set_labelcoordinates(const ::std::string& value);
  inline void set_labelcoordinates(const char* value);
  inline void set_labelcoordinates(const void* value, size_t size);
  inline ::std::string* mutable_labelcoordinates();
  inline ::std::string* release_labelcoordinates();
  inline void set_allocated_labelcoordinates(::std::string* labelcoordinates);

  // optional bytes stringNames = 10;
  inline bool has_stringnames() const;
  inline void clear_stringnames();
  static const int kStringNamesFieldNumber = 10;
  inline const ::std::string& stringnames() const;
  inline void set_stringnames(const ::std::string& value);
  inline void set_stringnames(const char* value);
  inline void set_stringnames(const void* value, size_t size);
  inline ::std::string* mutable_stringnames();
  inline ::std::string* release_stringnames();
  inline void set_allocated_stringnames(::std::string* stringnames);

  // required sint64 id = 12;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 12;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // optional bytes rasterBytes = 15;
  inline bool has_rasterbytes() const;
  inline void clear_rasterbytes();
  static const int kRasterBytesFieldNumber = 15;
  inline const ::std::string& rasterbytes() const;
  inline void set_rasterbytes(const ::std::string& value);
  inline void set_rasterbytes(const char* value);
  inline void set_rasterbytes(const void* value, size_t size);
  inline ::std::string* mutable_rasterbytes();
  inline ::std::string* release_rasterbytes();
  inline void set_allocated_rasterbytes(::std::string* rasterbytes);

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.MapData)
 private:
  inline void set_has_coordinates();
  inline void clear_has_coordinates();
  inline void set_has_areacoordinates();
  inline void clear_has_areacoordinates();
  inline void set_has_additionaltypes();
  inline void clear_has_additionaltypes();
  inline void set_has_types();
  inline void clear_has_types();
  inline void set_has_labelcoordinates();
  inline void clear_has_labelcoordinates();
  inline void set_has_stringnames();
  inline void clear_has_stringnames();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_rasterbytes();
  inline void clear_has_rasterbytes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* coordinates_;
  ::std::string* areacoordinates_;
  ::google::protobuf::RepeatedPtrField< ::std::string> polygoninnercoordinates_;
  ::std::string* additionaltypes_;
  ::std::string* types_;
  ::std::string* labelcoordinates_;
  ::std::string* stringnames_;
  ::google::protobuf::int64 id_;
  ::std::string* rasterbytes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static MapData* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndAddressIndex_CitiesIndex : public ::google::protobuf::Message {
 public:
  OsmAndAddressIndex_CitiesIndex();
  virtual ~OsmAndAddressIndex_CitiesIndex();

  OsmAndAddressIndex_CitiesIndex(const OsmAndAddressIndex_CitiesIndex& from);

  inline OsmAndAddressIndex_CitiesIndex& operator=(const OsmAndAddressIndex_CitiesIndex& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndAddressIndex_CitiesIndex& default_instance();

  void Swap(OsmAndAddressIndex_CitiesIndex* other);

  // implements Message ----------------------------------------------

  OsmAndAddressIndex_CitiesIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndAddressIndex_CitiesIndex& from);
  void MergeFrom(const OsmAndAddressIndex_CitiesIndex& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef OsmAndAddressIndex_CitiesIndex_CitiesType CitiesType;
  static const CitiesType CitiesOrTowns = OsmAndAddressIndex_CitiesIndex_CitiesType_CitiesOrTowns;
  static const CitiesType Postcodes = OsmAndAddressIndex_CitiesIndex_CitiesType_Postcodes;
  static const CitiesType Villages = OsmAndAddressIndex_CitiesIndex_CitiesType_Villages;
  static inline bool CitiesType_IsValid(int value) {
    return OsmAndAddressIndex_CitiesIndex_CitiesType_IsValid(value);
  }
  static const CitiesType CitiesType_MIN =
    OsmAndAddressIndex_CitiesIndex_CitiesType_CitiesType_MIN;
  static const CitiesType CitiesType_MAX =
    OsmAndAddressIndex_CitiesIndex_CitiesType_CitiesType_MAX;
  static const int CitiesType_ARRAYSIZE =
    OsmAndAddressIndex_CitiesIndex_CitiesType_CitiesType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CitiesType_descriptor() {
    return OsmAndAddressIndex_CitiesIndex_CitiesType_descriptor();
  }
  static inline const ::std::string& CitiesType_Name(CitiesType value) {
    return OsmAndAddressIndex_CitiesIndex_CitiesType_Name(value);
  }
  static inline bool CitiesType_Parse(const ::std::string& name,
      CitiesType* value) {
    return OsmAndAddressIndex_CitiesIndex_CitiesType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .OsmAnd.OBF.OsmAndAddressIndex.CitiesIndex.CitiesType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::OsmAnd::OBF::OsmAndAddressIndex_CitiesIndex_CitiesType type() const;
  inline void set_type(::OsmAnd::OBF::OsmAndAddressIndex_CitiesIndex_CitiesType value);

  // repeated .OsmAnd.OBF.CityIndex cities = 5;
  inline int cities_size() const;
  inline void clear_cities();
  static const int kCitiesFieldNumber = 5;
  inline const ::OsmAnd::OBF::CityIndex& cities(int index) const;
  inline ::OsmAnd::OBF::CityIndex* mutable_cities(int index);
  inline ::OsmAnd::OBF::CityIndex* add_cities();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::CityIndex >&
      cities() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::CityIndex >*
      mutable_cities();

  // repeated .OsmAnd.OBF.CityBlockIndex blocks = 7;
  inline int blocks_size() const;
  inline void clear_blocks();
  static const int kBlocksFieldNumber = 7;
  inline const ::OsmAnd::OBF::CityBlockIndex& blocks(int index) const;
  inline ::OsmAnd::OBF::CityBlockIndex* mutable_blocks(int index);
  inline ::OsmAnd::OBF::CityBlockIndex* add_blocks();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::CityBlockIndex >&
      blocks() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::CityBlockIndex >*
      mutable_blocks();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndAddressIndex.CitiesIndex)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::CityIndex > cities_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::CityBlockIndex > blocks_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndAddressIndex_CitiesIndex* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndAddressIndex : public ::google::protobuf::Message {
 public:
  OsmAndAddressIndex();
  virtual ~OsmAndAddressIndex();

  OsmAndAddressIndex(const OsmAndAddressIndex& from);

  inline OsmAndAddressIndex& operator=(const OsmAndAddressIndex& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndAddressIndex& default_instance();

  void Swap(OsmAndAddressIndex* other);

  // implements Message ----------------------------------------------

  OsmAndAddressIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndAddressIndex& from);
  void MergeFrom(const OsmAndAddressIndex& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef OsmAndAddressIndex_CitiesIndex CitiesIndex;

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string name_en = 2;
  inline bool has_name_en() const;
  inline void clear_name_en();
  static const int kNameEnFieldNumber = 2;
  inline const ::std::string& name_en() const;
  inline void set_name_en(const ::std::string& value);
  inline void set_name_en(const char* value);
  inline void set_name_en(const char* value, size_t size);
  inline ::std::string* mutable_name_en();
  inline ::std::string* release_name_en();
  inline void set_allocated_name_en(::std::string* name_en);

  // optional .OsmAnd.OBF.OsmAndTileBox boundaries = 3;
  inline bool has_boundaries() const;
  inline void clear_boundaries();
  static const int kBoundariesFieldNumber = 3;
  inline const ::OsmAnd::OBF::OsmAndTileBox& boundaries() const;
  inline ::OsmAnd::OBF::OsmAndTileBox* mutable_boundaries();
  inline ::OsmAnd::OBF::OsmAndTileBox* release_boundaries();
  inline void set_allocated_boundaries(::OsmAnd::OBF::OsmAndTileBox* boundaries);

  // optional .OsmAnd.OBF.StringTable attributeTagsTable = 4;
  inline bool has_attributetagstable() const;
  inline void clear_attributetagstable();
  static const int kAttributeTagsTableFieldNumber = 4;
  inline const ::OsmAnd::OBF::StringTable& attributetagstable() const;
  inline ::OsmAnd::OBF::StringTable* mutable_attributetagstable();
  inline ::OsmAnd::OBF::StringTable* release_attributetagstable();
  inline void set_allocated_attributetagstable(::OsmAnd::OBF::StringTable* attributetagstable);

  // repeated .OsmAnd.OBF.OsmAndAddressIndex.CitiesIndex cities = 6;
  inline int cities_size() const;
  inline void clear_cities();
  static const int kCitiesFieldNumber = 6;
  inline const ::OsmAnd::OBF::OsmAndAddressIndex_CitiesIndex& cities(int index) const;
  inline ::OsmAnd::OBF::OsmAndAddressIndex_CitiesIndex* mutable_cities(int index);
  inline ::OsmAnd::OBF::OsmAndAddressIndex_CitiesIndex* add_cities();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndAddressIndex_CitiesIndex >&
      cities() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndAddressIndex_CitiesIndex >*
      mutable_cities();

  // optional .OsmAnd.OBF.OsmAndAddressNameIndexData nameIndex = 7;
  inline bool has_nameindex() const;
  inline void clear_nameindex();
  static const int kNameIndexFieldNumber = 7;
  inline const ::OsmAnd::OBF::OsmAndAddressNameIndexData& nameindex() const;
  inline ::OsmAnd::OBF::OsmAndAddressNameIndexData* mutable_nameindex();
  inline ::OsmAnd::OBF::OsmAndAddressNameIndexData* release_nameindex();
  inline void set_allocated_nameindex(::OsmAnd::OBF::OsmAndAddressNameIndexData* nameindex);

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndAddressIndex)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_name_en();
  inline void clear_has_name_en();
  inline void set_has_boundaries();
  inline void clear_has_boundaries();
  inline void set_has_attributetagstable();
  inline void clear_has_attributetagstable();
  inline void set_has_nameindex();
  inline void clear_has_nameindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* name_en_;
  ::OsmAnd::OBF::OsmAndTileBox* boundaries_;
  ::OsmAnd::OBF::StringTable* attributetagstable_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndAddressIndex_CitiesIndex > cities_;
  ::OsmAnd::OBF::OsmAndAddressNameIndexData* nameindex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndAddressIndex* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndAddressNameIndexData_AddressNameIndexData : public ::google::protobuf::Message {
 public:
  OsmAndAddressNameIndexData_AddressNameIndexData();
  virtual ~OsmAndAddressNameIndexData_AddressNameIndexData();

  OsmAndAddressNameIndexData_AddressNameIndexData(const OsmAndAddressNameIndexData_AddressNameIndexData& from);

  inline OsmAndAddressNameIndexData_AddressNameIndexData& operator=(const OsmAndAddressNameIndexData_AddressNameIndexData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndAddressNameIndexData_AddressNameIndexData& default_instance();

  void Swap(OsmAndAddressNameIndexData_AddressNameIndexData* other);

  // implements Message ----------------------------------------------

  OsmAndAddressNameIndexData_AddressNameIndexData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndAddressNameIndexData_AddressNameIndexData& from);
  void MergeFrom(const OsmAndAddressNameIndexData_AddressNameIndexData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .OsmAnd.OBF.AddressNameIndexDataAtom atom = 4;
  inline int atom_size() const;
  inline void clear_atom();
  static const int kAtomFieldNumber = 4;
  inline const ::OsmAnd::OBF::AddressNameIndexDataAtom& atom(int index) const;
  inline ::OsmAnd::OBF::AddressNameIndexDataAtom* mutable_atom(int index);
  inline ::OsmAnd::OBF::AddressNameIndexDataAtom* add_atom();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::AddressNameIndexDataAtom >&
      atom() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::AddressNameIndexDataAtom >*
      mutable_atom();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndAddressNameIndexData.AddressNameIndexData)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::AddressNameIndexDataAtom > atom_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndAddressNameIndexData_AddressNameIndexData* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndAddressNameIndexData : public ::google::protobuf::Message {
 public:
  OsmAndAddressNameIndexData();
  virtual ~OsmAndAddressNameIndexData();

  OsmAndAddressNameIndexData(const OsmAndAddressNameIndexData& from);

  inline OsmAndAddressNameIndexData& operator=(const OsmAndAddressNameIndexData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndAddressNameIndexData& default_instance();

  void Swap(OsmAndAddressNameIndexData* other);

  // implements Message ----------------------------------------------

  OsmAndAddressNameIndexData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndAddressNameIndexData& from);
  void MergeFrom(const OsmAndAddressNameIndexData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef OsmAndAddressNameIndexData_AddressNameIndexData AddressNameIndexData;

  // accessors -------------------------------------------------------

  // required .OsmAnd.OBF.IndexedStringTable table = 4;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 4;
  inline const ::OsmAnd::OBF::IndexedStringTable& table() const;
  inline ::OsmAnd::OBF::IndexedStringTable* mutable_table();
  inline ::OsmAnd::OBF::IndexedStringTable* release_table();
  inline void set_allocated_table(::OsmAnd::OBF::IndexedStringTable* table);

  // repeated .OsmAnd.OBF.OsmAndAddressNameIndexData.AddressNameIndexData atom = 7;
  inline int atom_size() const;
  inline void clear_atom();
  static const int kAtomFieldNumber = 7;
  inline const ::OsmAnd::OBF::OsmAndAddressNameIndexData_AddressNameIndexData& atom(int index) const;
  inline ::OsmAnd::OBF::OsmAndAddressNameIndexData_AddressNameIndexData* mutable_atom(int index);
  inline ::OsmAnd::OBF::OsmAndAddressNameIndexData_AddressNameIndexData* add_atom();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndAddressNameIndexData_AddressNameIndexData >&
      atom() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndAddressNameIndexData_AddressNameIndexData >*
      mutable_atom();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndAddressNameIndexData)
 private:
  inline void set_has_table();
  inline void clear_has_table();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::OsmAnd::OBF::IndexedStringTable* table_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndAddressNameIndexData_AddressNameIndexData > atom_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndAddressNameIndexData* default_instance_;
};
// -------------------------------------------------------------------

class AddressNameIndexDataAtom : public ::google::protobuf::Message {
 public:
  AddressNameIndexDataAtom();
  virtual ~AddressNameIndexDataAtom();

  AddressNameIndexDataAtom(const AddressNameIndexDataAtom& from);

  inline AddressNameIndexDataAtom& operator=(const AddressNameIndexDataAtom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddressNameIndexDataAtom& default_instance();

  void Swap(AddressNameIndexDataAtom* other);

  // implements Message ----------------------------------------------

  AddressNameIndexDataAtom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddressNameIndexDataAtom& from);
  void MergeFrom(const AddressNameIndexDataAtom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string nameEn = 2;
  inline bool has_nameen() const;
  inline void clear_nameen();
  static const int kNameEnFieldNumber = 2;
  inline const ::std::string& nameen() const;
  inline void set_nameen(const ::std::string& value);
  inline void set_nameen(const char* value);
  inline void set_nameen(const char* value, size_t size);
  inline ::std::string* mutable_nameen();
  inline ::std::string* release_nameen();
  inline void set_allocated_nameen(::std::string* nameen);

  // required uint32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // repeated int32 shiftToIndex = 5;
  inline int shifttoindex_size() const;
  inline void clear_shifttoindex();
  static const int kShiftToIndexFieldNumber = 5;
  inline ::google::protobuf::int32 shifttoindex(int index) const;
  inline void set_shifttoindex(int index, ::google::protobuf::int32 value);
  inline void add_shifttoindex(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      shifttoindex() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_shifttoindex();

  // repeated int32 shiftToCityIndex = 6;
  inline int shifttocityindex_size() const;
  inline void clear_shifttocityindex();
  static const int kShiftToCityIndexFieldNumber = 6;
  inline ::google::protobuf::int32 shifttocityindex(int index) const;
  inline void set_shifttocityindex(int index, ::google::protobuf::int32 value);
  inline void add_shifttocityindex(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      shifttocityindex() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_shifttocityindex();

  // repeated uint32 xy16 = 7;
  inline int xy16_size() const;
  inline void clear_xy16();
  static const int kXy16FieldNumber = 7;
  inline ::google::protobuf::uint32 xy16(int index) const;
  inline void set_xy16(int index, ::google::protobuf::uint32 value);
  inline void add_xy16(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      xy16() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_xy16();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.AddressNameIndexDataAtom)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_nameen();
  inline void clear_has_nameen();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* nameen_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > shifttoindex_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > shifttocityindex_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > xy16_;
  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static AddressNameIndexDataAtom* default_instance_;
};
// -------------------------------------------------------------------

class CityIndex : public ::google::protobuf::Message {
 public:
  CityIndex();
  virtual ~CityIndex();

  CityIndex(const CityIndex& from);

  inline CityIndex& operator=(const CityIndex& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CityIndex& default_instance();

  void Swap(CityIndex* other);

  // implements Message ----------------------------------------------

  CityIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CityIndex& from);
  void MergeFrom(const CityIndex& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 city_type = 1;
  inline bool has_city_type() const;
  inline void clear_city_type();
  static const int kCityTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 city_type() const;
  inline void set_city_type(::google::protobuf::uint32 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string name_en = 3;
  inline bool has_name_en() const;
  inline void clear_name_en();
  static const int kNameEnFieldNumber = 3;
  inline const ::std::string& name_en() const;
  inline void set_name_en(const ::std::string& value);
  inline void set_name_en(const char* value);
  inline void set_name_en(const char* value, size_t size);
  inline ::std::string* mutable_name_en();
  inline ::std::string* release_name_en();
  inline void set_allocated_name_en(::std::string* name_en);

  // optional uint64 id = 4;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 4;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // required uint32 x = 5;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 5;
  inline ::google::protobuf::uint32 x() const;
  inline void set_x(::google::protobuf::uint32 value);

  // required uint32 y = 6;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 6;
  inline ::google::protobuf::uint32 y() const;
  inline void set_y(::google::protobuf::uint32 value);

  // repeated uint32 attributeTagIds = 7;
  inline int attributetagids_size() const;
  inline void clear_attributetagids();
  static const int kAttributeTagIdsFieldNumber = 7;
  inline ::google::protobuf::uint32 attributetagids(int index) const;
  inline void set_attributetagids(int index, ::google::protobuf::uint32 value);
  inline void add_attributetagids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      attributetagids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_attributetagids();

  // repeated string attributeValues = 8;
  inline int attributevalues_size() const;
  inline void clear_attributevalues();
  static const int kAttributeValuesFieldNumber = 8;
  inline const ::std::string& attributevalues(int index) const;
  inline ::std::string* mutable_attributevalues(int index);
  inline void set_attributevalues(int index, const ::std::string& value);
  inline void set_attributevalues(int index, const char* value);
  inline void set_attributevalues(int index, const char* value, size_t size);
  inline ::std::string* add_attributevalues();
  inline void add_attributevalues(const ::std::string& value);
  inline void add_attributevalues(const char* value);
  inline void add_attributevalues(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& attributevalues() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_attributevalues();

  // optional fixed32 shiftToCityBlockIndex = 10;
  inline bool has_shifttocityblockindex() const;
  inline void clear_shifttocityblockindex();
  static const int kShiftToCityBlockIndexFieldNumber = 10;
  inline ::google::protobuf::uint32 shifttocityblockindex() const;
  inline void set_shifttocityblockindex(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.CityIndex)
 private:
  inline void set_has_city_type();
  inline void clear_has_city_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_name_en();
  inline void clear_has_name_en();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_shifttocityblockindex();
  inline void clear_has_shifttocityblockindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* name_en_;
  ::google::protobuf::uint32 city_type_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > attributetagids_;
  ::google::protobuf::uint32 y_;
  ::google::protobuf::uint32 shifttocityblockindex_;
  ::google::protobuf::RepeatedPtrField< ::std::string> attributevalues_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static CityIndex* default_instance_;
};
// -------------------------------------------------------------------

class CityBlockIndex : public ::google::protobuf::Message {
 public:
  CityBlockIndex();
  virtual ~CityBlockIndex();

  CityBlockIndex(const CityBlockIndex& from);

  inline CityBlockIndex& operator=(const CityBlockIndex& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CityBlockIndex& default_instance();

  void Swap(CityBlockIndex* other);

  // implements Message ----------------------------------------------

  CityBlockIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CityBlockIndex& from);
  void MergeFrom(const CityBlockIndex& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed32 shiftToCityIndex = 4;
  inline bool has_shifttocityindex() const;
  inline void clear_shifttocityindex();
  static const int kShiftToCityIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 shifttocityindex() const;
  inline void set_shifttocityindex(::google::protobuf::uint32 value);

  // repeated .OsmAnd.OBF.BuildingIndex buildings = 10;
  inline int buildings_size() const;
  inline void clear_buildings();
  static const int kBuildingsFieldNumber = 10;
  inline const ::OsmAnd::OBF::BuildingIndex& buildings(int index) const;
  inline ::OsmAnd::OBF::BuildingIndex* mutable_buildings(int index);
  inline ::OsmAnd::OBF::BuildingIndex* add_buildings();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::BuildingIndex >&
      buildings() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::BuildingIndex >*
      mutable_buildings();

  // repeated .OsmAnd.OBF.StreetIndex streets = 12;
  inline int streets_size() const;
  inline void clear_streets();
  static const int kStreetsFieldNumber = 12;
  inline const ::OsmAnd::OBF::StreetIndex& streets(int index) const;
  inline ::OsmAnd::OBF::StreetIndex* mutable_streets(int index);
  inline ::OsmAnd::OBF::StreetIndex* add_streets();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::StreetIndex >&
      streets() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::StreetIndex >*
      mutable_streets();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.CityBlockIndex)
 private:
  inline void set_has_shifttocityindex();
  inline void clear_has_shifttocityindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::BuildingIndex > buildings_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::StreetIndex > streets_;
  ::google::protobuf::uint32 shifttocityindex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static CityBlockIndex* default_instance_;
};
// -------------------------------------------------------------------

class StreetIndex : public ::google::protobuf::Message {
 public:
  StreetIndex();
  virtual ~StreetIndex();

  StreetIndex(const StreetIndex& from);

  inline StreetIndex& operator=(const StreetIndex& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StreetIndex& default_instance();

  void Swap(StreetIndex* other);

  // implements Message ----------------------------------------------

  StreetIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StreetIndex& from);
  void MergeFrom(const StreetIndex& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string name_en = 2;
  inline bool has_name_en() const;
  inline void clear_name_en();
  static const int kNameEnFieldNumber = 2;
  inline const ::std::string& name_en() const;
  inline void set_name_en(const ::std::string& value);
  inline void set_name_en(const char* value);
  inline void set_name_en(const char* value, size_t size);
  inline ::std::string* mutable_name_en();
  inline ::std::string* release_name_en();
  inline void set_allocated_name_en(::std::string* name_en);

  // required sint32 x = 3;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 3;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required sint32 y = 4;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 4;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // repeated .OsmAnd.OBF.StreetIntersection intersections = 5;
  inline int intersections_size() const;
  inline void clear_intersections();
  static const int kIntersectionsFieldNumber = 5;
  inline const ::OsmAnd::OBF::StreetIntersection& intersections(int index) const;
  inline ::OsmAnd::OBF::StreetIntersection* mutable_intersections(int index);
  inline ::OsmAnd::OBF::StreetIntersection* add_intersections();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::StreetIntersection >&
      intersections() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::StreetIntersection >*
      mutable_intersections();

  // optional uint64 id = 6;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 6;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // repeated uint32 attributeTagIds = 7;
  inline int attributetagids_size() const;
  inline void clear_attributetagids();
  static const int kAttributeTagIdsFieldNumber = 7;
  inline ::google::protobuf::uint32 attributetagids(int index) const;
  inline void set_attributetagids(int index, ::google::protobuf::uint32 value);
  inline void add_attributetagids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      attributetagids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_attributetagids();

  // repeated string attributeValues = 8;
  inline int attributevalues_size() const;
  inline void clear_attributevalues();
  static const int kAttributeValuesFieldNumber = 8;
  inline const ::std::string& attributevalues(int index) const;
  inline ::std::string* mutable_attributevalues(int index);
  inline void set_attributevalues(int index, const ::std::string& value);
  inline void set_attributevalues(int index, const char* value);
  inline void set_attributevalues(int index, const char* value, size_t size);
  inline ::std::string* add_attributevalues();
  inline void add_attributevalues(const ::std::string& value);
  inline void add_attributevalues(const char* value);
  inline void add_attributevalues(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& attributevalues() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_attributevalues();

  // repeated .OsmAnd.OBF.BuildingIndex buildings = 12;
  inline int buildings_size() const;
  inline void clear_buildings();
  static const int kBuildingsFieldNumber = 12;
  inline const ::OsmAnd::OBF::BuildingIndex& buildings(int index) const;
  inline ::OsmAnd::OBF::BuildingIndex* mutable_buildings(int index);
  inline ::OsmAnd::OBF::BuildingIndex* add_buildings();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::BuildingIndex >&
      buildings() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::BuildingIndex >*
      mutable_buildings();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.StreetIndex)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_name_en();
  inline void clear_has_name_en();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* name_en_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::StreetIntersection > intersections_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > attributetagids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> attributevalues_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::BuildingIndex > buildings_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static StreetIndex* default_instance_;
};
// -------------------------------------------------------------------

class StreetIntersection : public ::google::protobuf::Message {
 public:
  StreetIntersection();
  virtual ~StreetIntersection();

  StreetIntersection(const StreetIntersection& from);

  inline StreetIntersection& operator=(const StreetIntersection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StreetIntersection& default_instance();

  void Swap(StreetIntersection* other);

  // implements Message ----------------------------------------------

  StreetIntersection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StreetIntersection& from);
  void MergeFrom(const StreetIntersection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string name_en = 3;
  inline bool has_name_en() const;
  inline void clear_name_en();
  static const int kNameEnFieldNumber = 3;
  inline const ::std::string& name_en() const;
  inline void set_name_en(const ::std::string& value);
  inline void set_name_en(const char* value);
  inline void set_name_en(const char* value, size_t size);
  inline ::std::string* mutable_name_en();
  inline ::std::string* release_name_en();
  inline void set_allocated_name_en(::std::string* name_en);

  // required sint32 intersectedX = 4;
  inline bool has_intersectedx() const;
  inline void clear_intersectedx();
  static const int kIntersectedXFieldNumber = 4;
  inline ::google::protobuf::int32 intersectedx() const;
  inline void set_intersectedx(::google::protobuf::int32 value);

  // required sint32 intersectedY = 5;
  inline bool has_intersectedy() const;
  inline void clear_intersectedy();
  static const int kIntersectedYFieldNumber = 5;
  inline ::google::protobuf::int32 intersectedy() const;
  inline void set_intersectedy(::google::protobuf::int32 value);

  // repeated uint32 attributeTagIds = 7;
  inline int attributetagids_size() const;
  inline void clear_attributetagids();
  static const int kAttributeTagIdsFieldNumber = 7;
  inline ::google::protobuf::uint32 attributetagids(int index) const;
  inline void set_attributetagids(int index, ::google::protobuf::uint32 value);
  inline void add_attributetagids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      attributetagids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_attributetagids();

  // repeated string attributeValues = 8;
  inline int attributevalues_size() const;
  inline void clear_attributevalues();
  static const int kAttributeValuesFieldNumber = 8;
  inline const ::std::string& attributevalues(int index) const;
  inline ::std::string* mutable_attributevalues(int index);
  inline void set_attributevalues(int index, const ::std::string& value);
  inline void set_attributevalues(int index, const char* value);
  inline void set_attributevalues(int index, const char* value, size_t size);
  inline ::std::string* add_attributevalues();
  inline void add_attributevalues(const ::std::string& value);
  inline void add_attributevalues(const char* value);
  inline void add_attributevalues(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& attributevalues() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_attributevalues();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.StreetIntersection)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_name_en();
  inline void clear_has_name_en();
  inline void set_has_intersectedx();
  inline void clear_has_intersectedx();
  inline void set_has_intersectedy();
  inline void clear_has_intersectedy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* name_en_;
  ::google::protobuf::int32 intersectedx_;
  ::google::protobuf::int32 intersectedy_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > attributetagids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> attributevalues_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static StreetIntersection* default_instance_;
};
// -------------------------------------------------------------------

class BuildingIndex : public ::google::protobuf::Message {
 public:
  BuildingIndex();
  virtual ~BuildingIndex();

  BuildingIndex(const BuildingIndex& from);

  inline BuildingIndex& operator=(const BuildingIndex& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuildingIndex& default_instance();

  void Swap(BuildingIndex* other);

  // implements Message ----------------------------------------------

  BuildingIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuildingIndex& from);
  void MergeFrom(const BuildingIndex& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string name_en = 2;
  inline bool has_name_en() const;
  inline void clear_name_en();
  static const int kNameEnFieldNumber = 2;
  inline const ::std::string& name_en() const;
  inline void set_name_en(const ::std::string& value);
  inline void set_name_en(const char* value);
  inline void set_name_en(const char* value, size_t size);
  inline ::std::string* mutable_name_en();
  inline ::std::string* release_name_en();
  inline void set_allocated_name_en(::std::string* name_en);

  // optional string name2 = 3;
  inline bool has_name2() const;
  inline void clear_name2();
  static const int kName2FieldNumber = 3;
  inline const ::std::string& name2() const;
  inline void set_name2(const ::std::string& value);
  inline void set_name2(const char* value);
  inline void set_name2(const char* value, size_t size);
  inline ::std::string* mutable_name2();
  inline ::std::string* release_name2();
  inline void set_allocated_name2(::std::string* name2);

  // optional string name_en2 = 4;
  inline bool has_name_en2() const;
  inline void clear_name_en2();
  static const int kNameEn2FieldNumber = 4;
  inline const ::std::string& name_en2() const;
  inline void set_name_en2(const ::std::string& value);
  inline void set_name_en2(const char* value);
  inline void set_name_en2(const char* value, size_t size);
  inline ::std::string* mutable_name_en2();
  inline ::std::string* release_name_en2();
  inline void set_allocated_name_en2(::std::string* name_en2);

  // optional sint32 interpolation = 5;
  inline bool has_interpolation() const;
  inline void clear_interpolation();
  static const int kInterpolationFieldNumber = 5;
  inline ::google::protobuf::int32 interpolation() const;
  inline void set_interpolation(::google::protobuf::int32 value);

  // required sint32 x = 7;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 7;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required sint32 y = 8;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 8;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // optional sint32 x2 = 9;
  inline bool has_x2() const;
  inline void clear_x2();
  static const int kX2FieldNumber = 9;
  inline ::google::protobuf::int32 x2() const;
  inline void set_x2(::google::protobuf::int32 value);

  // optional sint32 y2 = 10;
  inline bool has_y2() const;
  inline void clear_y2();
  static const int kY2FieldNumber = 10;
  inline ::google::protobuf::int32 y2() const;
  inline void set_y2(::google::protobuf::int32 value);

  // optional uint64 id = 13;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 13;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional string postcode = 14;
  inline bool has_postcode() const;
  inline void clear_postcode();
  static const int kPostcodeFieldNumber = 14;
  inline const ::std::string& postcode() const;
  inline void set_postcode(const ::std::string& value);
  inline void set_postcode(const char* value);
  inline void set_postcode(const char* value, size_t size);
  inline ::std::string* mutable_postcode();
  inline ::std::string* release_postcode();
  inline void set_allocated_postcode(::std::string* postcode);

  // repeated uint32 attributeTagIds = 15;
  inline int attributetagids_size() const;
  inline void clear_attributetagids();
  static const int kAttributeTagIdsFieldNumber = 15;
  inline ::google::protobuf::uint32 attributetagids(int index) const;
  inline void set_attributetagids(int index, ::google::protobuf::uint32 value);
  inline void add_attributetagids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      attributetagids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_attributetagids();

  // repeated string attributeValues = 16;
  inline int attributevalues_size() const;
  inline void clear_attributevalues();
  static const int kAttributeValuesFieldNumber = 16;
  inline const ::std::string& attributevalues(int index) const;
  inline ::std::string* mutable_attributevalues(int index);
  inline void set_attributevalues(int index, const ::std::string& value);
  inline void set_attributevalues(int index, const char* value);
  inline void set_attributevalues(int index, const char* value, size_t size);
  inline ::std::string* add_attributevalues();
  inline void add_attributevalues(const ::std::string& value);
  inline void add_attributevalues(const char* value);
  inline void add_attributevalues(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& attributevalues() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_attributevalues();

  // repeated uint32 attributeTagIds2 = 17;
  inline int attributetagids2_size() const;
  inline void clear_attributetagids2();
  static const int kAttributeTagIds2FieldNumber = 17;
  inline ::google::protobuf::uint32 attributetagids2(int index) const;
  inline void set_attributetagids2(int index, ::google::protobuf::uint32 value);
  inline void add_attributetagids2(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      attributetagids2() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_attributetagids2();

  // repeated string attributeValues2 = 18;
  inline int attributevalues2_size() const;
  inline void clear_attributevalues2();
  static const int kAttributeValues2FieldNumber = 18;
  inline const ::std::string& attributevalues2(int index) const;
  inline ::std::string* mutable_attributevalues2(int index);
  inline void set_attributevalues2(int index, const ::std::string& value);
  inline void set_attributevalues2(int index, const char* value);
  inline void set_attributevalues2(int index, const char* value, size_t size);
  inline ::std::string* add_attributevalues2();
  inline void add_attributevalues2(const ::std::string& value);
  inline void add_attributevalues2(const char* value);
  inline void add_attributevalues2(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& attributevalues2() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_attributevalues2();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.BuildingIndex)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_name_en();
  inline void clear_has_name_en();
  inline void set_has_name2();
  inline void clear_has_name2();
  inline void set_has_name_en2();
  inline void clear_has_name_en2();
  inline void set_has_interpolation();
  inline void clear_has_interpolation();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_x2();
  inline void clear_has_x2();
  inline void set_has_y2();
  inline void clear_has_y2();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_postcode();
  inline void clear_has_postcode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* name_en_;
  ::std::string* name2_;
  ::std::string* name_en2_;
  ::google::protobuf::int32 interpolation_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 x2_;
  ::google::protobuf::uint64 id_;
  ::std::string* postcode_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > attributetagids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> attributevalues_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > attributetagids2_;
  ::google::protobuf::RepeatedPtrField< ::std::string> attributevalues2_;
  ::google::protobuf::int32 y2_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static BuildingIndex* default_instance_;
};
// -------------------------------------------------------------------

class TransportRoutes : public ::google::protobuf::Message {
 public:
  TransportRoutes();
  virtual ~TransportRoutes();

  TransportRoutes(const TransportRoutes& from);

  inline TransportRoutes& operator=(const TransportRoutes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransportRoutes& default_instance();

  void Swap(TransportRoutes* other);

  // implements Message ----------------------------------------------

  TransportRoutes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransportRoutes& from);
  void MergeFrom(const TransportRoutes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .OsmAnd.OBF.TransportRoute routes = 6;
  inline int routes_size() const;
  inline void clear_routes();
  static const int kRoutesFieldNumber = 6;
  inline const ::OsmAnd::OBF::TransportRoute& routes(int index) const;
  inline ::OsmAnd::OBF::TransportRoute* mutable_routes(int index);
  inline ::OsmAnd::OBF::TransportRoute* add_routes();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportRoute >&
      routes() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportRoute >*
      mutable_routes();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.TransportRoutes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportRoute > routes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static TransportRoutes* default_instance_;
};
// -------------------------------------------------------------------

class TransportRoute : public ::google::protobuf::Message {
 public:
  TransportRoute();
  virtual ~TransportRoute();

  TransportRoute(const TransportRoute& from);

  inline TransportRoute& operator=(const TransportRoute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransportRoute& default_instance();

  void Swap(TransportRoute* other);

  // implements Message ----------------------------------------------

  TransportRoute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransportRoute& from);
  void MergeFrom(const TransportRoute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional uint32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 operator = 4;
  inline bool has_operator_() const;
  inline void clear_operator_();
  static const int kOperatorFieldNumber = 4;
  inline ::google::protobuf::uint32 operator_() const;
  inline void set_operator_(::google::protobuf::uint32 value);

  // optional string ref = 5;
  inline bool has_ref() const;
  inline void clear_ref();
  static const int kRefFieldNumber = 5;
  inline const ::std::string& ref() const;
  inline void set_ref(const ::std::string& value);
  inline void set_ref(const char* value);
  inline void set_ref(const char* value, size_t size);
  inline ::std::string* mutable_ref();
  inline ::std::string* release_ref();
  inline void set_allocated_ref(::std::string* ref);

  // optional uint32 name = 6;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 6;
  inline ::google::protobuf::uint32 name() const;
  inline void set_name(::google::protobuf::uint32 value);

  // optional uint32 name_en = 7;
  inline bool has_name_en() const;
  inline void clear_name_en();
  static const int kNameEnFieldNumber = 7;
  inline ::google::protobuf::uint32 name_en() const;
  inline void set_name_en(::google::protobuf::uint32 value);

  // optional uint32 distance = 8;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 8;
  inline ::google::protobuf::uint32 distance() const;
  inline void set_distance(::google::protobuf::uint32 value);

  // optional uint32 color = 9;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 9;
  inline ::google::protobuf::uint32 color() const;
  inline void set_color(::google::protobuf::uint32 value);

  // repeated .OsmAnd.OBF.TransportRouteStop directStops = 15;
  inline int directstops_size() const;
  inline void clear_directstops();
  static const int kDirectStopsFieldNumber = 15;
  inline const ::OsmAnd::OBF::TransportRouteStop& directstops(int index) const;
  inline ::OsmAnd::OBF::TransportRouteStop* mutable_directstops(int index);
  inline ::OsmAnd::OBF::TransportRouteStop* add_directstops();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportRouteStop >&
      directstops() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportRouteStop >*
      mutable_directstops();

  // repeated .OsmAnd.OBF.TransportRouteStop reverseStops = 16;
  inline int reversestops_size() const;
  inline void clear_reversestops();
  static const int kReverseStopsFieldNumber = 16;
  inline const ::OsmAnd::OBF::TransportRouteStop& reversestops(int index) const;
  inline ::OsmAnd::OBF::TransportRouteStop* mutable_reversestops(int index);
  inline ::OsmAnd::OBF::TransportRouteStop* add_reversestops();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportRouteStop >&
      reversestops() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportRouteStop >*
      mutable_reversestops();

  // optional bytes geometry = 17;
  inline bool has_geometry() const;
  inline void clear_geometry();
  static const int kGeometryFieldNumber = 17;
  inline const ::std::string& geometry() const;
  inline void set_geometry(const ::std::string& value);
  inline void set_geometry(const char* value);
  inline void set_geometry(const void* value, size_t size);
  inline ::std::string* mutable_geometry();
  inline ::std::string* release_geometry();
  inline void set_allocated_geometry(::std::string* geometry);

  // repeated .OsmAnd.OBF.TransportRouteSchedule scheduleTrip = 18;
  inline int scheduletrip_size() const;
  inline void clear_scheduletrip();
  static const int kScheduleTripFieldNumber = 18;
  inline const ::OsmAnd::OBF::TransportRouteSchedule& scheduletrip(int index) const;
  inline ::OsmAnd::OBF::TransportRouteSchedule* mutable_scheduletrip(int index);
  inline ::OsmAnd::OBF::TransportRouteSchedule* add_scheduletrip();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportRouteSchedule >&
      scheduletrip() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportRouteSchedule >*
      mutable_scheduletrip();

  // repeated uint32 attributeTagIds = 19;
  inline int attributetagids_size() const;
  inline void clear_attributetagids();
  static const int kAttributeTagIdsFieldNumber = 19;
  inline ::google::protobuf::uint32 attributetagids(int index) const;
  inline void set_attributetagids(int index, ::google::protobuf::uint32 value);
  inline void add_attributetagids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      attributetagids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_attributetagids();

  // repeated bytes attributeTextTagValues = 20;
  inline int attributetexttagvalues_size() const;
  inline void clear_attributetexttagvalues();
  static const int kAttributeTextTagValuesFieldNumber = 20;
  inline const ::std::string& attributetexttagvalues(int index) const;
  inline ::std::string* mutable_attributetexttagvalues(int index);
  inline void set_attributetexttagvalues(int index, const ::std::string& value);
  inline void set_attributetexttagvalues(int index, const char* value);
  inline void set_attributetexttagvalues(int index, const void* value, size_t size);
  inline ::std::string* add_attributetexttagvalues();
  inline void add_attributetexttagvalues(const ::std::string& value);
  inline void add_attributetexttagvalues(const char* value);
  inline void add_attributetexttagvalues(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& attributetexttagvalues() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_attributetexttagvalues();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.TransportRoute)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_operator_();
  inline void clear_has_operator_();
  inline void set_has_ref();
  inline void clear_has_ref();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_name_en();
  inline void clear_has_name_en();
  inline void set_has_distance();
  inline void clear_has_distance();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_geometry();
  inline void clear_has_geometry();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 operator__;
  ::std::string* ref_;
  ::google::protobuf::uint32 name_;
  ::google::protobuf::uint32 name_en_;
  ::google::protobuf::uint32 distance_;
  ::google::protobuf::uint32 color_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportRouteStop > directstops_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportRouteStop > reversestops_;
  ::std::string* geometry_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportRouteSchedule > scheduletrip_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > attributetagids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> attributetexttagvalues_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static TransportRoute* default_instance_;
};
// -------------------------------------------------------------------

class IncompleteTransportRoutes : public ::google::protobuf::Message {
 public:
  IncompleteTransportRoutes();
  virtual ~IncompleteTransportRoutes();

  IncompleteTransportRoutes(const IncompleteTransportRoutes& from);

  inline IncompleteTransportRoutes& operator=(const IncompleteTransportRoutes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IncompleteTransportRoutes& default_instance();

  void Swap(IncompleteTransportRoutes* other);

  // implements Message ----------------------------------------------

  IncompleteTransportRoutes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IncompleteTransportRoutes& from);
  void MergeFrom(const IncompleteTransportRoutes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .OsmAnd.OBF.IncompleteTransportRoute routes = 6;
  inline int routes_size() const;
  inline void clear_routes();
  static const int kRoutesFieldNumber = 6;
  inline const ::OsmAnd::OBF::IncompleteTransportRoute& routes(int index) const;
  inline ::OsmAnd::OBF::IncompleteTransportRoute* mutable_routes(int index);
  inline ::OsmAnd::OBF::IncompleteTransportRoute* add_routes();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::IncompleteTransportRoute >&
      routes() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::IncompleteTransportRoute >*
      mutable_routes();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.IncompleteTransportRoutes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::IncompleteTransportRoute > routes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static IncompleteTransportRoutes* default_instance_;
};
// -------------------------------------------------------------------

class IncompleteTransportRoute : public ::google::protobuf::Message {
 public:
  IncompleteTransportRoute();
  virtual ~IncompleteTransportRoute();

  IncompleteTransportRoute(const IncompleteTransportRoute& from);

  inline IncompleteTransportRoute& operator=(const IncompleteTransportRoute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IncompleteTransportRoute& default_instance();

  void Swap(IncompleteTransportRoute* other);

  // implements Message ----------------------------------------------

  IncompleteTransportRoute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IncompleteTransportRoute& from);
  void MergeFrom(const IncompleteTransportRoute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional uint32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 operator = 4;
  inline bool has_operator_() const;
  inline void clear_operator_();
  static const int kOperatorFieldNumber = 4;
  inline ::google::protobuf::uint32 operator_() const;
  inline void set_operator_(::google::protobuf::uint32 value);

  // optional uint32 ref = 5;
  inline bool has_ref() const;
  inline void clear_ref();
  static const int kRefFieldNumber = 5;
  inline ::google::protobuf::uint32 ref() const;
  inline void set_ref(::google::protobuf::uint32 value);

  // required uint32 routeRef = 7;
  inline bool has_routeref() const;
  inline void clear_routeref();
  static const int kRouteRefFieldNumber = 7;
  inline ::google::protobuf::uint32 routeref() const;
  inline void set_routeref(::google::protobuf::uint32 value);

  // repeated uint32 missingStops = 8;
  inline int missingstops_size() const;
  inline void clear_missingstops();
  static const int kMissingStopsFieldNumber = 8;
  inline ::google::protobuf::uint32 missingstops(int index) const;
  inline void set_missingstops(int index, ::google::protobuf::uint32 value);
  inline void add_missingstops(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      missingstops() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_missingstops();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.IncompleteTransportRoute)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_operator_();
  inline void clear_has_operator_();
  inline void set_has_ref();
  inline void clear_has_ref();
  inline void set_has_routeref();
  inline void clear_has_routeref();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 operator__;
  ::google::protobuf::uint32 ref_;
  ::google::protobuf::uint32 routeref_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > missingstops_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static IncompleteTransportRoute* default_instance_;
};
// -------------------------------------------------------------------

class TransportRouteSchedule : public ::google::protobuf::Message {
 public:
  TransportRouteSchedule();
  virtual ~TransportRouteSchedule();

  TransportRouteSchedule(const TransportRouteSchedule& from);

  inline TransportRouteSchedule& operator=(const TransportRouteSchedule& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransportRouteSchedule& default_instance();

  void Swap(TransportRouteSchedule* other);

  // implements Message ----------------------------------------------

  TransportRouteSchedule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransportRouteSchedule& from);
  void MergeFrom(const TransportRouteSchedule& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes avgStopIntervals = 1;
  inline bool has_avgstopintervals() const;
  inline void clear_avgstopintervals();
  static const int kAvgStopIntervalsFieldNumber = 1;
  inline const ::std::string& avgstopintervals() const;
  inline void set_avgstopintervals(const ::std::string& value);
  inline void set_avgstopintervals(const char* value);
  inline void set_avgstopintervals(const void* value, size_t size);
  inline ::std::string* mutable_avgstopintervals();
  inline ::std::string* release_avgstopintervals();
  inline void set_allocated_avgstopintervals(::std::string* avgstopintervals);

  // optional bytes avgWaitIntervals = 2;
  inline bool has_avgwaitintervals() const;
  inline void clear_avgwaitintervals();
  static const int kAvgWaitIntervalsFieldNumber = 2;
  inline const ::std::string& avgwaitintervals() const;
  inline void set_avgwaitintervals(const ::std::string& value);
  inline void set_avgwaitintervals(const char* value);
  inline void set_avgwaitintervals(const void* value, size_t size);
  inline ::std::string* mutable_avgwaitintervals();
  inline ::std::string* release_avgwaitintervals();
  inline void set_allocated_avgwaitintervals(::std::string* avgwaitintervals);

  // optional bytes tripIntervals = 3;
  inline bool has_tripintervals() const;
  inline void clear_tripintervals();
  static const int kTripIntervalsFieldNumber = 3;
  inline const ::std::string& tripintervals() const;
  inline void set_tripintervals(const ::std::string& value);
  inline void set_tripintervals(const char* value);
  inline void set_tripintervals(const void* value, size_t size);
  inline ::std::string* mutable_tripintervals();
  inline ::std::string* release_tripintervals();
  inline void set_allocated_tripintervals(::std::string* tripintervals);

  // repeated .OsmAnd.OBF.TransportRouteScheduleException exceptions = 8;
  inline int exceptions_size() const;
  inline void clear_exceptions();
  static const int kExceptionsFieldNumber = 8;
  inline const ::OsmAnd::OBF::TransportRouteScheduleException& exceptions(int index) const;
  inline ::OsmAnd::OBF::TransportRouteScheduleException* mutable_exceptions(int index);
  inline ::OsmAnd::OBF::TransportRouteScheduleException* add_exceptions();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportRouteScheduleException >&
      exceptions() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportRouteScheduleException >*
      mutable_exceptions();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.TransportRouteSchedule)
 private:
  inline void set_has_avgstopintervals();
  inline void clear_has_avgstopintervals();
  inline void set_has_avgwaitintervals();
  inline void clear_has_avgwaitintervals();
  inline void set_has_tripintervals();
  inline void clear_has_tripintervals();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* avgstopintervals_;
  ::std::string* avgwaitintervals_;
  ::std::string* tripintervals_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportRouteScheduleException > exceptions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static TransportRouteSchedule* default_instance_;
};
// -------------------------------------------------------------------

class TransportRouteScheduleException : public ::google::protobuf::Message {
 public:
  TransportRouteScheduleException();
  virtual ~TransportRouteScheduleException();

  TransportRouteScheduleException(const TransportRouteScheduleException& from);

  inline TransportRouteScheduleException& operator=(const TransportRouteScheduleException& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransportRouteScheduleException& default_instance();

  void Swap(TransportRouteScheduleException* other);

  // implements Message ----------------------------------------------

  TransportRouteScheduleException* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransportRouteScheduleException& from);
  void MergeFrom(const TransportRouteScheduleException& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 tripIndexes = 1;
  inline int tripindexes_size() const;
  inline void clear_tripindexes();
  static const int kTripIndexesFieldNumber = 1;
  inline ::google::protobuf::uint32 tripindexes(int index) const;
  inline void set_tripindexes(int index, ::google::protobuf::uint32 value);
  inline void add_tripindexes(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      tripindexes() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_tripindexes();

  // repeated uint32 stopIndexes = 2;
  inline int stopindexes_size() const;
  inline void clear_stopindexes();
  static const int kStopIndexesFieldNumber = 2;
  inline ::google::protobuf::uint32 stopindexes(int index) const;
  inline void set_stopindexes(int index, ::google::protobuf::uint32 value);
  inline void add_stopindexes(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      stopindexes() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_stopindexes();

  // optional bool available = 3;
  inline bool has_available() const;
  inline void clear_available();
  static const int kAvailableFieldNumber = 3;
  inline bool available() const;
  inline void set_available(bool value);

  // repeated uint32 delayArrival = 5;
  inline int delayarrival_size() const;
  inline void clear_delayarrival();
  static const int kDelayArrivalFieldNumber = 5;
  inline ::google::protobuf::uint32 delayarrival(int index) const;
  inline void set_delayarrival(int index, ::google::protobuf::uint32 value);
  inline void add_delayarrival(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      delayarrival() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_delayarrival();

  // repeated int32 deltaWaitInterval = 6;
  inline int deltawaitinterval_size() const;
  inline void clear_deltawaitinterval();
  static const int kDeltaWaitIntervalFieldNumber = 6;
  inline ::google::protobuf::int32 deltawaitinterval(int index) const;
  inline void set_deltawaitinterval(int index, ::google::protobuf::int32 value);
  inline void add_deltawaitinterval(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      deltawaitinterval() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_deltawaitinterval();

  // repeated uint32 dayOfWeekRestriction = 7;
  inline int dayofweekrestriction_size() const;
  inline void clear_dayofweekrestriction();
  static const int kDayOfWeekRestrictionFieldNumber = 7;
  inline ::google::protobuf::uint32 dayofweekrestriction(int index) const;
  inline void set_dayofweekrestriction(int index, ::google::protobuf::uint32 value);
  inline void add_dayofweekrestriction(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      dayofweekrestriction() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_dayofweekrestriction();

  // repeated uint32 dayOfYearRestriction = 8;
  inline int dayofyearrestriction_size() const;
  inline void clear_dayofyearrestriction();
  static const int kDayOfYearRestrictionFieldNumber = 8;
  inline ::google::protobuf::uint32 dayofyearrestriction(int index) const;
  inline void set_dayofyearrestriction(int index, ::google::protobuf::uint32 value);
  inline void add_dayofyearrestriction(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      dayofyearrestriction() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_dayofyearrestriction();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.TransportRouteScheduleException)
 private:
  inline void set_has_available();
  inline void clear_has_available();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > tripindexes_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > stopindexes_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > delayarrival_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > deltawaitinterval_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > dayofweekrestriction_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > dayofyearrestriction_;
  bool available_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static TransportRouteScheduleException* default_instance_;
};
// -------------------------------------------------------------------

class TransportRouteStop : public ::google::protobuf::Message {
 public:
  TransportRouteStop();
  virtual ~TransportRouteStop();

  TransportRouteStop(const TransportRouteStop& from);

  inline TransportRouteStop& operator=(const TransportRouteStop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransportRouteStop& default_instance();

  void Swap(TransportRouteStop* other);

  // implements Message ----------------------------------------------

  TransportRouteStop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransportRouteStop& from);
  void MergeFrom(const TransportRouteStop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required sint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // required sint32 dx = 2;
  inline bool has_dx() const;
  inline void clear_dx();
  static const int kDxFieldNumber = 2;
  inline ::google::protobuf::int32 dx() const;
  inline void set_dx(::google::protobuf::int32 value);

  // required sint32 dy = 3;
  inline bool has_dy() const;
  inline void clear_dy();
  static const int kDyFieldNumber = 3;
  inline ::google::protobuf::int32 dy() const;
  inline void set_dy(::google::protobuf::int32 value);

  // required uint32 name = 6;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 6;
  inline ::google::protobuf::uint32 name() const;
  inline void set_name(::google::protobuf::uint32 value);

  // optional uint32 name_en = 7;
  inline bool has_name_en() const;
  inline void clear_name_en();
  static const int kNameEnFieldNumber = 7;
  inline ::google::protobuf::uint32 name_en() const;
  inline void set_name_en(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.TransportRouteStop)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_dx();
  inline void clear_has_dx();
  inline void set_has_dy();
  inline void clear_has_dy();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_name_en();
  inline void clear_has_name_en();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 id_;
  ::google::protobuf::int32 dx_;
  ::google::protobuf::int32 dy_;
  ::google::protobuf::uint32 name_;
  ::google::protobuf::uint32 name_en_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static TransportRouteStop* default_instance_;
};
// -------------------------------------------------------------------

class TransportStop : public ::google::protobuf::Message {
 public:
  TransportStop();
  virtual ~TransportStop();

  TransportStop(const TransportStop& from);

  inline TransportStop& operator=(const TransportStop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransportStop& default_instance();

  void Swap(TransportStop* other);

  // implements Message ----------------------------------------------

  TransportStop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransportStop& from);
  void MergeFrom(const TransportStop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required sint32 dx = 1;
  inline bool has_dx() const;
  inline void clear_dx();
  static const int kDxFieldNumber = 1;
  inline ::google::protobuf::int32 dx() const;
  inline void set_dx(::google::protobuf::int32 value);

  // required sint32 dy = 2;
  inline bool has_dy() const;
  inline void clear_dy();
  static const int kDyFieldNumber = 2;
  inline ::google::protobuf::int32 dy() const;
  inline void set_dy(::google::protobuf::int32 value);

  // required sint64 id = 5;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 5;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // required uint32 name = 6;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 6;
  inline ::google::protobuf::uint32 name() const;
  inline void set_name(::google::protobuf::uint32 value);

  // optional uint32 name_en = 7;
  inline bool has_name_en() const;
  inline void clear_name_en();
  static const int kNameEnFieldNumber = 7;
  inline ::google::protobuf::uint32 name_en() const;
  inline void set_name_en(::google::protobuf::uint32 value);

  // optional bytes additionalNamePairs = 8;
  inline bool has_additionalnamepairs() const;
  inline void clear_additionalnamepairs();
  static const int kAdditionalNamePairsFieldNumber = 8;
  inline const ::std::string& additionalnamepairs() const;
  inline void set_additionalnamepairs(const ::std::string& value);
  inline void set_additionalnamepairs(const char* value);
  inline void set_additionalnamepairs(const void* value, size_t size);
  inline ::std::string* mutable_additionalnamepairs();
  inline ::std::string* release_additionalnamepairs();
  inline void set_allocated_additionalnamepairs(::std::string* additionalnamepairs);

  // repeated .OsmAnd.OBF.TransportStopExit exits = 9;
  inline int exits_size() const;
  inline void clear_exits();
  static const int kExitsFieldNumber = 9;
  inline const ::OsmAnd::OBF::TransportStopExit& exits(int index) const;
  inline ::OsmAnd::OBF::TransportStopExit* mutable_exits(int index);
  inline ::OsmAnd::OBF::TransportStopExit* add_exits();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportStopExit >&
      exits() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportStopExit >*
      mutable_exits();

  // repeated uint32 routes = 16;
  inline int routes_size() const;
  inline void clear_routes();
  static const int kRoutesFieldNumber = 16;
  inline ::google::protobuf::uint32 routes(int index) const;
  inline void set_routes(int index, ::google::protobuf::uint32 value);
  inline void add_routes(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      routes() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_routes();

  // repeated uint64 deletedRoutesIds = 20;
  inline int deletedroutesids_size() const;
  inline void clear_deletedroutesids();
  static const int kDeletedRoutesIdsFieldNumber = 20;
  inline ::google::protobuf::uint64 deletedroutesids(int index) const;
  inline void set_deletedroutesids(int index, ::google::protobuf::uint64 value);
  inline void add_deletedroutesids(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      deletedroutesids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_deletedroutesids();

  // repeated uint64 routesIds = 22;
  inline int routesids_size() const;
  inline void clear_routesids();
  static const int kRoutesIdsFieldNumber = 22;
  inline ::google::protobuf::uint64 routesids(int index) const;
  inline void set_routesids(int index, ::google::protobuf::uint64 value);
  inline void add_routesids(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      routesids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_routesids();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.TransportStop)
 private:
  inline void set_has_dx();
  inline void clear_has_dx();
  inline void set_has_dy();
  inline void clear_has_dy();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_name_en();
  inline void clear_has_name_en();
  inline void set_has_additionalnamepairs();
  inline void clear_has_additionalnamepairs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 dx_;
  ::google::protobuf::int32 dy_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::uint32 name_;
  ::google::protobuf::uint32 name_en_;
  ::std::string* additionalnamepairs_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportStopExit > exits_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > routes_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > deletedroutesids_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > routesids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static TransportStop* default_instance_;
};
// -------------------------------------------------------------------

class TransportStopExit : public ::google::protobuf::Message {
 public:
  TransportStopExit();
  virtual ~TransportStopExit();

  TransportStopExit(const TransportStopExit& from);

  inline TransportStopExit& operator=(const TransportStopExit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransportStopExit& default_instance();

  void Swap(TransportStopExit* other);

  // implements Message ----------------------------------------------

  TransportStopExit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransportStopExit& from);
  void MergeFrom(const TransportStopExit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required sint32 dx = 1;
  inline bool has_dx() const;
  inline void clear_dx();
  static const int kDxFieldNumber = 1;
  inline ::google::protobuf::int32 dx() const;
  inline void set_dx(::google::protobuf::int32 value);

  // required sint32 dy = 2;
  inline bool has_dy() const;
  inline void clear_dy();
  static const int kDyFieldNumber = 2;
  inline ::google::protobuf::int32 dy() const;
  inline void set_dy(::google::protobuf::int32 value);

  // required uint32 ref = 3;
  inline bool has_ref() const;
  inline void clear_ref();
  static const int kRefFieldNumber = 3;
  inline ::google::protobuf::uint32 ref() const;
  inline void set_ref(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.TransportStopExit)
 private:
  inline void set_has_dx();
  inline void clear_has_dx();
  inline void set_has_dy();
  inline void clear_has_dy();
  inline void set_has_ref();
  inline void clear_has_ref();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 dx_;
  ::google::protobuf::int32 dy_;
  ::google::protobuf::uint32 ref_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static TransportStopExit* default_instance_;
};
// -------------------------------------------------------------------

class TransportStopsTree : public ::google::protobuf::Message {
 public:
  TransportStopsTree();
  virtual ~TransportStopsTree();

  TransportStopsTree(const TransportStopsTree& from);

  inline TransportStopsTree& operator=(const TransportStopsTree& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransportStopsTree& default_instance();

  void Swap(TransportStopsTree* other);

  // implements Message ----------------------------------------------

  TransportStopsTree* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransportStopsTree& from);
  void MergeFrom(const TransportStopsTree& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required sint32 left = 1;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 1;
  inline ::google::protobuf::int32 left() const;
  inline void set_left(::google::protobuf::int32 value);

  // required sint32 right = 2;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 2;
  inline ::google::protobuf::int32 right() const;
  inline void set_right(::google::protobuf::int32 value);

  // required sint32 top = 3;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 3;
  inline ::google::protobuf::int32 top() const;
  inline void set_top(::google::protobuf::int32 value);

  // required sint32 bottom = 4;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 4;
  inline ::google::protobuf::int32 bottom() const;
  inline void set_bottom(::google::protobuf::int32 value);

  // repeated .OsmAnd.OBF.TransportStopsTree subtrees = 7;
  inline int subtrees_size() const;
  inline void clear_subtrees();
  static const int kSubtreesFieldNumber = 7;
  inline const ::OsmAnd::OBF::TransportStopsTree& subtrees(int index) const;
  inline ::OsmAnd::OBF::TransportStopsTree* mutable_subtrees(int index);
  inline ::OsmAnd::OBF::TransportStopsTree* add_subtrees();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportStopsTree >&
      subtrees() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportStopsTree >*
      mutable_subtrees();

  // repeated .OsmAnd.OBF.TransportStop leafs = 8;
  inline int leafs_size() const;
  inline void clear_leafs();
  static const int kLeafsFieldNumber = 8;
  inline const ::OsmAnd::OBF::TransportStop& leafs(int index) const;
  inline ::OsmAnd::OBF::TransportStop* mutable_leafs(int index);
  inline ::OsmAnd::OBF::TransportStop* add_leafs();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportStop >&
      leafs() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportStop >*
      mutable_leafs();

  // optional uint64 baseId = 16;
  inline bool has_baseid() const;
  inline void clear_baseid();
  static const int kBaseIdFieldNumber = 16;
  inline ::google::protobuf::uint64 baseid() const;
  inline void set_baseid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.TransportStopsTree)
 private:
  inline void set_has_left();
  inline void clear_has_left();
  inline void set_has_right();
  inline void clear_has_right();
  inline void set_has_top();
  inline void clear_has_top();
  inline void set_has_bottom();
  inline void clear_has_bottom();
  inline void set_has_baseid();
  inline void clear_has_baseid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 right_;
  ::google::protobuf::int32 top_;
  ::google::protobuf::int32 bottom_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportStopsTree > subtrees_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportStop > leafs_;
  ::google::protobuf::uint64 baseid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static TransportStopsTree* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndTransportIndex : public ::google::protobuf::Message {
 public:
  OsmAndTransportIndex();
  virtual ~OsmAndTransportIndex();

  OsmAndTransportIndex(const OsmAndTransportIndex& from);

  inline OsmAndTransportIndex& operator=(const OsmAndTransportIndex& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndTransportIndex& default_instance();

  void Swap(OsmAndTransportIndex* other);

  // implements Message ----------------------------------------------

  OsmAndTransportIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndTransportIndex& from);
  void MergeFrom(const OsmAndTransportIndex& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .OsmAnd.OBF.TransportRoutes routes = 3;
  inline bool has_routes() const;
  inline void clear_routes();
  static const int kRoutesFieldNumber = 3;
  inline const ::OsmAnd::OBF::TransportRoutes& routes() const;
  inline ::OsmAnd::OBF::TransportRoutes* mutable_routes();
  inline ::OsmAnd::OBF::TransportRoutes* release_routes();
  inline void set_allocated_routes(::OsmAnd::OBF::TransportRoutes* routes);

  // optional .OsmAnd.OBF.TransportStopsTree stops = 6;
  inline bool has_stops() const;
  inline void clear_stops();
  static const int kStopsFieldNumber = 6;
  inline const ::OsmAnd::OBF::TransportStopsTree& stops() const;
  inline ::OsmAnd::OBF::TransportStopsTree* mutable_stops();
  inline ::OsmAnd::OBF::TransportStopsTree* release_stops();
  inline void set_allocated_stops(::OsmAnd::OBF::TransportStopsTree* stops);

  // optional .OsmAnd.OBF.IncompleteTransportRoutes incompleteRoutes = 8;
  inline bool has_incompleteroutes() const;
  inline void clear_incompleteroutes();
  static const int kIncompleteRoutesFieldNumber = 8;
  inline const ::OsmAnd::OBF::IncompleteTransportRoutes& incompleteroutes() const;
  inline ::OsmAnd::OBF::IncompleteTransportRoutes* mutable_incompleteroutes();
  inline ::OsmAnd::OBF::IncompleteTransportRoutes* release_incompleteroutes();
  inline void set_allocated_incompleteroutes(::OsmAnd::OBF::IncompleteTransportRoutes* incompleteroutes);

  // required .OsmAnd.OBF.StringTable stringTable = 9;
  inline bool has_stringtable() const;
  inline void clear_stringtable();
  static const int kStringTableFieldNumber = 9;
  inline const ::OsmAnd::OBF::StringTable& stringtable() const;
  inline ::OsmAnd::OBF::StringTable* mutable_stringtable();
  inline ::OsmAnd::OBF::StringTable* release_stringtable();
  inline void set_allocated_stringtable(::OsmAnd::OBF::StringTable* stringtable);

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndTransportIndex)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_routes();
  inline void clear_has_routes();
  inline void set_has_stops();
  inline void clear_has_stops();
  inline void set_has_incompleteroutes();
  inline void clear_has_incompleteroutes();
  inline void set_has_stringtable();
  inline void clear_has_stringtable();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::OsmAnd::OBF::TransportRoutes* routes_;
  ::OsmAnd::OBF::TransportStopsTree* stops_;
  ::OsmAnd::OBF::IncompleteTransportRoutes* incompleteroutes_;
  ::OsmAnd::OBF::StringTable* stringtable_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndTransportIndex* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndPoiIndex : public ::google::protobuf::Message {
 public:
  OsmAndPoiIndex();
  virtual ~OsmAndPoiIndex();

  OsmAndPoiIndex(const OsmAndPoiIndex& from);

  inline OsmAndPoiIndex& operator=(const OsmAndPoiIndex& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndPoiIndex& default_instance();

  void Swap(OsmAndPoiIndex* other);

  // implements Message ----------------------------------------------

  OsmAndPoiIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndPoiIndex& from);
  void MergeFrom(const OsmAndPoiIndex& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .OsmAnd.OBF.OsmAndTileBox boundaries = 2;
  inline bool has_boundaries() const;
  inline void clear_boundaries();
  static const int kBoundariesFieldNumber = 2;
  inline const ::OsmAnd::OBF::OsmAndTileBox& boundaries() const;
  inline ::OsmAnd::OBF::OsmAndTileBox* mutable_boundaries();
  inline ::OsmAnd::OBF::OsmAndTileBox* release_boundaries();
  inline void set_allocated_boundaries(::OsmAnd::OBF::OsmAndTileBox* boundaries);

  // repeated .OsmAnd.OBF.OsmAndCategoryTable categoriesTable = 3;
  inline int categoriestable_size() const;
  inline void clear_categoriestable();
  static const int kCategoriesTableFieldNumber = 3;
  inline const ::OsmAnd::OBF::OsmAndCategoryTable& categoriestable(int index) const;
  inline ::OsmAnd::OBF::OsmAndCategoryTable* mutable_categoriestable(int index);
  inline ::OsmAnd::OBF::OsmAndCategoryTable* add_categoriestable();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndCategoryTable >&
      categoriestable() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndCategoryTable >*
      mutable_categoriestable();

  // optional .OsmAnd.OBF.OsmAndPoiNameIndex nameIndex = 4;
  inline bool has_nameindex() const;
  inline void clear_nameindex();
  static const int kNameIndexFieldNumber = 4;
  inline const ::OsmAnd::OBF::OsmAndPoiNameIndex& nameindex() const;
  inline ::OsmAnd::OBF::OsmAndPoiNameIndex* mutable_nameindex();
  inline ::OsmAnd::OBF::OsmAndPoiNameIndex* release_nameindex();
  inline void set_allocated_nameindex(::OsmAnd::OBF::OsmAndPoiNameIndex* nameindex);

  // optional .OsmAnd.OBF.OsmAndSubtypesTable subtypesTable = 5;
  inline bool has_subtypestable() const;
  inline void clear_subtypestable();
  static const int kSubtypesTableFieldNumber = 5;
  inline const ::OsmAnd::OBF::OsmAndSubtypesTable& subtypestable() const;
  inline ::OsmAnd::OBF::OsmAndSubtypesTable* mutable_subtypestable();
  inline ::OsmAnd::OBF::OsmAndSubtypesTable* release_subtypestable();
  inline void set_allocated_subtypestable(::OsmAnd::OBF::OsmAndSubtypesTable* subtypestable);

  // repeated .OsmAnd.OBF.OsmAndPoiBox boxes = 6;
  inline int boxes_size() const;
  inline void clear_boxes();
  static const int kBoxesFieldNumber = 6;
  inline const ::OsmAnd::OBF::OsmAndPoiBox& boxes(int index) const;
  inline ::OsmAnd::OBF::OsmAndPoiBox* mutable_boxes(int index);
  inline ::OsmAnd::OBF::OsmAndPoiBox* add_boxes();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiBox >&
      boxes() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiBox >*
      mutable_boxes();

  // repeated .OsmAnd.OBF.OsmAndPoiBoxData poiData = 9;
  inline int poidata_size() const;
  inline void clear_poidata();
  static const int kPoiDataFieldNumber = 9;
  inline const ::OsmAnd::OBF::OsmAndPoiBoxData& poidata(int index) const;
  inline ::OsmAnd::OBF::OsmAndPoiBoxData* mutable_poidata(int index);
  inline ::OsmAnd::OBF::OsmAndPoiBoxData* add_poidata();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiBoxData >&
      poidata() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiBoxData >*
      mutable_poidata();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndPoiIndex)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_boundaries();
  inline void clear_has_boundaries();
  inline void set_has_nameindex();
  inline void clear_has_nameindex();
  inline void set_has_subtypestable();
  inline void clear_has_subtypestable();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::OsmAnd::OBF::OsmAndTileBox* boundaries_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndCategoryTable > categoriestable_;
  ::OsmAnd::OBF::OsmAndPoiNameIndex* nameindex_;
  ::OsmAnd::OBF::OsmAndSubtypesTable* subtypestable_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiBox > boxes_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiBoxData > poidata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndPoiIndex* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndPoiNameIndex_OsmAndPoiNameIndexData : public ::google::protobuf::Message {
 public:
  OsmAndPoiNameIndex_OsmAndPoiNameIndexData();
  virtual ~OsmAndPoiNameIndex_OsmAndPoiNameIndexData();

  OsmAndPoiNameIndex_OsmAndPoiNameIndexData(const OsmAndPoiNameIndex_OsmAndPoiNameIndexData& from);

  inline OsmAndPoiNameIndex_OsmAndPoiNameIndexData& operator=(const OsmAndPoiNameIndex_OsmAndPoiNameIndexData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndPoiNameIndex_OsmAndPoiNameIndexData& default_instance();

  void Swap(OsmAndPoiNameIndex_OsmAndPoiNameIndexData* other);

  // implements Message ----------------------------------------------

  OsmAndPoiNameIndex_OsmAndPoiNameIndexData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndPoiNameIndex_OsmAndPoiNameIndexData& from);
  void MergeFrom(const OsmAndPoiNameIndex_OsmAndPoiNameIndexData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .OsmAnd.OBF.OsmAndPoiNameIndexDataAtom atoms = 3;
  inline int atoms_size() const;
  inline void clear_atoms();
  static const int kAtomsFieldNumber = 3;
  inline const ::OsmAnd::OBF::OsmAndPoiNameIndexDataAtom& atoms(int index) const;
  inline ::OsmAnd::OBF::OsmAndPoiNameIndexDataAtom* mutable_atoms(int index);
  inline ::OsmAnd::OBF::OsmAndPoiNameIndexDataAtom* add_atoms();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiNameIndexDataAtom >&
      atoms() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiNameIndexDataAtom >*
      mutable_atoms();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndPoiNameIndex.OsmAndPoiNameIndexData)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiNameIndexDataAtom > atoms_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndPoiNameIndex_OsmAndPoiNameIndexData* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndPoiNameIndex : public ::google::protobuf::Message {
 public:
  OsmAndPoiNameIndex();
  virtual ~OsmAndPoiNameIndex();

  OsmAndPoiNameIndex(const OsmAndPoiNameIndex& from);

  inline OsmAndPoiNameIndex& operator=(const OsmAndPoiNameIndex& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndPoiNameIndex& default_instance();

  void Swap(OsmAndPoiNameIndex* other);

  // implements Message ----------------------------------------------

  OsmAndPoiNameIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndPoiNameIndex& from);
  void MergeFrom(const OsmAndPoiNameIndex& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef OsmAndPoiNameIndex_OsmAndPoiNameIndexData OsmAndPoiNameIndexData;

  // accessors -------------------------------------------------------

  // required .OsmAnd.OBF.IndexedStringTable table = 3;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 3;
  inline const ::OsmAnd::OBF::IndexedStringTable& table() const;
  inline ::OsmAnd::OBF::IndexedStringTable* mutable_table();
  inline ::OsmAnd::OBF::IndexedStringTable* release_table();
  inline void set_allocated_table(::OsmAnd::OBF::IndexedStringTable* table);

  // repeated .OsmAnd.OBF.OsmAndPoiNameIndex.OsmAndPoiNameIndexData data = 5;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 5;
  inline const ::OsmAnd::OBF::OsmAndPoiNameIndex_OsmAndPoiNameIndexData& data(int index) const;
  inline ::OsmAnd::OBF::OsmAndPoiNameIndex_OsmAndPoiNameIndexData* mutable_data(int index);
  inline ::OsmAnd::OBF::OsmAndPoiNameIndex_OsmAndPoiNameIndexData* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiNameIndex_OsmAndPoiNameIndexData >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiNameIndex_OsmAndPoiNameIndexData >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndPoiNameIndex)
 private:
  inline void set_has_table();
  inline void clear_has_table();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::OsmAnd::OBF::IndexedStringTable* table_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiNameIndex_OsmAndPoiNameIndexData > data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndPoiNameIndex* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndPoiNameIndexDataAtom : public ::google::protobuf::Message {
 public:
  OsmAndPoiNameIndexDataAtom();
  virtual ~OsmAndPoiNameIndexDataAtom();

  OsmAndPoiNameIndexDataAtom(const OsmAndPoiNameIndexDataAtom& from);

  inline OsmAndPoiNameIndexDataAtom& operator=(const OsmAndPoiNameIndexDataAtom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndPoiNameIndexDataAtom& default_instance();

  void Swap(OsmAndPoiNameIndexDataAtom* other);

  // implements Message ----------------------------------------------

  OsmAndPoiNameIndexDataAtom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndPoiNameIndexDataAtom& from);
  void MergeFrom(const OsmAndPoiNameIndexDataAtom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 zoom = 2;
  inline bool has_zoom() const;
  inline void clear_zoom();
  static const int kZoomFieldNumber = 2;
  inline ::google::protobuf::uint32 zoom() const;
  inline void set_zoom(::google::protobuf::uint32 value);

  // optional uint32 x = 3;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 3;
  inline ::google::protobuf::uint32 x() const;
  inline void set_x(::google::protobuf::uint32 value);

  // optional uint32 y = 4;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 4;
  inline ::google::protobuf::uint32 y() const;
  inline void set_y(::google::protobuf::uint32 value);

  // optional fixed32 shiftTo = 14;
  inline bool has_shiftto() const;
  inline void clear_shiftto();
  static const int kShiftToFieldNumber = 14;
  inline ::google::protobuf::uint32 shiftto() const;
  inline void set_shiftto(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndPoiNameIndexDataAtom)
 private:
  inline void set_has_zoom();
  inline void clear_has_zoom();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_shiftto();
  inline void clear_has_shiftto();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 zoom_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;
  ::google::protobuf::uint32 shiftto_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndPoiNameIndexDataAtom* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndCategoryTable : public ::google::protobuf::Message {
 public:
  OsmAndCategoryTable();
  virtual ~OsmAndCategoryTable();

  OsmAndCategoryTable(const OsmAndCategoryTable& from);

  inline OsmAndCategoryTable& operator=(const OsmAndCategoryTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndCategoryTable& default_instance();

  void Swap(OsmAndCategoryTable* other);

  // implements Message ----------------------------------------------

  OsmAndCategoryTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndCategoryTable& from);
  void MergeFrom(const OsmAndCategoryTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string category = 1;
  inline bool has_category() const;
  inline void clear_category();
  static const int kCategoryFieldNumber = 1;
  inline const ::std::string& category() const;
  inline void set_category(const ::std::string& value);
  inline void set_category(const char* value);
  inline void set_category(const char* value, size_t size);
  inline ::std::string* mutable_category();
  inline ::std::string* release_category();
  inline void set_allocated_category(::std::string* category);

  // repeated string subcategories = 3;
  inline int subcategories_size() const;
  inline void clear_subcategories();
  static const int kSubcategoriesFieldNumber = 3;
  inline const ::std::string& subcategories(int index) const;
  inline ::std::string* mutable_subcategories(int index);
  inline void set_subcategories(int index, const ::std::string& value);
  inline void set_subcategories(int index, const char* value);
  inline void set_subcategories(int index, const char* value, size_t size);
  inline ::std::string* add_subcategories();
  inline void add_subcategories(const ::std::string& value);
  inline void add_subcategories(const char* value);
  inline void add_subcategories(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& subcategories() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_subcategories();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndCategoryTable)
 private:
  inline void set_has_category();
  inline void clear_has_category();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* category_;
  ::google::protobuf::RepeatedPtrField< ::std::string> subcategories_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndCategoryTable* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndSubtypesTable : public ::google::protobuf::Message {
 public:
  OsmAndSubtypesTable();
  virtual ~OsmAndSubtypesTable();

  OsmAndSubtypesTable(const OsmAndSubtypesTable& from);

  inline OsmAndSubtypesTable& operator=(const OsmAndSubtypesTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndSubtypesTable& default_instance();

  void Swap(OsmAndSubtypesTable* other);

  // implements Message ----------------------------------------------

  OsmAndSubtypesTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndSubtypesTable& from);
  void MergeFrom(const OsmAndSubtypesTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .OsmAnd.OBF.OsmAndPoiSubtype subtypes = 4;
  inline int subtypes_size() const;
  inline void clear_subtypes();
  static const int kSubtypesFieldNumber = 4;
  inline const ::OsmAnd::OBF::OsmAndPoiSubtype& subtypes(int index) const;
  inline ::OsmAnd::OBF::OsmAndPoiSubtype* mutable_subtypes(int index);
  inline ::OsmAnd::OBF::OsmAndPoiSubtype* add_subtypes();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiSubtype >&
      subtypes() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiSubtype >*
      mutable_subtypes();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndSubtypesTable)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiSubtype > subtypes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndSubtypesTable* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndPoiSubtype : public ::google::protobuf::Message {
 public:
  OsmAndPoiSubtype();
  virtual ~OsmAndPoiSubtype();

  OsmAndPoiSubtype(const OsmAndPoiSubtype& from);

  inline OsmAndPoiSubtype& operator=(const OsmAndPoiSubtype& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndPoiSubtype& default_instance();

  void Swap(OsmAndPoiSubtype* other);

  // implements Message ----------------------------------------------

  OsmAndPoiSubtype* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndPoiSubtype& from);
  void MergeFrom(const OsmAndPoiSubtype& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string tagname = 2;
  inline bool has_tagname() const;
  inline void clear_tagname();
  static const int kTagnameFieldNumber = 2;
  inline const ::std::string& tagname() const;
  inline void set_tagname(const ::std::string& value);
  inline void set_tagname(const char* value);
  inline void set_tagname(const char* value, size_t size);
  inline ::std::string* mutable_tagname();
  inline ::std::string* release_tagname();
  inline void set_allocated_tagname(::std::string* tagname);

  // required bool isText = 3;
  inline bool has_istext() const;
  inline void clear_istext();
  static const int kIsTextFieldNumber = 3;
  inline bool istext() const;
  inline void set_istext(bool value);

  // optional uint32 frequency = 5;
  inline bool has_frequency() const;
  inline void clear_frequency();
  static const int kFrequencyFieldNumber = 5;
  inline ::google::protobuf::uint32 frequency() const;
  inline void set_frequency(::google::protobuf::uint32 value);

  // optional uint32 subtypeValuesSize = 6;
  inline bool has_subtypevaluessize() const;
  inline void clear_subtypevaluessize();
  static const int kSubtypeValuesSizeFieldNumber = 6;
  inline ::google::protobuf::uint32 subtypevaluessize() const;
  inline void set_subtypevaluessize(::google::protobuf::uint32 value);

  // repeated string subtypeValue = 8;
  inline int subtypevalue_size() const;
  inline void clear_subtypevalue();
  static const int kSubtypeValueFieldNumber = 8;
  inline const ::std::string& subtypevalue(int index) const;
  inline ::std::string* mutable_subtypevalue(int index);
  inline void set_subtypevalue(int index, const ::std::string& value);
  inline void set_subtypevalue(int index, const char* value);
  inline void set_subtypevalue(int index, const char* value, size_t size);
  inline ::std::string* add_subtypevalue();
  inline void add_subtypevalue(const ::std::string& value);
  inline void add_subtypevalue(const char* value);
  inline void add_subtypevalue(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& subtypevalue() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_subtypevalue();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndPoiSubtype)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_tagname();
  inline void clear_has_tagname();
  inline void set_has_istext();
  inline void clear_has_istext();
  inline void set_has_frequency();
  inline void clear_has_frequency();
  inline void set_has_subtypevaluessize();
  inline void clear_has_subtypevaluessize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* tagname_;
  bool istext_;
  ::google::protobuf::uint32 frequency_;
  ::google::protobuf::RepeatedPtrField< ::std::string> subtypevalue_;
  ::google::protobuf::uint32 subtypevaluessize_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndPoiSubtype* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndPoiTagGroup : public ::google::protobuf::Message {
 public:
  OsmAndPoiTagGroup();
  virtual ~OsmAndPoiTagGroup();

  OsmAndPoiTagGroup(const OsmAndPoiTagGroup& from);

  inline OsmAndPoiTagGroup& operator=(const OsmAndPoiTagGroup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndPoiTagGroup& default_instance();

  void Swap(OsmAndPoiTagGroup* other);

  // implements Message ----------------------------------------------

  OsmAndPoiTagGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndPoiTagGroup& from);
  void MergeFrom(const OsmAndPoiTagGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // repeated string tagValues = 5;
  inline int tagvalues_size() const;
  inline void clear_tagvalues();
  static const int kTagValuesFieldNumber = 5;
  inline const ::std::string& tagvalues(int index) const;
  inline ::std::string* mutable_tagvalues(int index);
  inline void set_tagvalues(int index, const ::std::string& value);
  inline void set_tagvalues(int index, const char* value);
  inline void set_tagvalues(int index, const char* value, size_t size);
  inline ::std::string* add_tagvalues();
  inline void add_tagvalues(const ::std::string& value);
  inline void add_tagvalues(const char* value);
  inline void add_tagvalues(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tagvalues() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tagvalues();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndPoiTagGroup)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> tagvalues_;
  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndPoiTagGroup* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndPoiTagGroups : public ::google::protobuf::Message {
 public:
  OsmAndPoiTagGroups();
  virtual ~OsmAndPoiTagGroups();

  OsmAndPoiTagGroups(const OsmAndPoiTagGroups& from);

  inline OsmAndPoiTagGroups& operator=(const OsmAndPoiTagGroups& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndPoiTagGroups& default_instance();

  void Swap(OsmAndPoiTagGroups* other);

  // implements Message ----------------------------------------------

  OsmAndPoiTagGroups* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndPoiTagGroups& from);
  void MergeFrom(const OsmAndPoiTagGroups& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 ids = 2 [packed = true];
  inline int ids_size() const;
  inline void clear_ids();
  static const int kIdsFieldNumber = 2;
  inline ::google::protobuf::uint32 ids(int index) const;
  inline void set_ids(int index, ::google::protobuf::uint32 value);
  inline void add_ids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ids();

  // repeated .OsmAnd.OBF.OsmAndPoiTagGroup groups = 5;
  inline int groups_size() const;
  inline void clear_groups();
  static const int kGroupsFieldNumber = 5;
  inline const ::OsmAnd::OBF::OsmAndPoiTagGroup& groups(int index) const;
  inline ::OsmAnd::OBF::OsmAndPoiTagGroup* mutable_groups(int index);
  inline ::OsmAnd::OBF::OsmAndPoiTagGroup* add_groups();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiTagGroup >&
      groups() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiTagGroup >*
      mutable_groups();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndPoiTagGroups)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ids_;
  mutable int _ids_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiTagGroup > groups_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndPoiTagGroups* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndPoiBox : public ::google::protobuf::Message {
 public:
  OsmAndPoiBox();
  virtual ~OsmAndPoiBox();

  OsmAndPoiBox(const OsmAndPoiBox& from);

  inline OsmAndPoiBox& operator=(const OsmAndPoiBox& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndPoiBox& default_instance();

  void Swap(OsmAndPoiBox* other);

  // implements Message ----------------------------------------------

  OsmAndPoiBox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndPoiBox& from);
  void MergeFrom(const OsmAndPoiBox& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 zoom = 1;
  inline bool has_zoom() const;
  inline void clear_zoom();
  static const int kZoomFieldNumber = 1;
  inline ::google::protobuf::uint32 zoom() const;
  inline void set_zoom(::google::protobuf::uint32 value);

  // required sint32 left = 2;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 2;
  inline ::google::protobuf::int32 left() const;
  inline void set_left(::google::protobuf::int32 value);

  // required sint32 top = 3;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 3;
  inline ::google::protobuf::int32 top() const;
  inline void set_top(::google::protobuf::int32 value);

  // optional .OsmAnd.OBF.OsmAndPoiCategories categories = 4;
  inline bool has_categories() const;
  inline void clear_categories();
  static const int kCategoriesFieldNumber = 4;
  inline const ::OsmAnd::OBF::OsmAndPoiCategories& categories() const;
  inline ::OsmAnd::OBF::OsmAndPoiCategories* mutable_categories();
  inline ::OsmAnd::OBF::OsmAndPoiCategories* release_categories();
  inline void set_allocated_categories(::OsmAnd::OBF::OsmAndPoiCategories* categories);

  // optional .OsmAnd.OBF.OsmAndPoiTagGroups tagGroups = 8;
  inline bool has_taggroups() const;
  inline void clear_taggroups();
  static const int kTagGroupsFieldNumber = 8;
  inline const ::OsmAnd::OBF::OsmAndPoiTagGroups& taggroups() const;
  inline ::OsmAnd::OBF::OsmAndPoiTagGroups* mutable_taggroups();
  inline ::OsmAnd::OBF::OsmAndPoiTagGroups* release_taggroups();
  inline void set_allocated_taggroups(::OsmAnd::OBF::OsmAndPoiTagGroups* taggroups);

  // repeated .OsmAnd.OBF.OsmAndPoiBox subBoxes = 10;
  inline int subboxes_size() const;
  inline void clear_subboxes();
  static const int kSubBoxesFieldNumber = 10;
  inline const ::OsmAnd::OBF::OsmAndPoiBox& subboxes(int index) const;
  inline ::OsmAnd::OBF::OsmAndPoiBox* mutable_subboxes(int index);
  inline ::OsmAnd::OBF::OsmAndPoiBox* add_subboxes();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiBox >&
      subboxes() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiBox >*
      mutable_subboxes();

  // optional fixed32 shiftToData = 14;
  inline bool has_shifttodata() const;
  inline void clear_shifttodata();
  static const int kShiftToDataFieldNumber = 14;
  inline ::google::protobuf::uint32 shifttodata() const;
  inline void set_shifttodata(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndPoiBox)
 private:
  inline void set_has_zoom();
  inline void clear_has_zoom();
  inline void set_has_left();
  inline void clear_has_left();
  inline void set_has_top();
  inline void clear_has_top();
  inline void set_has_categories();
  inline void clear_has_categories();
  inline void set_has_taggroups();
  inline void clear_has_taggroups();
  inline void set_has_shifttodata();
  inline void clear_has_shifttodata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 zoom_;
  ::google::protobuf::int32 left_;
  ::OsmAnd::OBF::OsmAndPoiCategories* categories_;
  ::OsmAnd::OBF::OsmAndPoiTagGroups* taggroups_;
  ::google::protobuf::int32 top_;
  ::google::protobuf::uint32 shifttodata_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiBox > subboxes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndPoiBox* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndPoiCategories : public ::google::protobuf::Message {
 public:
  OsmAndPoiCategories();
  virtual ~OsmAndPoiCategories();

  OsmAndPoiCategories(const OsmAndPoiCategories& from);

  inline OsmAndPoiCategories& operator=(const OsmAndPoiCategories& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndPoiCategories& default_instance();

  void Swap(OsmAndPoiCategories* other);

  // implements Message ----------------------------------------------

  OsmAndPoiCategories* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndPoiCategories& from);
  void MergeFrom(const OsmAndPoiCategories& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 categories = 3;
  inline int categories_size() const;
  inline void clear_categories();
  static const int kCategoriesFieldNumber = 3;
  inline ::google::protobuf::uint32 categories(int index) const;
  inline void set_categories(int index, ::google::protobuf::uint32 value);
  inline void add_categories(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      categories() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_categories();

  // repeated uint32 subcategories = 5;
  inline int subcategories_size() const;
  inline void clear_subcategories();
  static const int kSubcategoriesFieldNumber = 5;
  inline ::google::protobuf::uint32 subcategories(int index) const;
  inline void set_subcategories(int index, ::google::protobuf::uint32 value);
  inline void add_subcategories(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      subcategories() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_subcategories();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndPoiCategories)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > categories_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > subcategories_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndPoiCategories* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndPoiBoxData : public ::google::protobuf::Message {
 public:
  OsmAndPoiBoxData();
  virtual ~OsmAndPoiBoxData();

  OsmAndPoiBoxData(const OsmAndPoiBoxData& from);

  inline OsmAndPoiBoxData& operator=(const OsmAndPoiBoxData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndPoiBoxData& default_instance();

  void Swap(OsmAndPoiBoxData* other);

  // implements Message ----------------------------------------------

  OsmAndPoiBoxData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndPoiBoxData& from);
  void MergeFrom(const OsmAndPoiBoxData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 zoom = 1;
  inline bool has_zoom() const;
  inline void clear_zoom();
  static const int kZoomFieldNumber = 1;
  inline ::google::protobuf::uint32 zoom() const;
  inline void set_zoom(::google::protobuf::uint32 value);

  // optional uint32 x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline ::google::protobuf::uint32 x() const;
  inline void set_x(::google::protobuf::uint32 value);

  // optional uint32 y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline ::google::protobuf::uint32 y() const;
  inline void set_y(::google::protobuf::uint32 value);

  // repeated .OsmAnd.OBF.OsmAndPoiBoxDataAtom poiData = 5;
  inline int poidata_size() const;
  inline void clear_poidata();
  static const int kPoiDataFieldNumber = 5;
  inline const ::OsmAnd::OBF::OsmAndPoiBoxDataAtom& poidata(int index) const;
  inline ::OsmAnd::OBF::OsmAndPoiBoxDataAtom* mutable_poidata(int index);
  inline ::OsmAnd::OBF::OsmAndPoiBoxDataAtom* add_poidata();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiBoxDataAtom >&
      poidata() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiBoxDataAtom >*
      mutable_poidata();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndPoiBoxData)
 private:
  inline void set_has_zoom();
  inline void clear_has_zoom();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 zoom_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiBoxDataAtom > poidata_;
  ::google::protobuf::uint32 y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndPoiBoxData* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndPoiBoxDataAtom : public ::google::protobuf::Message {
 public:
  OsmAndPoiBoxDataAtom();
  virtual ~OsmAndPoiBoxDataAtom();

  OsmAndPoiBoxDataAtom(const OsmAndPoiBoxDataAtom& from);

  inline OsmAndPoiBoxDataAtom& operator=(const OsmAndPoiBoxDataAtom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndPoiBoxDataAtom& default_instance();

  void Swap(OsmAndPoiBoxDataAtom* other);

  // implements Message ----------------------------------------------

  OsmAndPoiBoxDataAtom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndPoiBoxDataAtom& from);
  void MergeFrom(const OsmAndPoiBoxDataAtom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required sint32 dx = 2;
  inline bool has_dx() const;
  inline void clear_dx();
  static const int kDxFieldNumber = 2;
  inline ::google::protobuf::int32 dx() const;
  inline void set_dx(::google::protobuf::int32 value);

  // required sint32 dy = 3;
  inline bool has_dy() const;
  inline void clear_dy();
  static const int kDyFieldNumber = 3;
  inline ::google::protobuf::int32 dy() const;
  inline void set_dy(::google::protobuf::int32 value);

  // repeated uint32 categories = 4;
  inline int categories_size() const;
  inline void clear_categories();
  static const int kCategoriesFieldNumber = 4;
  inline ::google::protobuf::uint32 categories(int index) const;
  inline void set_categories(int index, ::google::protobuf::uint32 value);
  inline void add_categories(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      categories() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_categories();

  // repeated uint32 subcategories = 5;
  inline int subcategories_size() const;
  inline void clear_subcategories();
  static const int kSubcategoriesFieldNumber = 5;
  inline ::google::protobuf::uint32 subcategories(int index) const;
  inline void set_subcategories(int index, ::google::protobuf::uint32 value);
  inline void add_subcategories(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      subcategories() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_subcategories();

  // optional string name = 6;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 6;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string nameEn = 7;
  inline bool has_nameen() const;
  inline void clear_nameen();
  static const int kNameEnFieldNumber = 7;
  inline const ::std::string& nameen() const;
  inline void set_nameen(const ::std::string& value);
  inline void set_nameen(const char* value);
  inline void set_nameen(const char* value, size_t size);
  inline ::std::string* mutable_nameen();
  inline ::std::string* release_nameen();
  inline void set_allocated_nameen(::std::string* nameen);

  // optional uint64 id = 8;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 8;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional string openingHours = 10;
  inline bool has_openinghours() const;
  inline void clear_openinghours();
  static const int kOpeningHoursFieldNumber = 10;
  inline const ::std::string& openinghours() const;
  inline void set_openinghours(const ::std::string& value);
  inline void set_openinghours(const char* value);
  inline void set_openinghours(const char* value, size_t size);
  inline ::std::string* mutable_openinghours();
  inline ::std::string* release_openinghours();
  inline void set_allocated_openinghours(::std::string* openinghours);

  // optional string site = 11;
  inline bool has_site() const;
  inline void clear_site();
  static const int kSiteFieldNumber = 11;
  inline const ::std::string& site() const;
  inline void set_site(const ::std::string& value);
  inline void set_site(const char* value);
  inline void set_site(const char* value, size_t size);
  inline ::std::string* mutable_site();
  inline ::std::string* release_site();
  inline void set_allocated_site(::std::string* site);

  // optional string phone = 12;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 12;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  inline void set_allocated_phone(::std::string* phone);

  // optional string note = 13;
  inline bool has_note() const;
  inline void clear_note();
  static const int kNoteFieldNumber = 13;
  inline const ::std::string& note() const;
  inline void set_note(const ::std::string& value);
  inline void set_note(const char* value);
  inline void set_note(const char* value, size_t size);
  inline ::std::string* mutable_note();
  inline ::std::string* release_note();
  inline void set_allocated_note(::std::string* note);

  // repeated uint32 textCategories = 14;
  inline int textcategories_size() const;
  inline void clear_textcategories();
  static const int kTextCategoriesFieldNumber = 14;
  inline ::google::protobuf::uint32 textcategories(int index) const;
  inline void set_textcategories(int index, ::google::protobuf::uint32 value);
  inline void add_textcategories(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      textcategories() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_textcategories();

  // repeated string textValues = 15;
  inline int textvalues_size() const;
  inline void clear_textvalues();
  static const int kTextValuesFieldNumber = 15;
  inline const ::std::string& textvalues(int index) const;
  inline ::std::string* mutable_textvalues(int index);
  inline void set_textvalues(int index, const ::std::string& value);
  inline void set_textvalues(int index, const char* value);
  inline void set_textvalues(int index, const char* value, size_t size);
  inline ::std::string* add_textvalues();
  inline void add_textvalues(const ::std::string& value);
  inline void add_textvalues(const char* value);
  inline void add_textvalues(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& textvalues() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_textvalues();

  // optional int32 precisionXY = 16;
  inline bool has_precisionxy() const;
  inline void clear_precisionxy();
  static const int kPrecisionXYFieldNumber = 16;
  inline ::google::protobuf::int32 precisionxy() const;
  inline void set_precisionxy(::google::protobuf::int32 value);

  // repeated uint32 tagGroups = 17 [packed = true];
  inline int taggroups_size() const;
  inline void clear_taggroups();
  static const int kTagGroupsFieldNumber = 17;
  inline ::google::protobuf::uint32 taggroups(int index) const;
  inline void set_taggroups(int index, ::google::protobuf::uint32 value);
  inline void add_taggroups(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      taggroups() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_taggroups();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndPoiBoxDataAtom)
 private:
  inline void set_has_dx();
  inline void clear_has_dx();
  inline void set_has_dy();
  inline void clear_has_dy();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_nameen();
  inline void clear_has_nameen();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_openinghours();
  inline void clear_has_openinghours();
  inline void set_has_site();
  inline void clear_has_site();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_note();
  inline void clear_has_note();
  inline void set_has_precisionxy();
  inline void clear_has_precisionxy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 dx_;
  ::google::protobuf::int32 dy_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > categories_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > subcategories_;
  ::std::string* name_;
  ::std::string* nameen_;
  ::google::protobuf::uint64 id_;
  ::std::string* openinghours_;
  ::std::string* site_;
  ::std::string* phone_;
  ::std::string* note_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > textcategories_;
  ::google::protobuf::RepeatedPtrField< ::std::string> textvalues_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > taggroups_;
  mutable int _taggroups_cached_byte_size_;
  ::google::protobuf::int32 precisionxy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndPoiBoxDataAtom* default_instance_;
};
// -------------------------------------------------------------------

class IdTable : public ::google::protobuf::Message {
 public:
  IdTable();
  virtual ~IdTable();

  IdTable(const IdTable& from);

  inline IdTable& operator=(const IdTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IdTable& default_instance();

  void Swap(IdTable* other);

  // implements Message ----------------------------------------------

  IdTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IdTable& from);
  void MergeFrom(const IdTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated sint64 routeId = 1;
  inline int routeid_size() const;
  inline void clear_routeid();
  static const int kRouteIdFieldNumber = 1;
  inline ::google::protobuf::int64 routeid(int index) const;
  inline void set_routeid(int index, ::google::protobuf::int64 value);
  inline void add_routeid(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      routeid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_routeid();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.IdTable)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > routeid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static IdTable* default_instance_;
};
// -------------------------------------------------------------------

class RestrictionData : public ::google::protobuf::Message {
 public:
  RestrictionData();
  virtual ~RestrictionData();

  RestrictionData(const RestrictionData& from);

  inline RestrictionData& operator=(const RestrictionData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RestrictionData& default_instance();

  void Swap(RestrictionData* other);

  // implements Message ----------------------------------------------

  RestrictionData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RestrictionData& from);
  void MergeFrom(const RestrictionData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required int32 from = 2;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 2;
  inline ::google::protobuf::int32 from() const;
  inline void set_from(::google::protobuf::int32 value);

  // required int32 to = 3;
  inline bool has_to() const;
  inline void clear_to();
  static const int kToFieldNumber = 3;
  inline ::google::protobuf::int32 to() const;
  inline void set_to(::google::protobuf::int32 value);

  // optional int32 via = 4;
  inline bool has_via() const;
  inline void clear_via();
  static const int kViaFieldNumber = 4;
  inline ::google::protobuf::int32 via() const;
  inline void set_via(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.RestrictionData)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_to();
  inline void clear_has_to();
  inline void set_has_via();
  inline void clear_has_via();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 from_;
  ::google::protobuf::int32 to_;
  ::google::protobuf::int32 via_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static RestrictionData* default_instance_;
};
// -------------------------------------------------------------------

class RouteData : public ::google::protobuf::Message {
 public:
  RouteData();
  virtual ~RouteData();

  RouteData(const RouteData& from);

  inline RouteData& operator=(const RouteData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RouteData& default_instance();

  void Swap(RouteData* other);

  // implements Message ----------------------------------------------

  RouteData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RouteData& from);
  void MergeFrom(const RouteData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes points = 1;
  inline bool has_points() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 1;
  inline const ::std::string& points() const;
  inline void set_points(const ::std::string& value);
  inline void set_points(const char* value);
  inline void set_points(const void* value, size_t size);
  inline ::std::string* mutable_points();
  inline ::std::string* release_points();
  inline void set_allocated_points(::std::string* points);

  // optional bytes pointTypes = 4;
  inline bool has_pointtypes() const;
  inline void clear_pointtypes();
  static const int kPointTypesFieldNumber = 4;
  inline const ::std::string& pointtypes() const;
  inline void set_pointtypes(const ::std::string& value);
  inline void set_pointtypes(const char* value);
  inline void set_pointtypes(const void* value, size_t size);
  inline ::std::string* mutable_pointtypes();
  inline ::std::string* release_pointtypes();
  inline void set_allocated_pointtypes(::std::string* pointtypes);

  // optional bytes pointNames = 5;
  inline bool has_pointnames() const;
  inline void clear_pointnames();
  static const int kPointNamesFieldNumber = 5;
  inline const ::std::string& pointnames() const;
  inline void set_pointnames(const ::std::string& value);
  inline void set_pointnames(const char* value);
  inline void set_pointnames(const void* value, size_t size);
  inline ::std::string* mutable_pointnames();
  inline ::std::string* release_pointnames();
  inline void set_allocated_pointnames(::std::string* pointnames);

  // required bytes types = 7;
  inline bool has_types() const;
  inline void clear_types();
  static const int kTypesFieldNumber = 7;
  inline const ::std::string& types() const;
  inline void set_types(const ::std::string& value);
  inline void set_types(const char* value);
  inline void set_types(const void* value, size_t size);
  inline ::std::string* mutable_types();
  inline ::std::string* release_types();
  inline void set_allocated_types(::std::string* types);

  // required int32 routeId = 12;
  inline bool has_routeid() const;
  inline void clear_routeid();
  static const int kRouteIdFieldNumber = 12;
  inline ::google::protobuf::int32 routeid() const;
  inline void set_routeid(::google::protobuf::int32 value);

  // optional bytes stringNames = 14;
  inline bool has_stringnames() const;
  inline void clear_stringnames();
  static const int kStringNamesFieldNumber = 14;
  inline const ::std::string& stringnames() const;
  inline void set_stringnames(const ::std::string& value);
  inline void set_stringnames(const char* value);
  inline void set_stringnames(const void* value, size_t size);
  inline ::std::string* mutable_stringnames();
  inline ::std::string* release_stringnames();
  inline void set_allocated_stringnames(::std::string* stringnames);

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.RouteData)
 private:
  inline void set_has_points();
  inline void clear_has_points();
  inline void set_has_pointtypes();
  inline void clear_has_pointtypes();
  inline void set_has_pointnames();
  inline void clear_has_pointnames();
  inline void set_has_types();
  inline void clear_has_types();
  inline void set_has_routeid();
  inline void clear_has_routeid();
  inline void set_has_stringnames();
  inline void clear_has_stringnames();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* points_;
  ::std::string* pointtypes_;
  ::std::string* pointnames_;
  ::std::string* types_;
  ::std::string* stringnames_;
  ::google::protobuf::int32 routeid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static RouteData* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndRoutingIndex_RouteEncodingRule : public ::google::protobuf::Message {
 public:
  OsmAndRoutingIndex_RouteEncodingRule();
  virtual ~OsmAndRoutingIndex_RouteEncodingRule();

  OsmAndRoutingIndex_RouteEncodingRule(const OsmAndRoutingIndex_RouteEncodingRule& from);

  inline OsmAndRoutingIndex_RouteEncodingRule& operator=(const OsmAndRoutingIndex_RouteEncodingRule& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndRoutingIndex_RouteEncodingRule& default_instance();

  void Swap(OsmAndRoutingIndex_RouteEncodingRule* other);

  // implements Message ----------------------------------------------

  OsmAndRoutingIndex_RouteEncodingRule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndRoutingIndex_RouteEncodingRule& from);
  void MergeFrom(const OsmAndRoutingIndex_RouteEncodingRule& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string tag = 3;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 3;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const char* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  inline void set_allocated_tag(::std::string* tag);

  // required string value = 5;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 5;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional uint32 id = 7;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 7;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndRoutingIndex.RouteEncodingRule)
 private:
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* tag_;
  ::std::string* value_;
  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndRoutingIndex_RouteEncodingRule* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndRoutingIndex_RouteDataBox : public ::google::protobuf::Message {
 public:
  OsmAndRoutingIndex_RouteDataBox();
  virtual ~OsmAndRoutingIndex_RouteDataBox();

  OsmAndRoutingIndex_RouteDataBox(const OsmAndRoutingIndex_RouteDataBox& from);

  inline OsmAndRoutingIndex_RouteDataBox& operator=(const OsmAndRoutingIndex_RouteDataBox& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndRoutingIndex_RouteDataBox& default_instance();

  void Swap(OsmAndRoutingIndex_RouteDataBox* other);

  // implements Message ----------------------------------------------

  OsmAndRoutingIndex_RouteDataBox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndRoutingIndex_RouteDataBox& from);
  void MergeFrom(const OsmAndRoutingIndex_RouteDataBox& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required sint32 left = 1;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 1;
  inline ::google::protobuf::int32 left() const;
  inline void set_left(::google::protobuf::int32 value);

  // required sint32 right = 2;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 2;
  inline ::google::protobuf::int32 right() const;
  inline void set_right(::google::protobuf::int32 value);

  // required sint32 top = 3;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 3;
  inline ::google::protobuf::int32 top() const;
  inline void set_top(::google::protobuf::int32 value);

  // required sint32 bottom = 4;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 4;
  inline ::google::protobuf::int32 bottom() const;
  inline void set_bottom(::google::protobuf::int32 value);

  // optional fixed32 shiftToData = 5;
  inline bool has_shifttodata() const;
  inline void clear_shifttodata();
  static const int kShiftToDataFieldNumber = 5;
  inline ::google::protobuf::uint32 shifttodata() const;
  inline void set_shifttodata(::google::protobuf::uint32 value);

  // repeated .OsmAnd.OBF.OsmAndRoutingIndex.RouteDataBox boxes = 7;
  inline int boxes_size() const;
  inline void clear_boxes();
  static const int kBoxesFieldNumber = 7;
  inline const ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox& boxes(int index) const;
  inline ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox* mutable_boxes(int index);
  inline ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox* add_boxes();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox >&
      boxes() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox >*
      mutable_boxes();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndRoutingIndex.RouteDataBox)
 private:
  inline void set_has_left();
  inline void clear_has_left();
  inline void set_has_right();
  inline void clear_has_right();
  inline void set_has_top();
  inline void clear_has_top();
  inline void set_has_bottom();
  inline void clear_has_bottom();
  inline void set_has_shifttodata();
  inline void clear_has_shifttodata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 right_;
  ::google::protobuf::int32 top_;
  ::google::protobuf::int32 bottom_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox > boxes_;
  ::google::protobuf::uint32 shifttodata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndRoutingIndex_RouteDataBox* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndRoutingIndex_RouteDataBlock : public ::google::protobuf::Message {
 public:
  OsmAndRoutingIndex_RouteDataBlock();
  virtual ~OsmAndRoutingIndex_RouteDataBlock();

  OsmAndRoutingIndex_RouteDataBlock(const OsmAndRoutingIndex_RouteDataBlock& from);

  inline OsmAndRoutingIndex_RouteDataBlock& operator=(const OsmAndRoutingIndex_RouteDataBlock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndRoutingIndex_RouteDataBlock& default_instance();

  void Swap(OsmAndRoutingIndex_RouteDataBlock* other);

  // implements Message ----------------------------------------------

  OsmAndRoutingIndex_RouteDataBlock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndRoutingIndex_RouteDataBlock& from);
  void MergeFrom(const OsmAndRoutingIndex_RouteDataBlock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .OsmAnd.OBF.IdTable idTable = 5;
  inline bool has_idtable() const;
  inline void clear_idtable();
  static const int kIdTableFieldNumber = 5;
  inline const ::OsmAnd::OBF::IdTable& idtable() const;
  inline ::OsmAnd::OBF::IdTable* mutable_idtable();
  inline ::OsmAnd::OBF::IdTable* release_idtable();
  inline void set_allocated_idtable(::OsmAnd::OBF::IdTable* idtable);

  // repeated .OsmAnd.OBF.RouteData dataObjects = 6;
  inline int dataobjects_size() const;
  inline void clear_dataobjects();
  static const int kDataObjectsFieldNumber = 6;
  inline const ::OsmAnd::OBF::RouteData& dataobjects(int index) const;
  inline ::OsmAnd::OBF::RouteData* mutable_dataobjects(int index);
  inline ::OsmAnd::OBF::RouteData* add_dataobjects();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::RouteData >&
      dataobjects() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::RouteData >*
      mutable_dataobjects();

  // repeated .OsmAnd.OBF.RestrictionData restrictions = 7;
  inline int restrictions_size() const;
  inline void clear_restrictions();
  static const int kRestrictionsFieldNumber = 7;
  inline const ::OsmAnd::OBF::RestrictionData& restrictions(int index) const;
  inline ::OsmAnd::OBF::RestrictionData* mutable_restrictions(int index);
  inline ::OsmAnd::OBF::RestrictionData* add_restrictions();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::RestrictionData >&
      restrictions() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::RestrictionData >*
      mutable_restrictions();

  // optional .OsmAnd.OBF.StringTable stringTable = 8;
  inline bool has_stringtable() const;
  inline void clear_stringtable();
  static const int kStringTableFieldNumber = 8;
  inline const ::OsmAnd::OBF::StringTable& stringtable() const;
  inline ::OsmAnd::OBF::StringTable* mutable_stringtable();
  inline ::OsmAnd::OBF::StringTable* release_stringtable();
  inline void set_allocated_stringtable(::OsmAnd::OBF::StringTable* stringtable);

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndRoutingIndex.RouteDataBlock)
 private:
  inline void set_has_idtable();
  inline void clear_has_idtable();
  inline void set_has_stringtable();
  inline void clear_has_stringtable();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::OsmAnd::OBF::IdTable* idtable_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::RouteData > dataobjects_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::RestrictionData > restrictions_;
  ::OsmAnd::OBF::StringTable* stringtable_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndRoutingIndex_RouteDataBlock* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndRoutingIndex : public ::google::protobuf::Message {
 public:
  OsmAndRoutingIndex();
  virtual ~OsmAndRoutingIndex();

  OsmAndRoutingIndex(const OsmAndRoutingIndex& from);

  inline OsmAndRoutingIndex& operator=(const OsmAndRoutingIndex& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndRoutingIndex& default_instance();

  void Swap(OsmAndRoutingIndex* other);

  // implements Message ----------------------------------------------

  OsmAndRoutingIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndRoutingIndex& from);
  void MergeFrom(const OsmAndRoutingIndex& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef OsmAndRoutingIndex_RouteEncodingRule RouteEncodingRule;
  typedef OsmAndRoutingIndex_RouteDataBox RouteDataBox;
  typedef OsmAndRoutingIndex_RouteDataBlock RouteDataBlock;

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .OsmAnd.OBF.OsmAndRoutingIndex.RouteEncodingRule rules = 2;
  inline int rules_size() const;
  inline void clear_rules();
  static const int kRulesFieldNumber = 2;
  inline const ::OsmAnd::OBF::OsmAndRoutingIndex_RouteEncodingRule& rules(int index) const;
  inline ::OsmAnd::OBF::OsmAndRoutingIndex_RouteEncodingRule* mutable_rules(int index);
  inline ::OsmAnd::OBF::OsmAndRoutingIndex_RouteEncodingRule* add_rules();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndRoutingIndex_RouteEncodingRule >&
      rules() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndRoutingIndex_RouteEncodingRule >*
      mutable_rules();

  // repeated .OsmAnd.OBF.OsmAndRoutingIndex.RouteDataBox rootBoxes = 3;
  inline int rootboxes_size() const;
  inline void clear_rootboxes();
  static const int kRootBoxesFieldNumber = 3;
  inline const ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox& rootboxes(int index) const;
  inline ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox* mutable_rootboxes(int index);
  inline ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox* add_rootboxes();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox >&
      rootboxes() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox >*
      mutable_rootboxes();

  // repeated .OsmAnd.OBF.OsmAndRoutingIndex.RouteDataBox basemapBoxes = 4;
  inline int basemapboxes_size() const;
  inline void clear_basemapboxes();
  static const int kBasemapBoxesFieldNumber = 4;
  inline const ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox& basemapboxes(int index) const;
  inline ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox* mutable_basemapboxes(int index);
  inline ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox* add_basemapboxes();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox >&
      basemapboxes() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox >*
      mutable_basemapboxes();

  // repeated .OsmAnd.OBF.OsmAndRoutingIndex.RouteDataBlock blocks = 5;
  inline int blocks_size() const;
  inline void clear_blocks();
  static const int kBlocksFieldNumber = 5;
  inline const ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBlock& blocks(int index) const;
  inline ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBlock* mutable_blocks(int index);
  inline ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBlock* add_blocks();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBlock >&
      blocks() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBlock >*
      mutable_blocks();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndRoutingIndex)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndRoutingIndex_RouteEncodingRule > rules_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox > rootboxes_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox > basemapboxes_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBlock > blocks_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndRoutingIndex* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndHHRoutingIndex_HHRoutePointsBox : public ::google::protobuf::Message {
 public:
  OsmAndHHRoutingIndex_HHRoutePointsBox();
  virtual ~OsmAndHHRoutingIndex_HHRoutePointsBox();

  OsmAndHHRoutingIndex_HHRoutePointsBox(const OsmAndHHRoutingIndex_HHRoutePointsBox& from);

  inline OsmAndHHRoutingIndex_HHRoutePointsBox& operator=(const OsmAndHHRoutingIndex_HHRoutePointsBox& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndHHRoutingIndex_HHRoutePointsBox& default_instance();

  void Swap(OsmAndHHRoutingIndex_HHRoutePointsBox* other);

  // implements Message ----------------------------------------------

  OsmAndHHRoutingIndex_HHRoutePointsBox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndHHRoutingIndex_HHRoutePointsBox& from);
  void MergeFrom(const OsmAndHHRoutingIndex_HHRoutePointsBox& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required sint32 left = 2;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 2;
  inline ::google::protobuf::int32 left() const;
  inline void set_left(::google::protobuf::int32 value);

  // required sint32 right = 3;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 3;
  inline ::google::protobuf::int32 right() const;
  inline void set_right(::google::protobuf::int32 value);

  // required sint32 top = 4;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 4;
  inline ::google::protobuf::int32 top() const;
  inline void set_top(::google::protobuf::int32 value);

  // required sint32 bottom = 5;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 5;
  inline ::google::protobuf::int32 bottom() const;
  inline void set_bottom(::google::protobuf::int32 value);

  // repeated .OsmAnd.OBF.OsmAndHHRoutingIndex.HHRoutePointsBox boxes = 6;
  inline int boxes_size() const;
  inline void clear_boxes();
  static const int kBoxesFieldNumber = 6;
  inline const ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointsBox& boxes(int index) const;
  inline ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointsBox* mutable_boxes(int index);
  inline ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointsBox* add_boxes();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointsBox >&
      boxes() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointsBox >*
      mutable_boxes();

  // repeated .OsmAnd.OBF.OsmAndHHRoutingIndex.HHRouteNetworkPoint points = 7;
  inline int points_size() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 7;
  inline const ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteNetworkPoint& points(int index) const;
  inline ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteNetworkPoint* mutable_points(int index);
  inline ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteNetworkPoint* add_points();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteNetworkPoint >&
      points() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteNetworkPoint >*
      mutable_points();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndHHRoutingIndex.HHRoutePointsBox)
 private:
  inline void set_has_left();
  inline void clear_has_left();
  inline void set_has_right();
  inline void clear_has_right();
  inline void set_has_top();
  inline void clear_has_top();
  inline void set_has_bottom();
  inline void clear_has_bottom();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 right_;
  ::google::protobuf::int32 top_;
  ::google::protobuf::int32 bottom_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointsBox > boxes_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteNetworkPoint > points_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndHHRoutingIndex_HHRoutePointsBox* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndHHRoutingIndex_HHRouteNetworkPoint : public ::google::protobuf::Message {
 public:
  OsmAndHHRoutingIndex_HHRouteNetworkPoint();
  virtual ~OsmAndHHRoutingIndex_HHRouteNetworkPoint();

  OsmAndHHRoutingIndex_HHRouteNetworkPoint(const OsmAndHHRoutingIndex_HHRouteNetworkPoint& from);

  inline OsmAndHHRoutingIndex_HHRouteNetworkPoint& operator=(const OsmAndHHRoutingIndex_HHRouteNetworkPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndHHRoutingIndex_HHRouteNetworkPoint& default_instance();

  void Swap(OsmAndHHRoutingIndex_HHRouteNetworkPoint* other);

  // implements Message ----------------------------------------------

  OsmAndHHRoutingIndex_HHRouteNetworkPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndHHRoutingIndex_HHRouteNetworkPoint& from);
  void MergeFrom(const OsmAndHHRoutingIndex_HHRouteNetworkPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required sint32 dx = 2;
  inline bool has_dx() const;
  inline void clear_dx();
  static const int kDxFieldNumber = 2;
  inline ::google::protobuf::int32 dx() const;
  inline void set_dx(::google::protobuf::int32 value);

  // required sint32 dy = 3;
  inline bool has_dy() const;
  inline void clear_dy();
  static const int kDyFieldNumber = 3;
  inline ::google::protobuf::int32 dy() const;
  inline void set_dy(::google::protobuf::int32 value);

  // required int32 globalId = 4;
  inline bool has_globalid() const;
  inline void clear_globalid();
  static const int kGlobalIdFieldNumber = 4;
  inline ::google::protobuf::int32 globalid() const;
  inline void set_globalid(::google::protobuf::int32 value);

  // required int64 roadId = 5;
  inline bool has_roadid() const;
  inline void clear_roadid();
  static const int kRoadIdFieldNumber = 5;
  inline ::google::protobuf::int64 roadid() const;
  inline void set_roadid(::google::protobuf::int64 value);

  // required int32 roadStartEndIndex = 6;
  inline bool has_roadstartendindex() const;
  inline void clear_roadstartendindex();
  static const int kRoadStartEndIndexFieldNumber = 6;
  inline ::google::protobuf::int32 roadstartendindex() const;
  inline void set_roadstartendindex(::google::protobuf::int32 value);

  // optional int32 clusterId = 7;
  inline bool has_clusterid() const;
  inline void clear_clusterid();
  static const int kClusterIdFieldNumber = 7;
  inline ::google::protobuf::int32 clusterid() const;
  inline void set_clusterid(::google::protobuf::int32 value);

  // optional int32 dualPointId = 8;
  inline bool has_dualpointid() const;
  inline void clear_dualpointid();
  static const int kDualPointIdFieldNumber = 8;
  inline ::google::protobuf::int32 dualpointid() const;
  inline void set_dualpointid(::google::protobuf::int32 value);

  // optional int32 dualClusterId = 9;
  inline bool has_dualclusterid() const;
  inline void clear_dualclusterid();
  static const int kDualClusterIdFieldNumber = 9;
  inline ::google::protobuf::int32 dualclusterid() const;
  inline void set_dualclusterid(::google::protobuf::int32 value);

  // repeated int32 profileIds = 10;
  inline int profileids_size() const;
  inline void clear_profileids();
  static const int kProfileIdsFieldNumber = 10;
  inline ::google::protobuf::int32 profileids(int index) const;
  inline void set_profileids(int index, ::google::protobuf::int32 value);
  inline void add_profileids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      profileids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_profileids();

  // optional int32 partialInd = 11;
  inline bool has_partialind() const;
  inline void clear_partialind();
  static const int kPartialIndFieldNumber = 11;
  inline ::google::protobuf::int32 partialind() const;
  inline void set_partialind(::google::protobuf::int32 value);

  // repeated int32 tagValueIds = 12 [packed = true];
  inline int tagvalueids_size() const;
  inline void clear_tagvalueids();
  static const int kTagValueIdsFieldNumber = 12;
  inline ::google::protobuf::int32 tagvalueids(int index) const;
  inline void set_tagvalueids(int index, ::google::protobuf::int32 value);
  inline void add_tagvalueids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      tagvalueids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_tagvalueids();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndHHRoutingIndex.HHRouteNetworkPoint)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_dx();
  inline void clear_has_dx();
  inline void set_has_dy();
  inline void clear_has_dy();
  inline void set_has_globalid();
  inline void clear_has_globalid();
  inline void set_has_roadid();
  inline void clear_has_roadid();
  inline void set_has_roadstartendindex();
  inline void clear_has_roadstartendindex();
  inline void set_has_clusterid();
  inline void clear_has_clusterid();
  inline void set_has_dualpointid();
  inline void clear_has_dualpointid();
  inline void set_has_dualclusterid();
  inline void clear_has_dualclusterid();
  inline void set_has_partialind();
  inline void clear_has_partialind();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 dx_;
  ::google::protobuf::int32 dy_;
  ::google::protobuf::int32 globalid_;
  ::google::protobuf::int64 roadid_;
  ::google::protobuf::int32 roadstartendindex_;
  ::google::protobuf::int32 clusterid_;
  ::google::protobuf::int32 dualpointid_;
  ::google::protobuf::int32 dualclusterid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > profileids_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > tagvalueids_;
  mutable int _tagvalueids_cached_byte_size_;
  ::google::protobuf::int32 partialind_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndHHRoutingIndex_HHRouteNetworkPoint* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndHHRoutingIndex_HHRouteBlockSegments : public ::google::protobuf::Message {
 public:
  OsmAndHHRoutingIndex_HHRouteBlockSegments();
  virtual ~OsmAndHHRoutingIndex_HHRouteBlockSegments();

  OsmAndHHRoutingIndex_HHRouteBlockSegments(const OsmAndHHRoutingIndex_HHRouteBlockSegments& from);

  inline OsmAndHHRoutingIndex_HHRouteBlockSegments& operator=(const OsmAndHHRoutingIndex_HHRouteBlockSegments& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndHHRoutingIndex_HHRouteBlockSegments& default_instance();

  void Swap(OsmAndHHRoutingIndex_HHRouteBlockSegments* other);

  // implements Message ----------------------------------------------

  OsmAndHHRoutingIndex_HHRouteBlockSegments* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndHHRoutingIndex_HHRouteBlockSegments& from);
  void MergeFrom(const OsmAndHHRoutingIndex_HHRouteBlockSegments& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 idRangeStart = 1;
  inline bool has_idrangestart() const;
  inline void clear_idrangestart();
  static const int kIdRangeStartFieldNumber = 1;
  inline ::google::protobuf::int32 idrangestart() const;
  inline void set_idrangestart(::google::protobuf::int32 value);

  // required int32 idRangeLength = 2;
  inline bool has_idrangelength() const;
  inline void clear_idrangelength();
  static const int kIdRangeLengthFieldNumber = 2;
  inline ::google::protobuf::int32 idrangelength() const;
  inline void set_idrangelength(::google::protobuf::int32 value);

  // optional int32 profileId = 3;
  inline bool has_profileid() const;
  inline void clear_profileid();
  static const int kProfileIdFieldNumber = 3;
  inline ::google::protobuf::int32 profileid() const;
  inline void set_profileid(::google::protobuf::int32 value);

  // repeated .OsmAnd.OBF.OsmAndHHRoutingIndex.HHRouteBlockSegments innerBlocks = 6;
  inline int innerblocks_size() const;
  inline void clear_innerblocks();
  static const int kInnerBlocksFieldNumber = 6;
  inline const ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteBlockSegments& innerblocks(int index) const;
  inline ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteBlockSegments* mutable_innerblocks(int index);
  inline ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteBlockSegments* add_innerblocks();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteBlockSegments >&
      innerblocks() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteBlockSegments >*
      mutable_innerblocks();

  // repeated .OsmAnd.OBF.OsmAndHHRoutingIndex.HHRoutePointSegments pointSegments = 4;
  inline int pointsegments_size() const;
  inline void clear_pointsegments();
  static const int kPointSegmentsFieldNumber = 4;
  inline const ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointSegments& pointsegments(int index) const;
  inline ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointSegments* mutable_pointsegments(int index);
  inline ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointSegments* add_pointsegments();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointSegments >&
      pointsegments() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointSegments >*
      mutable_pointsegments();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndHHRoutingIndex.HHRouteBlockSegments)
 private:
  inline void set_has_idrangestart();
  inline void clear_has_idrangestart();
  inline void set_has_idrangelength();
  inline void clear_has_idrangelength();
  inline void set_has_profileid();
  inline void clear_has_profileid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 idrangestart_;
  ::google::protobuf::int32 idrangelength_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteBlockSegments > innerblocks_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointSegments > pointsegments_;
  ::google::protobuf::int32 profileid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndHHRoutingIndex_HHRouteBlockSegments* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndHHRoutingIndex_HHRoutePointSegments : public ::google::protobuf::Message {
 public:
  OsmAndHHRoutingIndex_HHRoutePointSegments();
  virtual ~OsmAndHHRoutingIndex_HHRoutePointSegments();

  OsmAndHHRoutingIndex_HHRoutePointSegments(const OsmAndHHRoutingIndex_HHRoutePointSegments& from);

  inline OsmAndHHRoutingIndex_HHRoutePointSegments& operator=(const OsmAndHHRoutingIndex_HHRoutePointSegments& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndHHRoutingIndex_HHRoutePointSegments& default_instance();

  void Swap(OsmAndHHRoutingIndex_HHRoutePointSegments* other);

  // implements Message ----------------------------------------------

  OsmAndHHRoutingIndex_HHRoutePointSegments* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndHHRoutingIndex_HHRoutePointSegments& from);
  void MergeFrom(const OsmAndHHRoutingIndex_HHRoutePointSegments& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes segmentsIn = 2;
  inline bool has_segmentsin() const;
  inline void clear_segmentsin();
  static const int kSegmentsInFieldNumber = 2;
  inline const ::std::string& segmentsin() const;
  inline void set_segmentsin(const ::std::string& value);
  inline void set_segmentsin(const char* value);
  inline void set_segmentsin(const void* value, size_t size);
  inline ::std::string* mutable_segmentsin();
  inline ::std::string* release_segmentsin();
  inline void set_allocated_segmentsin(::std::string* segmentsin);

  // required bytes segmentsOut = 3;
  inline bool has_segmentsout() const;
  inline void clear_segmentsout();
  static const int kSegmentsOutFieldNumber = 3;
  inline const ::std::string& segmentsout() const;
  inline void set_segmentsout(const ::std::string& value);
  inline void set_segmentsout(const char* value);
  inline void set_segmentsout(const void* value, size_t size);
  inline ::std::string* mutable_segmentsout();
  inline ::std::string* release_segmentsout();
  inline void set_allocated_segmentsout(::std::string* segmentsout);

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndHHRoutingIndex.HHRoutePointSegments)
 private:
  inline void set_has_segmentsin();
  inline void clear_has_segmentsin();
  inline void set_has_segmentsout();
  inline void clear_has_segmentsout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* segmentsin_;
  ::std::string* segmentsout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndHHRoutingIndex_HHRoutePointSegments* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndHHRoutingIndex : public ::google::protobuf::Message {
 public:
  OsmAndHHRoutingIndex();
  virtual ~OsmAndHHRoutingIndex();

  OsmAndHHRoutingIndex(const OsmAndHHRoutingIndex& from);

  inline OsmAndHHRoutingIndex& operator=(const OsmAndHHRoutingIndex& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndHHRoutingIndex& default_instance();

  void Swap(OsmAndHHRoutingIndex* other);

  // implements Message ----------------------------------------------

  OsmAndHHRoutingIndex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndHHRoutingIndex& from);
  void MergeFrom(const OsmAndHHRoutingIndex& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef OsmAndHHRoutingIndex_HHRoutePointsBox HHRoutePointsBox;
  typedef OsmAndHHRoutingIndex_HHRouteNetworkPoint HHRouteNetworkPoint;
  typedef OsmAndHHRoutingIndex_HHRouteBlockSegments HHRouteBlockSegments;
  typedef OsmAndHHRoutingIndex_HHRoutePointSegments HHRoutePointSegments;

  // accessors -------------------------------------------------------

  // required int64 edition = 1;
  inline bool has_edition() const;
  inline void clear_edition();
  static const int kEditionFieldNumber = 1;
  inline ::google::protobuf::int64 edition() const;
  inline void set_edition(::google::protobuf::int64 value);

  // required string profile = 2;
  inline bool has_profile() const;
  inline void clear_profile();
  static const int kProfileFieldNumber = 2;
  inline const ::std::string& profile() const;
  inline void set_profile(const ::std::string& value);
  inline void set_profile(const char* value);
  inline void set_profile(const char* value, size_t size);
  inline ::std::string* mutable_profile();
  inline ::std::string* release_profile();
  inline void set_allocated_profile(::std::string* profile);

  // repeated string profileParams = 3;
  inline int profileparams_size() const;
  inline void clear_profileparams();
  static const int kProfileParamsFieldNumber = 3;
  inline const ::std::string& profileparams(int index) const;
  inline ::std::string* mutable_profileparams(int index);
  inline void set_profileparams(int index, const ::std::string& value);
  inline void set_profileparams(int index, const char* value);
  inline void set_profileparams(int index, const char* value, size_t size);
  inline ::std::string* add_profileparams();
  inline void add_profileparams(const ::std::string& value);
  inline void add_profileparams(const char* value);
  inline void add_profileparams(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& profileparams() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_profileparams();

  // optional .OsmAnd.OBF.StringTable tagValuesTable = 4;
  inline bool has_tagvaluestable() const;
  inline void clear_tagvaluestable();
  static const int kTagValuesTableFieldNumber = 4;
  inline const ::OsmAnd::OBF::StringTable& tagvaluestable() const;
  inline ::OsmAnd::OBF::StringTable* mutable_tagvaluestable();
  inline ::OsmAnd::OBF::StringTable* release_tagvaluestable();
  inline void set_allocated_tagvaluestable(::OsmAnd::OBF::StringTable* tagvaluestable);

  // required .OsmAnd.OBF.OsmAndHHRoutingIndex.HHRoutePointsBox pointBoxes = 5;
  inline bool has_pointboxes() const;
  inline void clear_pointboxes();
  static const int kPointBoxesFieldNumber = 5;
  inline const ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointsBox& pointboxes() const;
  inline ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointsBox* mutable_pointboxes();
  inline ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointsBox* release_pointboxes();
  inline void set_allocated_pointboxes(::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointsBox* pointboxes);

  // repeated .OsmAnd.OBF.OsmAndHHRoutingIndex.HHRouteBlockSegments pointSegments = 6;
  inline int pointsegments_size() const;
  inline void clear_pointsegments();
  static const int kPointSegmentsFieldNumber = 6;
  inline const ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteBlockSegments& pointsegments(int index) const;
  inline ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteBlockSegments* mutable_pointsegments(int index);
  inline ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteBlockSegments* add_pointsegments();
  inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteBlockSegments >&
      pointsegments() const;
  inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteBlockSegments >*
      mutable_pointsegments();

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndHHRoutingIndex)
 private:
  inline void set_has_edition();
  inline void clear_has_edition();
  inline void set_has_profile();
  inline void clear_has_profile();
  inline void set_has_tagvaluestable();
  inline void clear_has_tagvaluestable();
  inline void set_has_pointboxes();
  inline void clear_has_pointboxes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 edition_;
  ::std::string* profile_;
  ::google::protobuf::RepeatedPtrField< ::std::string> profileparams_;
  ::OsmAnd::OBF::StringTable* tagvaluestable_;
  ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointsBox* pointboxes_;
  ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteBlockSegments > pointsegments_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndHHRoutingIndex* default_instance_;
};
// -------------------------------------------------------------------

class OsmAndOwner : public ::google::protobuf::Message {
 public:
  OsmAndOwner();
  virtual ~OsmAndOwner();

  OsmAndOwner(const OsmAndOwner& from);

  inline OsmAndOwner& operator=(const OsmAndOwner& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OsmAndOwner& default_instance();

  void Swap(OsmAndOwner* other);

  // implements Message ----------------------------------------------

  OsmAndOwner* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OsmAndOwner& from);
  void MergeFrom(const OsmAndOwner& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string resource = 2;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 2;
  inline const ::std::string& resource() const;
  inline void set_resource(const ::std::string& value);
  inline void set_resource(const char* value);
  inline void set_resource(const char* value, size_t size);
  inline ::std::string* mutable_resource();
  inline ::std::string* release_resource();
  inline void set_allocated_resource(::std::string* resource);

  // optional string description = 3;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 3;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional string pluginid = 4;
  inline bool has_pluginid() const;
  inline void clear_pluginid();
  static const int kPluginidFieldNumber = 4;
  inline const ::std::string& pluginid() const;
  inline void set_pluginid(const ::std::string& value);
  inline void set_pluginid(const char* value);
  inline void set_pluginid(const char* value, size_t size);
  inline ::std::string* mutable_pluginid();
  inline ::std::string* release_pluginid();
  inline void set_allocated_pluginid(::std::string* pluginid);

  // @@protoc_insertion_point(class_scope:OsmAnd.OBF.OsmAndOwner)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_resource();
  inline void clear_has_resource();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_pluginid();
  inline void clear_has_pluginid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* resource_;
  ::std::string* description_;
  ::std::string* pluginid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_OBF_2eproto();
  friend void protobuf_AssignDesc_OBF_2eproto();
  friend void protobuf_ShutdownFile_OBF_2eproto();

  void InitAsDefaultInstance();
  static OsmAndOwner* default_instance_;
};
// ===================================================================


// ===================================================================

// OsmAndStructure

// required uint32 version = 1;
inline bool OsmAndStructure::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsmAndStructure::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsmAndStructure::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsmAndStructure::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 OsmAndStructure::version() const {
  return version_;
}
inline void OsmAndStructure::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
}

// required int64 dateCreated = 18;
inline bool OsmAndStructure::has_datecreated() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OsmAndStructure::set_has_datecreated() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OsmAndStructure::clear_has_datecreated() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OsmAndStructure::clear_datecreated() {
  datecreated_ = GOOGLE_LONGLONG(0);
  clear_has_datecreated();
}
inline ::google::protobuf::int64 OsmAndStructure::datecreated() const {
  return datecreated_;
}
inline void OsmAndStructure::set_datecreated(::google::protobuf::int64 value) {
  set_has_datecreated();
  datecreated_ = value;
}

// optional .OsmAnd.OBF.OsmAndOwner owner = 33;
inline bool OsmAndStructure::has_owner() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OsmAndStructure::set_has_owner() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OsmAndStructure::clear_has_owner() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OsmAndStructure::clear_owner() {
  if (owner_ != NULL) owner_->::OsmAnd::OBF::OsmAndOwner::Clear();
  clear_has_owner();
}
inline const ::OsmAnd::OBF::OsmAndOwner& OsmAndStructure::owner() const {
  return owner_ != NULL ? *owner_ : *default_instance_->owner_;
}
inline ::OsmAnd::OBF::OsmAndOwner* OsmAndStructure::mutable_owner() {
  set_has_owner();
  if (owner_ == NULL) owner_ = new ::OsmAnd::OBF::OsmAndOwner;
  return owner_;
}
inline ::OsmAnd::OBF::OsmAndOwner* OsmAndStructure::release_owner() {
  clear_has_owner();
  ::OsmAnd::OBF::OsmAndOwner* temp = owner_;
  owner_ = NULL;
  return temp;
}
inline void OsmAndStructure::set_allocated_owner(::OsmAnd::OBF::OsmAndOwner* owner) {
  delete owner_;
  owner_ = owner;
  if (owner) {
    set_has_owner();
  } else {
    clear_has_owner();
  }
}

// repeated .OsmAnd.OBF.OsmAndAddressIndex addressIndex = 7;
inline int OsmAndStructure::addressindex_size() const {
  return addressindex_.size();
}
inline void OsmAndStructure::clear_addressindex() {
  addressindex_.Clear();
}
inline const ::OsmAnd::OBF::OsmAndAddressIndex& OsmAndStructure::addressindex(int index) const {
  return addressindex_.Get(index);
}
inline ::OsmAnd::OBF::OsmAndAddressIndex* OsmAndStructure::mutable_addressindex(int index) {
  return addressindex_.Mutable(index);
}
inline ::OsmAnd::OBF::OsmAndAddressIndex* OsmAndStructure::add_addressindex() {
  return addressindex_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndAddressIndex >&
OsmAndStructure::addressindex() const {
  return addressindex_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndAddressIndex >*
OsmAndStructure::mutable_addressindex() {
  return &addressindex_;
}

// repeated .OsmAnd.OBF.OsmAndTransportIndex transportIndex = 4;
inline int OsmAndStructure::transportindex_size() const {
  return transportindex_.size();
}
inline void OsmAndStructure::clear_transportindex() {
  transportindex_.Clear();
}
inline const ::OsmAnd::OBF::OsmAndTransportIndex& OsmAndStructure::transportindex(int index) const {
  return transportindex_.Get(index);
}
inline ::OsmAnd::OBF::OsmAndTransportIndex* OsmAndStructure::mutable_transportindex(int index) {
  return transportindex_.Mutable(index);
}
inline ::OsmAnd::OBF::OsmAndTransportIndex* OsmAndStructure::add_transportindex() {
  return transportindex_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndTransportIndex >&
OsmAndStructure::transportindex() const {
  return transportindex_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndTransportIndex >*
OsmAndStructure::mutable_transportindex() {
  return &transportindex_;
}

// repeated .OsmAnd.OBF.OsmAndPoiIndex poiIndex = 8;
inline int OsmAndStructure::poiindex_size() const {
  return poiindex_.size();
}
inline void OsmAndStructure::clear_poiindex() {
  poiindex_.Clear();
}
inline const ::OsmAnd::OBF::OsmAndPoiIndex& OsmAndStructure::poiindex(int index) const {
  return poiindex_.Get(index);
}
inline ::OsmAnd::OBF::OsmAndPoiIndex* OsmAndStructure::mutable_poiindex(int index) {
  return poiindex_.Mutable(index);
}
inline ::OsmAnd::OBF::OsmAndPoiIndex* OsmAndStructure::add_poiindex() {
  return poiindex_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiIndex >&
OsmAndStructure::poiindex() const {
  return poiindex_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiIndex >*
OsmAndStructure::mutable_poiindex() {
  return &poiindex_;
}

// repeated .OsmAnd.OBF.OsmAndMapIndex mapIndex = 6;
inline int OsmAndStructure::mapindex_size() const {
  return mapindex_.size();
}
inline void OsmAndStructure::clear_mapindex() {
  mapindex_.Clear();
}
inline const ::OsmAnd::OBF::OsmAndMapIndex& OsmAndStructure::mapindex(int index) const {
  return mapindex_.Get(index);
}
inline ::OsmAnd::OBF::OsmAndMapIndex* OsmAndStructure::mutable_mapindex(int index) {
  return mapindex_.Mutable(index);
}
inline ::OsmAnd::OBF::OsmAndMapIndex* OsmAndStructure::add_mapindex() {
  return mapindex_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndMapIndex >&
OsmAndStructure::mapindex() const {
  return mapindex_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndMapIndex >*
OsmAndStructure::mutable_mapindex() {
  return &mapindex_;
}

// repeated .OsmAnd.OBF.OsmAndRoutingIndex routingIndex = 9;
inline int OsmAndStructure::routingindex_size() const {
  return routingindex_.size();
}
inline void OsmAndStructure::clear_routingindex() {
  routingindex_.Clear();
}
inline const ::OsmAnd::OBF::OsmAndRoutingIndex& OsmAndStructure::routingindex(int index) const {
  return routingindex_.Get(index);
}
inline ::OsmAnd::OBF::OsmAndRoutingIndex* OsmAndStructure::mutable_routingindex(int index) {
  return routingindex_.Mutable(index);
}
inline ::OsmAnd::OBF::OsmAndRoutingIndex* OsmAndStructure::add_routingindex() {
  return routingindex_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndRoutingIndex >&
OsmAndStructure::routingindex() const {
  return routingindex_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndRoutingIndex >*
OsmAndStructure::mutable_routingindex() {
  return &routingindex_;
}

// repeated .OsmAnd.OBF.OsmAndHHRoutingIndex hhRoutingIndex = 10;
inline int OsmAndStructure::hhroutingindex_size() const {
  return hhroutingindex_.size();
}
inline void OsmAndStructure::clear_hhroutingindex() {
  hhroutingindex_.Clear();
}
inline const ::OsmAnd::OBF::OsmAndHHRoutingIndex& OsmAndStructure::hhroutingindex(int index) const {
  return hhroutingindex_.Get(index);
}
inline ::OsmAnd::OBF::OsmAndHHRoutingIndex* OsmAndStructure::mutable_hhroutingindex(int index) {
  return hhroutingindex_.Mutable(index);
}
inline ::OsmAnd::OBF::OsmAndHHRoutingIndex* OsmAndStructure::add_hhroutingindex() {
  return hhroutingindex_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndHHRoutingIndex >&
OsmAndStructure::hhroutingindex() const {
  return hhroutingindex_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndHHRoutingIndex >*
OsmAndStructure::mutable_hhroutingindex() {
  return &hhroutingindex_;
}

// required uint32 versionConfirm = 32;
inline bool OsmAndStructure::has_versionconfirm() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void OsmAndStructure::set_has_versionconfirm() {
  _has_bits_[0] |= 0x00000200u;
}
inline void OsmAndStructure::clear_has_versionconfirm() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void OsmAndStructure::clear_versionconfirm() {
  versionconfirm_ = 0u;
  clear_has_versionconfirm();
}
inline ::google::protobuf::uint32 OsmAndStructure::versionconfirm() const {
  return versionconfirm_;
}
inline void OsmAndStructure::set_versionconfirm(::google::protobuf::uint32 value) {
  set_has_versionconfirm();
  versionconfirm_ = value;
}

// -------------------------------------------------------------------

// OsmAndTileBox

// required uint32 left = 1;
inline bool OsmAndTileBox::has_left() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsmAndTileBox::set_has_left() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsmAndTileBox::clear_has_left() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsmAndTileBox::clear_left() {
  left_ = 0u;
  clear_has_left();
}
inline ::google::protobuf::uint32 OsmAndTileBox::left() const {
  return left_;
}
inline void OsmAndTileBox::set_left(::google::protobuf::uint32 value) {
  set_has_left();
  left_ = value;
}

// required uint32 right = 2;
inline bool OsmAndTileBox::has_right() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OsmAndTileBox::set_has_right() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OsmAndTileBox::clear_has_right() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OsmAndTileBox::clear_right() {
  right_ = 0u;
  clear_has_right();
}
inline ::google::protobuf::uint32 OsmAndTileBox::right() const {
  return right_;
}
inline void OsmAndTileBox::set_right(::google::protobuf::uint32 value) {
  set_has_right();
  right_ = value;
}

// required uint32 top = 3;
inline bool OsmAndTileBox::has_top() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OsmAndTileBox::set_has_top() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OsmAndTileBox::clear_has_top() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OsmAndTileBox::clear_top() {
  top_ = 0u;
  clear_has_top();
}
inline ::google::protobuf::uint32 OsmAndTileBox::top() const {
  return top_;
}
inline void OsmAndTileBox::set_top(::google::protobuf::uint32 value) {
  set_has_top();
  top_ = value;
}

// required uint32 bottom = 4;
inline bool OsmAndTileBox::has_bottom() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OsmAndTileBox::set_has_bottom() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OsmAndTileBox::clear_has_bottom() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OsmAndTileBox::clear_bottom() {
  bottom_ = 0u;
  clear_has_bottom();
}
inline ::google::protobuf::uint32 OsmAndTileBox::bottom() const {
  return bottom_;
}
inline void OsmAndTileBox::set_bottom(::google::protobuf::uint32 value) {
  set_has_bottom();
  bottom_ = value;
}

// -------------------------------------------------------------------

// StringTable

// repeated string s = 1;
inline int StringTable::s_size() const {
  return s_.size();
}
inline void StringTable::clear_s() {
  s_.Clear();
}
inline const ::std::string& StringTable::s(int index) const {
  return s_.Get(index);
}
inline ::std::string* StringTable::mutable_s(int index) {
  return s_.Mutable(index);
}
inline void StringTable::set_s(int index, const ::std::string& value) {
  s_.Mutable(index)->assign(value);
}
inline void StringTable::set_s(int index, const char* value) {
  s_.Mutable(index)->assign(value);
}
inline void StringTable::set_s(int index, const char* value, size_t size) {
  s_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StringTable::add_s() {
  return s_.Add();
}
inline void StringTable::add_s(const ::std::string& value) {
  s_.Add()->assign(value);
}
inline void StringTable::add_s(const char* value) {
  s_.Add()->assign(value);
}
inline void StringTable::add_s(const char* value, size_t size) {
  s_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StringTable::s() const {
  return s_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StringTable::mutable_s() {
  return &s_;
}

// -------------------------------------------------------------------

// IndexedStringTable

// optional string prefix = 1;
inline bool IndexedStringTable::has_prefix() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IndexedStringTable::set_has_prefix() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IndexedStringTable::clear_has_prefix() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IndexedStringTable::clear_prefix() {
  if (prefix_ != &::google::protobuf::internal::kEmptyString) {
    prefix_->clear();
  }
  clear_has_prefix();
}
inline const ::std::string& IndexedStringTable::prefix() const {
  return *prefix_;
}
inline void IndexedStringTable::set_prefix(const ::std::string& value) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
}
inline void IndexedStringTable::set_prefix(const char* value) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
}
inline void IndexedStringTable::set_prefix(const char* value, size_t size) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IndexedStringTable::mutable_prefix() {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  return prefix_;
}
inline ::std::string* IndexedStringTable::release_prefix() {
  clear_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prefix_;
    prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IndexedStringTable::set_allocated_prefix(::std::string* prefix) {
  if (prefix_ != &::google::protobuf::internal::kEmptyString) {
    delete prefix_;
  }
  if (prefix) {
    set_has_prefix();
    prefix_ = prefix;
  } else {
    clear_has_prefix();
    prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string key = 3;
inline int IndexedStringTable::key_size() const {
  return key_.size();
}
inline void IndexedStringTable::clear_key() {
  key_.Clear();
}
inline const ::std::string& IndexedStringTable::key(int index) const {
  return key_.Get(index);
}
inline ::std::string* IndexedStringTable::mutable_key(int index) {
  return key_.Mutable(index);
}
inline void IndexedStringTable::set_key(int index, const ::std::string& value) {
  key_.Mutable(index)->assign(value);
}
inline void IndexedStringTable::set_key(int index, const char* value) {
  key_.Mutable(index)->assign(value);
}
inline void IndexedStringTable::set_key(int index, const char* value, size_t size) {
  key_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IndexedStringTable::add_key() {
  return key_.Add();
}
inline void IndexedStringTable::add_key(const ::std::string& value) {
  key_.Add()->assign(value);
}
inline void IndexedStringTable::add_key(const char* value) {
  key_.Add()->assign(value);
}
inline void IndexedStringTable::add_key(const char* value, size_t size) {
  key_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
IndexedStringTable::key() const {
  return key_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
IndexedStringTable::mutable_key() {
  return &key_;
}

// repeated fixed32 val = 4;
inline int IndexedStringTable::val_size() const {
  return val_.size();
}
inline void IndexedStringTable::clear_val() {
  val_.Clear();
}
inline ::google::protobuf::uint32 IndexedStringTable::val(int index) const {
  return val_.Get(index);
}
inline void IndexedStringTable::set_val(int index, ::google::protobuf::uint32 value) {
  val_.Set(index, value);
}
inline void IndexedStringTable::add_val(::google::protobuf::uint32 value) {
  val_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IndexedStringTable::val() const {
  return val_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IndexedStringTable::mutable_val() {
  return &val_;
}

// repeated .OsmAnd.OBF.IndexedStringTable subtables = 5;
inline int IndexedStringTable::subtables_size() const {
  return subtables_.size();
}
inline void IndexedStringTable::clear_subtables() {
  subtables_.Clear();
}
inline const ::OsmAnd::OBF::IndexedStringTable& IndexedStringTable::subtables(int index) const {
  return subtables_.Get(index);
}
inline ::OsmAnd::OBF::IndexedStringTable* IndexedStringTable::mutable_subtables(int index) {
  return subtables_.Mutable(index);
}
inline ::OsmAnd::OBF::IndexedStringTable* IndexedStringTable::add_subtables() {
  return subtables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::IndexedStringTable >&
IndexedStringTable::subtables() const {
  return subtables_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::IndexedStringTable >*
IndexedStringTable::mutable_subtables() {
  return &subtables_;
}

// -------------------------------------------------------------------

// OsmAndMapIndex_MapEncodingRule

// required string tag = 3;
inline bool OsmAndMapIndex_MapEncodingRule::has_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsmAndMapIndex_MapEncodingRule::set_has_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsmAndMapIndex_MapEncodingRule::clear_has_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsmAndMapIndex_MapEncodingRule::clear_tag() {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& OsmAndMapIndex_MapEncodingRule::tag() const {
  return *tag_;
}
inline void OsmAndMapIndex_MapEncodingRule::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void OsmAndMapIndex_MapEncodingRule::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void OsmAndMapIndex_MapEncodingRule::set_tag(const char* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndMapIndex_MapEncodingRule::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  return tag_;
}
inline ::std::string* OsmAndMapIndex_MapEncodingRule::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OsmAndMapIndex_MapEncodingRule::set_allocated_tag(::std::string* tag) {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    delete tag_;
  }
  if (tag) {
    set_has_tag();
    tag_ = tag;
  } else {
    clear_has_tag();
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string value = 5;
inline bool OsmAndMapIndex_MapEncodingRule::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OsmAndMapIndex_MapEncodingRule::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OsmAndMapIndex_MapEncodingRule::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OsmAndMapIndex_MapEncodingRule::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& OsmAndMapIndex_MapEncodingRule::value() const {
  return *value_;
}
inline void OsmAndMapIndex_MapEncodingRule::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void OsmAndMapIndex_MapEncodingRule::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void OsmAndMapIndex_MapEncodingRule::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndMapIndex_MapEncodingRule::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* OsmAndMapIndex_MapEncodingRule::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OsmAndMapIndex_MapEncodingRule::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 id = 7;
inline bool OsmAndMapIndex_MapEncodingRule::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OsmAndMapIndex_MapEncodingRule::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OsmAndMapIndex_MapEncodingRule::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OsmAndMapIndex_MapEncodingRule::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 OsmAndMapIndex_MapEncodingRule::id() const {
  return id_;
}
inline void OsmAndMapIndex_MapEncodingRule::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 minZoom = 9;
inline bool OsmAndMapIndex_MapEncodingRule::has_minzoom() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OsmAndMapIndex_MapEncodingRule::set_has_minzoom() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OsmAndMapIndex_MapEncodingRule::clear_has_minzoom() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OsmAndMapIndex_MapEncodingRule::clear_minzoom() {
  minzoom_ = 0u;
  clear_has_minzoom();
}
inline ::google::protobuf::uint32 OsmAndMapIndex_MapEncodingRule::minzoom() const {
  return minzoom_;
}
inline void OsmAndMapIndex_MapEncodingRule::set_minzoom(::google::protobuf::uint32 value) {
  set_has_minzoom();
  minzoom_ = value;
}

// optional uint32 type = 10;
inline bool OsmAndMapIndex_MapEncodingRule::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OsmAndMapIndex_MapEncodingRule::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OsmAndMapIndex_MapEncodingRule::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OsmAndMapIndex_MapEncodingRule::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 OsmAndMapIndex_MapEncodingRule::type() const {
  return type_;
}
inline void OsmAndMapIndex_MapEncodingRule::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// OsmAndMapIndex_MapRootLevel

// required int32 maxZoom = 1;
inline bool OsmAndMapIndex_MapRootLevel::has_maxzoom() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsmAndMapIndex_MapRootLevel::set_has_maxzoom() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsmAndMapIndex_MapRootLevel::clear_has_maxzoom() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsmAndMapIndex_MapRootLevel::clear_maxzoom() {
  maxzoom_ = 0;
  clear_has_maxzoom();
}
inline ::google::protobuf::int32 OsmAndMapIndex_MapRootLevel::maxzoom() const {
  return maxzoom_;
}
inline void OsmAndMapIndex_MapRootLevel::set_maxzoom(::google::protobuf::int32 value) {
  set_has_maxzoom();
  maxzoom_ = value;
}

// required int32 minZoom = 2;
inline bool OsmAndMapIndex_MapRootLevel::has_minzoom() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OsmAndMapIndex_MapRootLevel::set_has_minzoom() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OsmAndMapIndex_MapRootLevel::clear_has_minzoom() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OsmAndMapIndex_MapRootLevel::clear_minzoom() {
  minzoom_ = 0;
  clear_has_minzoom();
}
inline ::google::protobuf::int32 OsmAndMapIndex_MapRootLevel::minzoom() const {
  return minzoom_;
}
inline void OsmAndMapIndex_MapRootLevel::set_minzoom(::google::protobuf::int32 value) {
  set_has_minzoom();
  minzoom_ = value;
}

// required int32 left = 3;
inline bool OsmAndMapIndex_MapRootLevel::has_left() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OsmAndMapIndex_MapRootLevel::set_has_left() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OsmAndMapIndex_MapRootLevel::clear_has_left() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OsmAndMapIndex_MapRootLevel::clear_left() {
  left_ = 0;
  clear_has_left();
}
inline ::google::protobuf::int32 OsmAndMapIndex_MapRootLevel::left() const {
  return left_;
}
inline void OsmAndMapIndex_MapRootLevel::set_left(::google::protobuf::int32 value) {
  set_has_left();
  left_ = value;
}

// required int32 right = 4;
inline bool OsmAndMapIndex_MapRootLevel::has_right() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OsmAndMapIndex_MapRootLevel::set_has_right() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OsmAndMapIndex_MapRootLevel::clear_has_right() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OsmAndMapIndex_MapRootLevel::clear_right() {
  right_ = 0;
  clear_has_right();
}
inline ::google::protobuf::int32 OsmAndMapIndex_MapRootLevel::right() const {
  return right_;
}
inline void OsmAndMapIndex_MapRootLevel::set_right(::google::protobuf::int32 value) {
  set_has_right();
  right_ = value;
}

// required int32 top = 5;
inline bool OsmAndMapIndex_MapRootLevel::has_top() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OsmAndMapIndex_MapRootLevel::set_has_top() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OsmAndMapIndex_MapRootLevel::clear_has_top() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OsmAndMapIndex_MapRootLevel::clear_top() {
  top_ = 0;
  clear_has_top();
}
inline ::google::protobuf::int32 OsmAndMapIndex_MapRootLevel::top() const {
  return top_;
}
inline void OsmAndMapIndex_MapRootLevel::set_top(::google::protobuf::int32 value) {
  set_has_top();
  top_ = value;
}

// required int32 bottom = 6;
inline bool OsmAndMapIndex_MapRootLevel::has_bottom() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OsmAndMapIndex_MapRootLevel::set_has_bottom() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OsmAndMapIndex_MapRootLevel::clear_has_bottom() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OsmAndMapIndex_MapRootLevel::clear_bottom() {
  bottom_ = 0;
  clear_has_bottom();
}
inline ::google::protobuf::int32 OsmAndMapIndex_MapRootLevel::bottom() const {
  return bottom_;
}
inline void OsmAndMapIndex_MapRootLevel::set_bottom(::google::protobuf::int32 value) {
  set_has_bottom();
  bottom_ = value;
}

// repeated .OsmAnd.OBF.OsmAndMapIndex.MapDataBox boxes = 7;
inline int OsmAndMapIndex_MapRootLevel::boxes_size() const {
  return boxes_.size();
}
inline void OsmAndMapIndex_MapRootLevel::clear_boxes() {
  boxes_.Clear();
}
inline const ::OsmAnd::OBF::OsmAndMapIndex_MapDataBox& OsmAndMapIndex_MapRootLevel::boxes(int index) const {
  return boxes_.Get(index);
}
inline ::OsmAnd::OBF::OsmAndMapIndex_MapDataBox* OsmAndMapIndex_MapRootLevel::mutable_boxes(int index) {
  return boxes_.Mutable(index);
}
inline ::OsmAnd::OBF::OsmAndMapIndex_MapDataBox* OsmAndMapIndex_MapRootLevel::add_boxes() {
  return boxes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndMapIndex_MapDataBox >&
OsmAndMapIndex_MapRootLevel::boxes() const {
  return boxes_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndMapIndex_MapDataBox >*
OsmAndMapIndex_MapRootLevel::mutable_boxes() {
  return &boxes_;
}

// repeated .OsmAnd.OBF.MapDataBlock blocks = 15;
inline int OsmAndMapIndex_MapRootLevel::blocks_size() const {
  return blocks_.size();
}
inline void OsmAndMapIndex_MapRootLevel::clear_blocks() {
  blocks_.Clear();
}
inline const ::OsmAnd::OBF::MapDataBlock& OsmAndMapIndex_MapRootLevel::blocks(int index) const {
  return blocks_.Get(index);
}
inline ::OsmAnd::OBF::MapDataBlock* OsmAndMapIndex_MapRootLevel::mutable_blocks(int index) {
  return blocks_.Mutable(index);
}
inline ::OsmAnd::OBF::MapDataBlock* OsmAndMapIndex_MapRootLevel::add_blocks() {
  return blocks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::MapDataBlock >&
OsmAndMapIndex_MapRootLevel::blocks() const {
  return blocks_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::MapDataBlock >*
OsmAndMapIndex_MapRootLevel::mutable_blocks() {
  return &blocks_;
}

// -------------------------------------------------------------------

// OsmAndMapIndex_MapDataBox

// required sint32 left = 1;
inline bool OsmAndMapIndex_MapDataBox::has_left() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsmAndMapIndex_MapDataBox::set_has_left() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsmAndMapIndex_MapDataBox::clear_has_left() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsmAndMapIndex_MapDataBox::clear_left() {
  left_ = 0;
  clear_has_left();
}
inline ::google::protobuf::int32 OsmAndMapIndex_MapDataBox::left() const {
  return left_;
}
inline void OsmAndMapIndex_MapDataBox::set_left(::google::protobuf::int32 value) {
  set_has_left();
  left_ = value;
}

// required sint32 right = 2;
inline bool OsmAndMapIndex_MapDataBox::has_right() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OsmAndMapIndex_MapDataBox::set_has_right() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OsmAndMapIndex_MapDataBox::clear_has_right() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OsmAndMapIndex_MapDataBox::clear_right() {
  right_ = 0;
  clear_has_right();
}
inline ::google::protobuf::int32 OsmAndMapIndex_MapDataBox::right() const {
  return right_;
}
inline void OsmAndMapIndex_MapDataBox::set_right(::google::protobuf::int32 value) {
  set_has_right();
  right_ = value;
}

// required sint32 top = 3;
inline bool OsmAndMapIndex_MapDataBox::has_top() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OsmAndMapIndex_MapDataBox::set_has_top() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OsmAndMapIndex_MapDataBox::clear_has_top() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OsmAndMapIndex_MapDataBox::clear_top() {
  top_ = 0;
  clear_has_top();
}
inline ::google::protobuf::int32 OsmAndMapIndex_MapDataBox::top() const {
  return top_;
}
inline void OsmAndMapIndex_MapDataBox::set_top(::google::protobuf::int32 value) {
  set_has_top();
  top_ = value;
}

// required sint32 bottom = 4;
inline bool OsmAndMapIndex_MapDataBox::has_bottom() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OsmAndMapIndex_MapDataBox::set_has_bottom() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OsmAndMapIndex_MapDataBox::clear_has_bottom() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OsmAndMapIndex_MapDataBox::clear_bottom() {
  bottom_ = 0;
  clear_has_bottom();
}
inline ::google::protobuf::int32 OsmAndMapIndex_MapDataBox::bottom() const {
  return bottom_;
}
inline void OsmAndMapIndex_MapDataBox::set_bottom(::google::protobuf::int32 value) {
  set_has_bottom();
  bottom_ = value;
}

// optional fixed32 shiftToMapData = 5;
inline bool OsmAndMapIndex_MapDataBox::has_shifttomapdata() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OsmAndMapIndex_MapDataBox::set_has_shifttomapdata() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OsmAndMapIndex_MapDataBox::clear_has_shifttomapdata() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OsmAndMapIndex_MapDataBox::clear_shifttomapdata() {
  shifttomapdata_ = 0u;
  clear_has_shifttomapdata();
}
inline ::google::protobuf::uint32 OsmAndMapIndex_MapDataBox::shifttomapdata() const {
  return shifttomapdata_;
}
inline void OsmAndMapIndex_MapDataBox::set_shifttomapdata(::google::protobuf::uint32 value) {
  set_has_shifttomapdata();
  shifttomapdata_ = value;
}

// optional bool ocean = 6;
inline bool OsmAndMapIndex_MapDataBox::has_ocean() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OsmAndMapIndex_MapDataBox::set_has_ocean() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OsmAndMapIndex_MapDataBox::clear_has_ocean() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OsmAndMapIndex_MapDataBox::clear_ocean() {
  ocean_ = false;
  clear_has_ocean();
}
inline bool OsmAndMapIndex_MapDataBox::ocean() const {
  return ocean_;
}
inline void OsmAndMapIndex_MapDataBox::set_ocean(bool value) {
  set_has_ocean();
  ocean_ = value;
}

// repeated .OsmAnd.OBF.OsmAndMapIndex.MapDataBox boxes = 7;
inline int OsmAndMapIndex_MapDataBox::boxes_size() const {
  return boxes_.size();
}
inline void OsmAndMapIndex_MapDataBox::clear_boxes() {
  boxes_.Clear();
}
inline const ::OsmAnd::OBF::OsmAndMapIndex_MapDataBox& OsmAndMapIndex_MapDataBox::boxes(int index) const {
  return boxes_.Get(index);
}
inline ::OsmAnd::OBF::OsmAndMapIndex_MapDataBox* OsmAndMapIndex_MapDataBox::mutable_boxes(int index) {
  return boxes_.Mutable(index);
}
inline ::OsmAnd::OBF::OsmAndMapIndex_MapDataBox* OsmAndMapIndex_MapDataBox::add_boxes() {
  return boxes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndMapIndex_MapDataBox >&
OsmAndMapIndex_MapDataBox::boxes() const {
  return boxes_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndMapIndex_MapDataBox >*
OsmAndMapIndex_MapDataBox::mutable_boxes() {
  return &boxes_;
}

// -------------------------------------------------------------------

// OsmAndMapIndex

// required string name = 2;
inline bool OsmAndMapIndex::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsmAndMapIndex::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsmAndMapIndex::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsmAndMapIndex::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& OsmAndMapIndex::name() const {
  return *name_;
}
inline void OsmAndMapIndex::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndMapIndex::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndMapIndex::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndMapIndex::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* OsmAndMapIndex::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OsmAndMapIndex::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .OsmAnd.OBF.OsmAndMapIndex.MapEncodingRule rules = 4;
inline int OsmAndMapIndex::rules_size() const {
  return rules_.size();
}
inline void OsmAndMapIndex::clear_rules() {
  rules_.Clear();
}
inline const ::OsmAnd::OBF::OsmAndMapIndex_MapEncodingRule& OsmAndMapIndex::rules(int index) const {
  return rules_.Get(index);
}
inline ::OsmAnd::OBF::OsmAndMapIndex_MapEncodingRule* OsmAndMapIndex::mutable_rules(int index) {
  return rules_.Mutable(index);
}
inline ::OsmAnd::OBF::OsmAndMapIndex_MapEncodingRule* OsmAndMapIndex::add_rules() {
  return rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndMapIndex_MapEncodingRule >&
OsmAndMapIndex::rules() const {
  return rules_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndMapIndex_MapEncodingRule >*
OsmAndMapIndex::mutable_rules() {
  return &rules_;
}

// repeated .OsmAnd.OBF.OsmAndMapIndex.MapRootLevel levels = 5;
inline int OsmAndMapIndex::levels_size() const {
  return levels_.size();
}
inline void OsmAndMapIndex::clear_levels() {
  levels_.Clear();
}
inline const ::OsmAnd::OBF::OsmAndMapIndex_MapRootLevel& OsmAndMapIndex::levels(int index) const {
  return levels_.Get(index);
}
inline ::OsmAnd::OBF::OsmAndMapIndex_MapRootLevel* OsmAndMapIndex::mutable_levels(int index) {
  return levels_.Mutable(index);
}
inline ::OsmAnd::OBF::OsmAndMapIndex_MapRootLevel* OsmAndMapIndex::add_levels() {
  return levels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndMapIndex_MapRootLevel >&
OsmAndMapIndex::levels() const {
  return levels_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndMapIndex_MapRootLevel >*
OsmAndMapIndex::mutable_levels() {
  return &levels_;
}

// -------------------------------------------------------------------

// MapDataBlock

// optional uint64 baseId = 10;
inline bool MapDataBlock::has_baseid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapDataBlock::set_has_baseid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapDataBlock::clear_has_baseid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapDataBlock::clear_baseid() {
  baseid_ = GOOGLE_ULONGLONG(0);
  clear_has_baseid();
}
inline ::google::protobuf::uint64 MapDataBlock::baseid() const {
  return baseid_;
}
inline void MapDataBlock::set_baseid(::google::protobuf::uint64 value) {
  set_has_baseid();
  baseid_ = value;
}

// repeated .OsmAnd.OBF.MapData dataObjects = 12;
inline int MapDataBlock::dataobjects_size() const {
  return dataobjects_.size();
}
inline void MapDataBlock::clear_dataobjects() {
  dataobjects_.Clear();
}
inline const ::OsmAnd::OBF::MapData& MapDataBlock::dataobjects(int index) const {
  return dataobjects_.Get(index);
}
inline ::OsmAnd::OBF::MapData* MapDataBlock::mutable_dataobjects(int index) {
  return dataobjects_.Mutable(index);
}
inline ::OsmAnd::OBF::MapData* MapDataBlock::add_dataobjects() {
  return dataobjects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::MapData >&
MapDataBlock::dataobjects() const {
  return dataobjects_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::MapData >*
MapDataBlock::mutable_dataobjects() {
  return &dataobjects_;
}

// optional .OsmAnd.OBF.StringTable stringTable = 15;
inline bool MapDataBlock::has_stringtable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapDataBlock::set_has_stringtable() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapDataBlock::clear_has_stringtable() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapDataBlock::clear_stringtable() {
  if (stringtable_ != NULL) stringtable_->::OsmAnd::OBF::StringTable::Clear();
  clear_has_stringtable();
}
inline const ::OsmAnd::OBF::StringTable& MapDataBlock::stringtable() const {
  return stringtable_ != NULL ? *stringtable_ : *default_instance_->stringtable_;
}
inline ::OsmAnd::OBF::StringTable* MapDataBlock::mutable_stringtable() {
  set_has_stringtable();
  if (stringtable_ == NULL) stringtable_ = new ::OsmAnd::OBF::StringTable;
  return stringtable_;
}
inline ::OsmAnd::OBF::StringTable* MapDataBlock::release_stringtable() {
  clear_has_stringtable();
  ::OsmAnd::OBF::StringTable* temp = stringtable_;
  stringtable_ = NULL;
  return temp;
}
inline void MapDataBlock::set_allocated_stringtable(::OsmAnd::OBF::StringTable* stringtable) {
  delete stringtable_;
  stringtable_ = stringtable;
  if (stringtable) {
    set_has_stringtable();
  } else {
    clear_has_stringtable();
  }
}

// -------------------------------------------------------------------

// MapData

// optional bytes coordinates = 1;
inline bool MapData::has_coordinates() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapData::set_has_coordinates() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapData::clear_has_coordinates() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapData::clear_coordinates() {
  if (coordinates_ != &::google::protobuf::internal::kEmptyString) {
    coordinates_->clear();
  }
  clear_has_coordinates();
}
inline const ::std::string& MapData::coordinates() const {
  return *coordinates_;
}
inline void MapData::set_coordinates(const ::std::string& value) {
  set_has_coordinates();
  if (coordinates_ == &::google::protobuf::internal::kEmptyString) {
    coordinates_ = new ::std::string;
  }
  coordinates_->assign(value);
}
inline void MapData::set_coordinates(const char* value) {
  set_has_coordinates();
  if (coordinates_ == &::google::protobuf::internal::kEmptyString) {
    coordinates_ = new ::std::string;
  }
  coordinates_->assign(value);
}
inline void MapData::set_coordinates(const void* value, size_t size) {
  set_has_coordinates();
  if (coordinates_ == &::google::protobuf::internal::kEmptyString) {
    coordinates_ = new ::std::string;
  }
  coordinates_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapData::mutable_coordinates() {
  set_has_coordinates();
  if (coordinates_ == &::google::protobuf::internal::kEmptyString) {
    coordinates_ = new ::std::string;
  }
  return coordinates_;
}
inline ::std::string* MapData::release_coordinates() {
  clear_has_coordinates();
  if (coordinates_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = coordinates_;
    coordinates_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapData::set_allocated_coordinates(::std::string* coordinates) {
  if (coordinates_ != &::google::protobuf::internal::kEmptyString) {
    delete coordinates_;
  }
  if (coordinates) {
    set_has_coordinates();
    coordinates_ = coordinates;
  } else {
    clear_has_coordinates();
    coordinates_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes areaCoordinates = 2;
inline bool MapData::has_areacoordinates() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapData::set_has_areacoordinates() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapData::clear_has_areacoordinates() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapData::clear_areacoordinates() {
  if (areacoordinates_ != &::google::protobuf::internal::kEmptyString) {
    areacoordinates_->clear();
  }
  clear_has_areacoordinates();
}
inline const ::std::string& MapData::areacoordinates() const {
  return *areacoordinates_;
}
inline void MapData::set_areacoordinates(const ::std::string& value) {
  set_has_areacoordinates();
  if (areacoordinates_ == &::google::protobuf::internal::kEmptyString) {
    areacoordinates_ = new ::std::string;
  }
  areacoordinates_->assign(value);
}
inline void MapData::set_areacoordinates(const char* value) {
  set_has_areacoordinates();
  if (areacoordinates_ == &::google::protobuf::internal::kEmptyString) {
    areacoordinates_ = new ::std::string;
  }
  areacoordinates_->assign(value);
}
inline void MapData::set_areacoordinates(const void* value, size_t size) {
  set_has_areacoordinates();
  if (areacoordinates_ == &::google::protobuf::internal::kEmptyString) {
    areacoordinates_ = new ::std::string;
  }
  areacoordinates_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapData::mutable_areacoordinates() {
  set_has_areacoordinates();
  if (areacoordinates_ == &::google::protobuf::internal::kEmptyString) {
    areacoordinates_ = new ::std::string;
  }
  return areacoordinates_;
}
inline ::std::string* MapData::release_areacoordinates() {
  clear_has_areacoordinates();
  if (areacoordinates_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = areacoordinates_;
    areacoordinates_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapData::set_allocated_areacoordinates(::std::string* areacoordinates) {
  if (areacoordinates_ != &::google::protobuf::internal::kEmptyString) {
    delete areacoordinates_;
  }
  if (areacoordinates) {
    set_has_areacoordinates();
    areacoordinates_ = areacoordinates;
  } else {
    clear_has_areacoordinates();
    areacoordinates_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated bytes polygonInnerCoordinates = 4;
inline int MapData::polygoninnercoordinates_size() const {
  return polygoninnercoordinates_.size();
}
inline void MapData::clear_polygoninnercoordinates() {
  polygoninnercoordinates_.Clear();
}
inline const ::std::string& MapData::polygoninnercoordinates(int index) const {
  return polygoninnercoordinates_.Get(index);
}
inline ::std::string* MapData::mutable_polygoninnercoordinates(int index) {
  return polygoninnercoordinates_.Mutable(index);
}
inline void MapData::set_polygoninnercoordinates(int index, const ::std::string& value) {
  polygoninnercoordinates_.Mutable(index)->assign(value);
}
inline void MapData::set_polygoninnercoordinates(int index, const char* value) {
  polygoninnercoordinates_.Mutable(index)->assign(value);
}
inline void MapData::set_polygoninnercoordinates(int index, const void* value, size_t size) {
  polygoninnercoordinates_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapData::add_polygoninnercoordinates() {
  return polygoninnercoordinates_.Add();
}
inline void MapData::add_polygoninnercoordinates(const ::std::string& value) {
  polygoninnercoordinates_.Add()->assign(value);
}
inline void MapData::add_polygoninnercoordinates(const char* value) {
  polygoninnercoordinates_.Add()->assign(value);
}
inline void MapData::add_polygoninnercoordinates(const void* value, size_t size) {
  polygoninnercoordinates_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MapData::polygoninnercoordinates() const {
  return polygoninnercoordinates_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MapData::mutable_polygoninnercoordinates() {
  return &polygoninnercoordinates_;
}

// optional bytes additionalTypes = 6;
inline bool MapData::has_additionaltypes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapData::set_has_additionaltypes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapData::clear_has_additionaltypes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapData::clear_additionaltypes() {
  if (additionaltypes_ != &::google::protobuf::internal::kEmptyString) {
    additionaltypes_->clear();
  }
  clear_has_additionaltypes();
}
inline const ::std::string& MapData::additionaltypes() const {
  return *additionaltypes_;
}
inline void MapData::set_additionaltypes(const ::std::string& value) {
  set_has_additionaltypes();
  if (additionaltypes_ == &::google::protobuf::internal::kEmptyString) {
    additionaltypes_ = new ::std::string;
  }
  additionaltypes_->assign(value);
}
inline void MapData::set_additionaltypes(const char* value) {
  set_has_additionaltypes();
  if (additionaltypes_ == &::google::protobuf::internal::kEmptyString) {
    additionaltypes_ = new ::std::string;
  }
  additionaltypes_->assign(value);
}
inline void MapData::set_additionaltypes(const void* value, size_t size) {
  set_has_additionaltypes();
  if (additionaltypes_ == &::google::protobuf::internal::kEmptyString) {
    additionaltypes_ = new ::std::string;
  }
  additionaltypes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapData::mutable_additionaltypes() {
  set_has_additionaltypes();
  if (additionaltypes_ == &::google::protobuf::internal::kEmptyString) {
    additionaltypes_ = new ::std::string;
  }
  return additionaltypes_;
}
inline ::std::string* MapData::release_additionaltypes() {
  clear_has_additionaltypes();
  if (additionaltypes_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = additionaltypes_;
    additionaltypes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapData::set_allocated_additionaltypes(::std::string* additionaltypes) {
  if (additionaltypes_ != &::google::protobuf::internal::kEmptyString) {
    delete additionaltypes_;
  }
  if (additionaltypes) {
    set_has_additionaltypes();
    additionaltypes_ = additionaltypes;
  } else {
    clear_has_additionaltypes();
    additionaltypes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes types = 7;
inline bool MapData::has_types() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapData::set_has_types() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MapData::clear_has_types() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MapData::clear_types() {
  if (types_ != &::google::protobuf::internal::kEmptyString) {
    types_->clear();
  }
  clear_has_types();
}
inline const ::std::string& MapData::types() const {
  return *types_;
}
inline void MapData::set_types(const ::std::string& value) {
  set_has_types();
  if (types_ == &::google::protobuf::internal::kEmptyString) {
    types_ = new ::std::string;
  }
  types_->assign(value);
}
inline void MapData::set_types(const char* value) {
  set_has_types();
  if (types_ == &::google::protobuf::internal::kEmptyString) {
    types_ = new ::std::string;
  }
  types_->assign(value);
}
inline void MapData::set_types(const void* value, size_t size) {
  set_has_types();
  if (types_ == &::google::protobuf::internal::kEmptyString) {
    types_ = new ::std::string;
  }
  types_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapData::mutable_types() {
  set_has_types();
  if (types_ == &::google::protobuf::internal::kEmptyString) {
    types_ = new ::std::string;
  }
  return types_;
}
inline ::std::string* MapData::release_types() {
  clear_has_types();
  if (types_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = types_;
    types_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapData::set_allocated_types(::std::string* types) {
  if (types_ != &::google::protobuf::internal::kEmptyString) {
    delete types_;
  }
  if (types) {
    set_has_types();
    types_ = types;
  } else {
    clear_has_types();
    types_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes labelcoordinates = 8;
inline bool MapData::has_labelcoordinates() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MapData::set_has_labelcoordinates() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MapData::clear_has_labelcoordinates() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MapData::clear_labelcoordinates() {
  if (labelcoordinates_ != &::google::protobuf::internal::kEmptyString) {
    labelcoordinates_->clear();
  }
  clear_has_labelcoordinates();
}
inline const ::std::string& MapData::labelcoordinates() const {
  return *labelcoordinates_;
}
inline void MapData::set_labelcoordinates(const ::std::string& value) {
  set_has_labelcoordinates();
  if (labelcoordinates_ == &::google::protobuf::internal::kEmptyString) {
    labelcoordinates_ = new ::std::string;
  }
  labelcoordinates_->assign(value);
}
inline void MapData::set_labelcoordinates(const char* value) {
  set_has_labelcoordinates();
  if (labelcoordinates_ == &::google::protobuf::internal::kEmptyString) {
    labelcoordinates_ = new ::std::string;
  }
  labelcoordinates_->assign(value);
}
inline void MapData::set_labelcoordinates(const void* value, size_t size) {
  set_has_labelcoordinates();
  if (labelcoordinates_ == &::google::protobuf::internal::kEmptyString) {
    labelcoordinates_ = new ::std::string;
  }
  labelcoordinates_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapData::mutable_labelcoordinates() {
  set_has_labelcoordinates();
  if (labelcoordinates_ == &::google::protobuf::internal::kEmptyString) {
    labelcoordinates_ = new ::std::string;
  }
  return labelcoordinates_;
}
inline ::std::string* MapData::release_labelcoordinates() {
  clear_has_labelcoordinates();
  if (labelcoordinates_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = labelcoordinates_;
    labelcoordinates_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapData::set_allocated_labelcoordinates(::std::string* labelcoordinates) {
  if (labelcoordinates_ != &::google::protobuf::internal::kEmptyString) {
    delete labelcoordinates_;
  }
  if (labelcoordinates) {
    set_has_labelcoordinates();
    labelcoordinates_ = labelcoordinates;
  } else {
    clear_has_labelcoordinates();
    labelcoordinates_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes stringNames = 10;
inline bool MapData::has_stringnames() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MapData::set_has_stringnames() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MapData::clear_has_stringnames() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MapData::clear_stringnames() {
  if (stringnames_ != &::google::protobuf::internal::kEmptyString) {
    stringnames_->clear();
  }
  clear_has_stringnames();
}
inline const ::std::string& MapData::stringnames() const {
  return *stringnames_;
}
inline void MapData::set_stringnames(const ::std::string& value) {
  set_has_stringnames();
  if (stringnames_ == &::google::protobuf::internal::kEmptyString) {
    stringnames_ = new ::std::string;
  }
  stringnames_->assign(value);
}
inline void MapData::set_stringnames(const char* value) {
  set_has_stringnames();
  if (stringnames_ == &::google::protobuf::internal::kEmptyString) {
    stringnames_ = new ::std::string;
  }
  stringnames_->assign(value);
}
inline void MapData::set_stringnames(const void* value, size_t size) {
  set_has_stringnames();
  if (stringnames_ == &::google::protobuf::internal::kEmptyString) {
    stringnames_ = new ::std::string;
  }
  stringnames_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapData::mutable_stringnames() {
  set_has_stringnames();
  if (stringnames_ == &::google::protobuf::internal::kEmptyString) {
    stringnames_ = new ::std::string;
  }
  return stringnames_;
}
inline ::std::string* MapData::release_stringnames() {
  clear_has_stringnames();
  if (stringnames_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stringnames_;
    stringnames_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapData::set_allocated_stringnames(::std::string* stringnames) {
  if (stringnames_ != &::google::protobuf::internal::kEmptyString) {
    delete stringnames_;
  }
  if (stringnames) {
    set_has_stringnames();
    stringnames_ = stringnames;
  } else {
    clear_has_stringnames();
    stringnames_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required sint64 id = 12;
inline bool MapData::has_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MapData::set_has_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MapData::clear_has_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MapData::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 MapData::id() const {
  return id_;
}
inline void MapData::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// optional bytes rasterBytes = 15;
inline bool MapData::has_rasterbytes() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MapData::set_has_rasterbytes() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MapData::clear_has_rasterbytes() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MapData::clear_rasterbytes() {
  if (rasterbytes_ != &::google::protobuf::internal::kEmptyString) {
    rasterbytes_->clear();
  }
  clear_has_rasterbytes();
}
inline const ::std::string& MapData::rasterbytes() const {
  return *rasterbytes_;
}
inline void MapData::set_rasterbytes(const ::std::string& value) {
  set_has_rasterbytes();
  if (rasterbytes_ == &::google::protobuf::internal::kEmptyString) {
    rasterbytes_ = new ::std::string;
  }
  rasterbytes_->assign(value);
}
inline void MapData::set_rasterbytes(const char* value) {
  set_has_rasterbytes();
  if (rasterbytes_ == &::google::protobuf::internal::kEmptyString) {
    rasterbytes_ = new ::std::string;
  }
  rasterbytes_->assign(value);
}
inline void MapData::set_rasterbytes(const void* value, size_t size) {
  set_has_rasterbytes();
  if (rasterbytes_ == &::google::protobuf::internal::kEmptyString) {
    rasterbytes_ = new ::std::string;
  }
  rasterbytes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapData::mutable_rasterbytes() {
  set_has_rasterbytes();
  if (rasterbytes_ == &::google::protobuf::internal::kEmptyString) {
    rasterbytes_ = new ::std::string;
  }
  return rasterbytes_;
}
inline ::std::string* MapData::release_rasterbytes() {
  clear_has_rasterbytes();
  if (rasterbytes_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rasterbytes_;
    rasterbytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapData::set_allocated_rasterbytes(::std::string* rasterbytes) {
  if (rasterbytes_ != &::google::protobuf::internal::kEmptyString) {
    delete rasterbytes_;
  }
  if (rasterbytes) {
    set_has_rasterbytes();
    rasterbytes_ = rasterbytes;
  } else {
    clear_has_rasterbytes();
    rasterbytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// OsmAndAddressIndex_CitiesIndex

// required .OsmAnd.OBF.OsmAndAddressIndex.CitiesIndex.CitiesType type = 2;
inline bool OsmAndAddressIndex_CitiesIndex::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsmAndAddressIndex_CitiesIndex::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsmAndAddressIndex_CitiesIndex::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsmAndAddressIndex_CitiesIndex::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::OsmAnd::OBF::OsmAndAddressIndex_CitiesIndex_CitiesType OsmAndAddressIndex_CitiesIndex::type() const {
  return static_cast< ::OsmAnd::OBF::OsmAndAddressIndex_CitiesIndex_CitiesType >(type_);
}
inline void OsmAndAddressIndex_CitiesIndex::set_type(::OsmAnd::OBF::OsmAndAddressIndex_CitiesIndex_CitiesType value) {
  assert(::OsmAnd::OBF::OsmAndAddressIndex_CitiesIndex_CitiesType_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated .OsmAnd.OBF.CityIndex cities = 5;
inline int OsmAndAddressIndex_CitiesIndex::cities_size() const {
  return cities_.size();
}
inline void OsmAndAddressIndex_CitiesIndex::clear_cities() {
  cities_.Clear();
}
inline const ::OsmAnd::OBF::CityIndex& OsmAndAddressIndex_CitiesIndex::cities(int index) const {
  return cities_.Get(index);
}
inline ::OsmAnd::OBF::CityIndex* OsmAndAddressIndex_CitiesIndex::mutable_cities(int index) {
  return cities_.Mutable(index);
}
inline ::OsmAnd::OBF::CityIndex* OsmAndAddressIndex_CitiesIndex::add_cities() {
  return cities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::CityIndex >&
OsmAndAddressIndex_CitiesIndex::cities() const {
  return cities_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::CityIndex >*
OsmAndAddressIndex_CitiesIndex::mutable_cities() {
  return &cities_;
}

// repeated .OsmAnd.OBF.CityBlockIndex blocks = 7;
inline int OsmAndAddressIndex_CitiesIndex::blocks_size() const {
  return blocks_.size();
}
inline void OsmAndAddressIndex_CitiesIndex::clear_blocks() {
  blocks_.Clear();
}
inline const ::OsmAnd::OBF::CityBlockIndex& OsmAndAddressIndex_CitiesIndex::blocks(int index) const {
  return blocks_.Get(index);
}
inline ::OsmAnd::OBF::CityBlockIndex* OsmAndAddressIndex_CitiesIndex::mutable_blocks(int index) {
  return blocks_.Mutable(index);
}
inline ::OsmAnd::OBF::CityBlockIndex* OsmAndAddressIndex_CitiesIndex::add_blocks() {
  return blocks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::CityBlockIndex >&
OsmAndAddressIndex_CitiesIndex::blocks() const {
  return blocks_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::CityBlockIndex >*
OsmAndAddressIndex_CitiesIndex::mutable_blocks() {
  return &blocks_;
}

// -------------------------------------------------------------------

// OsmAndAddressIndex

// required string name = 1;
inline bool OsmAndAddressIndex::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsmAndAddressIndex::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsmAndAddressIndex::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsmAndAddressIndex::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& OsmAndAddressIndex::name() const {
  return *name_;
}
inline void OsmAndAddressIndex::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndAddressIndex::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndAddressIndex::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndAddressIndex::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* OsmAndAddressIndex::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OsmAndAddressIndex::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name_en = 2;
inline bool OsmAndAddressIndex::has_name_en() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OsmAndAddressIndex::set_has_name_en() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OsmAndAddressIndex::clear_has_name_en() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OsmAndAddressIndex::clear_name_en() {
  if (name_en_ != &::google::protobuf::internal::kEmptyString) {
    name_en_->clear();
  }
  clear_has_name_en();
}
inline const ::std::string& OsmAndAddressIndex::name_en() const {
  return *name_en_;
}
inline void OsmAndAddressIndex::set_name_en(const ::std::string& value) {
  set_has_name_en();
  if (name_en_ == &::google::protobuf::internal::kEmptyString) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void OsmAndAddressIndex::set_name_en(const char* value) {
  set_has_name_en();
  if (name_en_ == &::google::protobuf::internal::kEmptyString) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void OsmAndAddressIndex::set_name_en(const char* value, size_t size) {
  set_has_name_en();
  if (name_en_ == &::google::protobuf::internal::kEmptyString) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndAddressIndex::mutable_name_en() {
  set_has_name_en();
  if (name_en_ == &::google::protobuf::internal::kEmptyString) {
    name_en_ = new ::std::string;
  }
  return name_en_;
}
inline ::std::string* OsmAndAddressIndex::release_name_en() {
  clear_has_name_en();
  if (name_en_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_en_;
    name_en_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OsmAndAddressIndex::set_allocated_name_en(::std::string* name_en) {
  if (name_en_ != &::google::protobuf::internal::kEmptyString) {
    delete name_en_;
  }
  if (name_en) {
    set_has_name_en();
    name_en_ = name_en;
  } else {
    clear_has_name_en();
    name_en_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .OsmAnd.OBF.OsmAndTileBox boundaries = 3;
inline bool OsmAndAddressIndex::has_boundaries() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OsmAndAddressIndex::set_has_boundaries() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OsmAndAddressIndex::clear_has_boundaries() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OsmAndAddressIndex::clear_boundaries() {
  if (boundaries_ != NULL) boundaries_->::OsmAnd::OBF::OsmAndTileBox::Clear();
  clear_has_boundaries();
}
inline const ::OsmAnd::OBF::OsmAndTileBox& OsmAndAddressIndex::boundaries() const {
  return boundaries_ != NULL ? *boundaries_ : *default_instance_->boundaries_;
}
inline ::OsmAnd::OBF::OsmAndTileBox* OsmAndAddressIndex::mutable_boundaries() {
  set_has_boundaries();
  if (boundaries_ == NULL) boundaries_ = new ::OsmAnd::OBF::OsmAndTileBox;
  return boundaries_;
}
inline ::OsmAnd::OBF::OsmAndTileBox* OsmAndAddressIndex::release_boundaries() {
  clear_has_boundaries();
  ::OsmAnd::OBF::OsmAndTileBox* temp = boundaries_;
  boundaries_ = NULL;
  return temp;
}
inline void OsmAndAddressIndex::set_allocated_boundaries(::OsmAnd::OBF::OsmAndTileBox* boundaries) {
  delete boundaries_;
  boundaries_ = boundaries;
  if (boundaries) {
    set_has_boundaries();
  } else {
    clear_has_boundaries();
  }
}

// optional .OsmAnd.OBF.StringTable attributeTagsTable = 4;
inline bool OsmAndAddressIndex::has_attributetagstable() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OsmAndAddressIndex::set_has_attributetagstable() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OsmAndAddressIndex::clear_has_attributetagstable() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OsmAndAddressIndex::clear_attributetagstable() {
  if (attributetagstable_ != NULL) attributetagstable_->::OsmAnd::OBF::StringTable::Clear();
  clear_has_attributetagstable();
}
inline const ::OsmAnd::OBF::StringTable& OsmAndAddressIndex::attributetagstable() const {
  return attributetagstable_ != NULL ? *attributetagstable_ : *default_instance_->attributetagstable_;
}
inline ::OsmAnd::OBF::StringTable* OsmAndAddressIndex::mutable_attributetagstable() {
  set_has_attributetagstable();
  if (attributetagstable_ == NULL) attributetagstable_ = new ::OsmAnd::OBF::StringTable;
  return attributetagstable_;
}
inline ::OsmAnd::OBF::StringTable* OsmAndAddressIndex::release_attributetagstable() {
  clear_has_attributetagstable();
  ::OsmAnd::OBF::StringTable* temp = attributetagstable_;
  attributetagstable_ = NULL;
  return temp;
}
inline void OsmAndAddressIndex::set_allocated_attributetagstable(::OsmAnd::OBF::StringTable* attributetagstable) {
  delete attributetagstable_;
  attributetagstable_ = attributetagstable;
  if (attributetagstable) {
    set_has_attributetagstable();
  } else {
    clear_has_attributetagstable();
  }
}

// repeated .OsmAnd.OBF.OsmAndAddressIndex.CitiesIndex cities = 6;
inline int OsmAndAddressIndex::cities_size() const {
  return cities_.size();
}
inline void OsmAndAddressIndex::clear_cities() {
  cities_.Clear();
}
inline const ::OsmAnd::OBF::OsmAndAddressIndex_CitiesIndex& OsmAndAddressIndex::cities(int index) const {
  return cities_.Get(index);
}
inline ::OsmAnd::OBF::OsmAndAddressIndex_CitiesIndex* OsmAndAddressIndex::mutable_cities(int index) {
  return cities_.Mutable(index);
}
inline ::OsmAnd::OBF::OsmAndAddressIndex_CitiesIndex* OsmAndAddressIndex::add_cities() {
  return cities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndAddressIndex_CitiesIndex >&
OsmAndAddressIndex::cities() const {
  return cities_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndAddressIndex_CitiesIndex >*
OsmAndAddressIndex::mutable_cities() {
  return &cities_;
}

// optional .OsmAnd.OBF.OsmAndAddressNameIndexData nameIndex = 7;
inline bool OsmAndAddressIndex::has_nameindex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OsmAndAddressIndex::set_has_nameindex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OsmAndAddressIndex::clear_has_nameindex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OsmAndAddressIndex::clear_nameindex() {
  if (nameindex_ != NULL) nameindex_->::OsmAnd::OBF::OsmAndAddressNameIndexData::Clear();
  clear_has_nameindex();
}
inline const ::OsmAnd::OBF::OsmAndAddressNameIndexData& OsmAndAddressIndex::nameindex() const {
  return nameindex_ != NULL ? *nameindex_ : *default_instance_->nameindex_;
}
inline ::OsmAnd::OBF::OsmAndAddressNameIndexData* OsmAndAddressIndex::mutable_nameindex() {
  set_has_nameindex();
  if (nameindex_ == NULL) nameindex_ = new ::OsmAnd::OBF::OsmAndAddressNameIndexData;
  return nameindex_;
}
inline ::OsmAnd::OBF::OsmAndAddressNameIndexData* OsmAndAddressIndex::release_nameindex() {
  clear_has_nameindex();
  ::OsmAnd::OBF::OsmAndAddressNameIndexData* temp = nameindex_;
  nameindex_ = NULL;
  return temp;
}
inline void OsmAndAddressIndex::set_allocated_nameindex(::OsmAnd::OBF::OsmAndAddressNameIndexData* nameindex) {
  delete nameindex_;
  nameindex_ = nameindex;
  if (nameindex) {
    set_has_nameindex();
  } else {
    clear_has_nameindex();
  }
}

// -------------------------------------------------------------------

// OsmAndAddressNameIndexData_AddressNameIndexData

// repeated .OsmAnd.OBF.AddressNameIndexDataAtom atom = 4;
inline int OsmAndAddressNameIndexData_AddressNameIndexData::atom_size() const {
  return atom_.size();
}
inline void OsmAndAddressNameIndexData_AddressNameIndexData::clear_atom() {
  atom_.Clear();
}
inline const ::OsmAnd::OBF::AddressNameIndexDataAtom& OsmAndAddressNameIndexData_AddressNameIndexData::atom(int index) const {
  return atom_.Get(index);
}
inline ::OsmAnd::OBF::AddressNameIndexDataAtom* OsmAndAddressNameIndexData_AddressNameIndexData::mutable_atom(int index) {
  return atom_.Mutable(index);
}
inline ::OsmAnd::OBF::AddressNameIndexDataAtom* OsmAndAddressNameIndexData_AddressNameIndexData::add_atom() {
  return atom_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::AddressNameIndexDataAtom >&
OsmAndAddressNameIndexData_AddressNameIndexData::atom() const {
  return atom_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::AddressNameIndexDataAtom >*
OsmAndAddressNameIndexData_AddressNameIndexData::mutable_atom() {
  return &atom_;
}

// -------------------------------------------------------------------

// OsmAndAddressNameIndexData

// required .OsmAnd.OBF.IndexedStringTable table = 4;
inline bool OsmAndAddressNameIndexData::has_table() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsmAndAddressNameIndexData::set_has_table() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsmAndAddressNameIndexData::clear_has_table() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsmAndAddressNameIndexData::clear_table() {
  if (table_ != NULL) table_->::OsmAnd::OBF::IndexedStringTable::Clear();
  clear_has_table();
}
inline const ::OsmAnd::OBF::IndexedStringTable& OsmAndAddressNameIndexData::table() const {
  return table_ != NULL ? *table_ : *default_instance_->table_;
}
inline ::OsmAnd::OBF::IndexedStringTable* OsmAndAddressNameIndexData::mutable_table() {
  set_has_table();
  if (table_ == NULL) table_ = new ::OsmAnd::OBF::IndexedStringTable;
  return table_;
}
inline ::OsmAnd::OBF::IndexedStringTable* OsmAndAddressNameIndexData::release_table() {
  clear_has_table();
  ::OsmAnd::OBF::IndexedStringTable* temp = table_;
  table_ = NULL;
  return temp;
}
inline void OsmAndAddressNameIndexData::set_allocated_table(::OsmAnd::OBF::IndexedStringTable* table) {
  delete table_;
  table_ = table;
  if (table) {
    set_has_table();
  } else {
    clear_has_table();
  }
}

// repeated .OsmAnd.OBF.OsmAndAddressNameIndexData.AddressNameIndexData atom = 7;
inline int OsmAndAddressNameIndexData::atom_size() const {
  return atom_.size();
}
inline void OsmAndAddressNameIndexData::clear_atom() {
  atom_.Clear();
}
inline const ::OsmAnd::OBF::OsmAndAddressNameIndexData_AddressNameIndexData& OsmAndAddressNameIndexData::atom(int index) const {
  return atom_.Get(index);
}
inline ::OsmAnd::OBF::OsmAndAddressNameIndexData_AddressNameIndexData* OsmAndAddressNameIndexData::mutable_atom(int index) {
  return atom_.Mutable(index);
}
inline ::OsmAnd::OBF::OsmAndAddressNameIndexData_AddressNameIndexData* OsmAndAddressNameIndexData::add_atom() {
  return atom_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndAddressNameIndexData_AddressNameIndexData >&
OsmAndAddressNameIndexData::atom() const {
  return atom_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndAddressNameIndexData_AddressNameIndexData >*
OsmAndAddressNameIndexData::mutable_atom() {
  return &atom_;
}

// -------------------------------------------------------------------

// AddressNameIndexDataAtom

// optional string name = 1;
inline bool AddressNameIndexDataAtom::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddressNameIndexDataAtom::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddressNameIndexDataAtom::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddressNameIndexDataAtom::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AddressNameIndexDataAtom::name() const {
  return *name_;
}
inline void AddressNameIndexDataAtom::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AddressNameIndexDataAtom::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AddressNameIndexDataAtom::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddressNameIndexDataAtom::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AddressNameIndexDataAtom::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AddressNameIndexDataAtom::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nameEn = 2;
inline bool AddressNameIndexDataAtom::has_nameen() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddressNameIndexDataAtom::set_has_nameen() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddressNameIndexDataAtom::clear_has_nameen() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddressNameIndexDataAtom::clear_nameen() {
  if (nameen_ != &::google::protobuf::internal::kEmptyString) {
    nameen_->clear();
  }
  clear_has_nameen();
}
inline const ::std::string& AddressNameIndexDataAtom::nameen() const {
  return *nameen_;
}
inline void AddressNameIndexDataAtom::set_nameen(const ::std::string& value) {
  set_has_nameen();
  if (nameen_ == &::google::protobuf::internal::kEmptyString) {
    nameen_ = new ::std::string;
  }
  nameen_->assign(value);
}
inline void AddressNameIndexDataAtom::set_nameen(const char* value) {
  set_has_nameen();
  if (nameen_ == &::google::protobuf::internal::kEmptyString) {
    nameen_ = new ::std::string;
  }
  nameen_->assign(value);
}
inline void AddressNameIndexDataAtom::set_nameen(const char* value, size_t size) {
  set_has_nameen();
  if (nameen_ == &::google::protobuf::internal::kEmptyString) {
    nameen_ = new ::std::string;
  }
  nameen_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddressNameIndexDataAtom::mutable_nameen() {
  set_has_nameen();
  if (nameen_ == &::google::protobuf::internal::kEmptyString) {
    nameen_ = new ::std::string;
  }
  return nameen_;
}
inline ::std::string* AddressNameIndexDataAtom::release_nameen() {
  clear_has_nameen();
  if (nameen_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nameen_;
    nameen_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AddressNameIndexDataAtom::set_allocated_nameen(::std::string* nameen) {
  if (nameen_ != &::google::protobuf::internal::kEmptyString) {
    delete nameen_;
  }
  if (nameen) {
    set_has_nameen();
    nameen_ = nameen;
  } else {
    clear_has_nameen();
    nameen_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 type = 3;
inline bool AddressNameIndexDataAtom::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddressNameIndexDataAtom::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddressNameIndexDataAtom::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddressNameIndexDataAtom::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 AddressNameIndexDataAtom::type() const {
  return type_;
}
inline void AddressNameIndexDataAtom::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// repeated int32 shiftToIndex = 5;
inline int AddressNameIndexDataAtom::shifttoindex_size() const {
  return shifttoindex_.size();
}
inline void AddressNameIndexDataAtom::clear_shifttoindex() {
  shifttoindex_.Clear();
}
inline ::google::protobuf::int32 AddressNameIndexDataAtom::shifttoindex(int index) const {
  return shifttoindex_.Get(index);
}
inline void AddressNameIndexDataAtom::set_shifttoindex(int index, ::google::protobuf::int32 value) {
  shifttoindex_.Set(index, value);
}
inline void AddressNameIndexDataAtom::add_shifttoindex(::google::protobuf::int32 value) {
  shifttoindex_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
AddressNameIndexDataAtom::shifttoindex() const {
  return shifttoindex_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
AddressNameIndexDataAtom::mutable_shifttoindex() {
  return &shifttoindex_;
}

// repeated int32 shiftToCityIndex = 6;
inline int AddressNameIndexDataAtom::shifttocityindex_size() const {
  return shifttocityindex_.size();
}
inline void AddressNameIndexDataAtom::clear_shifttocityindex() {
  shifttocityindex_.Clear();
}
inline ::google::protobuf::int32 AddressNameIndexDataAtom::shifttocityindex(int index) const {
  return shifttocityindex_.Get(index);
}
inline void AddressNameIndexDataAtom::set_shifttocityindex(int index, ::google::protobuf::int32 value) {
  shifttocityindex_.Set(index, value);
}
inline void AddressNameIndexDataAtom::add_shifttocityindex(::google::protobuf::int32 value) {
  shifttocityindex_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
AddressNameIndexDataAtom::shifttocityindex() const {
  return shifttocityindex_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
AddressNameIndexDataAtom::mutable_shifttocityindex() {
  return &shifttocityindex_;
}

// repeated uint32 xy16 = 7;
inline int AddressNameIndexDataAtom::xy16_size() const {
  return xy16_.size();
}
inline void AddressNameIndexDataAtom::clear_xy16() {
  xy16_.Clear();
}
inline ::google::protobuf::uint32 AddressNameIndexDataAtom::xy16(int index) const {
  return xy16_.Get(index);
}
inline void AddressNameIndexDataAtom::set_xy16(int index, ::google::protobuf::uint32 value) {
  xy16_.Set(index, value);
}
inline void AddressNameIndexDataAtom::add_xy16(::google::protobuf::uint32 value) {
  xy16_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AddressNameIndexDataAtom::xy16() const {
  return xy16_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AddressNameIndexDataAtom::mutable_xy16() {
  return &xy16_;
}

// -------------------------------------------------------------------

// CityIndex

// optional uint32 city_type = 1;
inline bool CityIndex::has_city_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CityIndex::set_has_city_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CityIndex::clear_has_city_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CityIndex::clear_city_type() {
  city_type_ = 0u;
  clear_has_city_type();
}
inline ::google::protobuf::uint32 CityIndex::city_type() const {
  return city_type_;
}
inline void CityIndex::set_city_type(::google::protobuf::uint32 value) {
  set_has_city_type();
  city_type_ = value;
}

// required string name = 2;
inline bool CityIndex::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CityIndex::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CityIndex::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CityIndex::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CityIndex::name() const {
  return *name_;
}
inline void CityIndex::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CityIndex::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CityIndex::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CityIndex::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CityIndex::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CityIndex::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name_en = 3;
inline bool CityIndex::has_name_en() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CityIndex::set_has_name_en() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CityIndex::clear_has_name_en() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CityIndex::clear_name_en() {
  if (name_en_ != &::google::protobuf::internal::kEmptyString) {
    name_en_->clear();
  }
  clear_has_name_en();
}
inline const ::std::string& CityIndex::name_en() const {
  return *name_en_;
}
inline void CityIndex::set_name_en(const ::std::string& value) {
  set_has_name_en();
  if (name_en_ == &::google::protobuf::internal::kEmptyString) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void CityIndex::set_name_en(const char* value) {
  set_has_name_en();
  if (name_en_ == &::google::protobuf::internal::kEmptyString) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void CityIndex::set_name_en(const char* value, size_t size) {
  set_has_name_en();
  if (name_en_ == &::google::protobuf::internal::kEmptyString) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CityIndex::mutable_name_en() {
  set_has_name_en();
  if (name_en_ == &::google::protobuf::internal::kEmptyString) {
    name_en_ = new ::std::string;
  }
  return name_en_;
}
inline ::std::string* CityIndex::release_name_en() {
  clear_has_name_en();
  if (name_en_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_en_;
    name_en_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CityIndex::set_allocated_name_en(::std::string* name_en) {
  if (name_en_ != &::google::protobuf::internal::kEmptyString) {
    delete name_en_;
  }
  if (name_en) {
    set_has_name_en();
    name_en_ = name_en;
  } else {
    clear_has_name_en();
    name_en_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 id = 4;
inline bool CityIndex::has_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CityIndex::set_has_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CityIndex::clear_has_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CityIndex::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 CityIndex::id() const {
  return id_;
}
inline void CityIndex::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// required uint32 x = 5;
inline bool CityIndex::has_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CityIndex::set_has_x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CityIndex::clear_has_x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CityIndex::clear_x() {
  x_ = 0u;
  clear_has_x();
}
inline ::google::protobuf::uint32 CityIndex::x() const {
  return x_;
}
inline void CityIndex::set_x(::google::protobuf::uint32 value) {
  set_has_x();
  x_ = value;
}

// required uint32 y = 6;
inline bool CityIndex::has_y() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CityIndex::set_has_y() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CityIndex::clear_has_y() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CityIndex::clear_y() {
  y_ = 0u;
  clear_has_y();
}
inline ::google::protobuf::uint32 CityIndex::y() const {
  return y_;
}
inline void CityIndex::set_y(::google::protobuf::uint32 value) {
  set_has_y();
  y_ = value;
}

// repeated uint32 attributeTagIds = 7;
inline int CityIndex::attributetagids_size() const {
  return attributetagids_.size();
}
inline void CityIndex::clear_attributetagids() {
  attributetagids_.Clear();
}
inline ::google::protobuf::uint32 CityIndex::attributetagids(int index) const {
  return attributetagids_.Get(index);
}
inline void CityIndex::set_attributetagids(int index, ::google::protobuf::uint32 value) {
  attributetagids_.Set(index, value);
}
inline void CityIndex::add_attributetagids(::google::protobuf::uint32 value) {
  attributetagids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CityIndex::attributetagids() const {
  return attributetagids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CityIndex::mutable_attributetagids() {
  return &attributetagids_;
}

// repeated string attributeValues = 8;
inline int CityIndex::attributevalues_size() const {
  return attributevalues_.size();
}
inline void CityIndex::clear_attributevalues() {
  attributevalues_.Clear();
}
inline const ::std::string& CityIndex::attributevalues(int index) const {
  return attributevalues_.Get(index);
}
inline ::std::string* CityIndex::mutable_attributevalues(int index) {
  return attributevalues_.Mutable(index);
}
inline void CityIndex::set_attributevalues(int index, const ::std::string& value) {
  attributevalues_.Mutable(index)->assign(value);
}
inline void CityIndex::set_attributevalues(int index, const char* value) {
  attributevalues_.Mutable(index)->assign(value);
}
inline void CityIndex::set_attributevalues(int index, const char* value, size_t size) {
  attributevalues_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CityIndex::add_attributevalues() {
  return attributevalues_.Add();
}
inline void CityIndex::add_attributevalues(const ::std::string& value) {
  attributevalues_.Add()->assign(value);
}
inline void CityIndex::add_attributevalues(const char* value) {
  attributevalues_.Add()->assign(value);
}
inline void CityIndex::add_attributevalues(const char* value, size_t size) {
  attributevalues_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CityIndex::attributevalues() const {
  return attributevalues_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CityIndex::mutable_attributevalues() {
  return &attributevalues_;
}

// optional fixed32 shiftToCityBlockIndex = 10;
inline bool CityIndex::has_shifttocityblockindex() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CityIndex::set_has_shifttocityblockindex() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CityIndex::clear_has_shifttocityblockindex() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CityIndex::clear_shifttocityblockindex() {
  shifttocityblockindex_ = 0u;
  clear_has_shifttocityblockindex();
}
inline ::google::protobuf::uint32 CityIndex::shifttocityblockindex() const {
  return shifttocityblockindex_;
}
inline void CityIndex::set_shifttocityblockindex(::google::protobuf::uint32 value) {
  set_has_shifttocityblockindex();
  shifttocityblockindex_ = value;
}

// -------------------------------------------------------------------

// CityBlockIndex

// optional fixed32 shiftToCityIndex = 4;
inline bool CityBlockIndex::has_shifttocityindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CityBlockIndex::set_has_shifttocityindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CityBlockIndex::clear_has_shifttocityindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CityBlockIndex::clear_shifttocityindex() {
  shifttocityindex_ = 0u;
  clear_has_shifttocityindex();
}
inline ::google::protobuf::uint32 CityBlockIndex::shifttocityindex() const {
  return shifttocityindex_;
}
inline void CityBlockIndex::set_shifttocityindex(::google::protobuf::uint32 value) {
  set_has_shifttocityindex();
  shifttocityindex_ = value;
}

// repeated .OsmAnd.OBF.BuildingIndex buildings = 10;
inline int CityBlockIndex::buildings_size() const {
  return buildings_.size();
}
inline void CityBlockIndex::clear_buildings() {
  buildings_.Clear();
}
inline const ::OsmAnd::OBF::BuildingIndex& CityBlockIndex::buildings(int index) const {
  return buildings_.Get(index);
}
inline ::OsmAnd::OBF::BuildingIndex* CityBlockIndex::mutable_buildings(int index) {
  return buildings_.Mutable(index);
}
inline ::OsmAnd::OBF::BuildingIndex* CityBlockIndex::add_buildings() {
  return buildings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::BuildingIndex >&
CityBlockIndex::buildings() const {
  return buildings_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::BuildingIndex >*
CityBlockIndex::mutable_buildings() {
  return &buildings_;
}

// repeated .OsmAnd.OBF.StreetIndex streets = 12;
inline int CityBlockIndex::streets_size() const {
  return streets_.size();
}
inline void CityBlockIndex::clear_streets() {
  streets_.Clear();
}
inline const ::OsmAnd::OBF::StreetIndex& CityBlockIndex::streets(int index) const {
  return streets_.Get(index);
}
inline ::OsmAnd::OBF::StreetIndex* CityBlockIndex::mutable_streets(int index) {
  return streets_.Mutable(index);
}
inline ::OsmAnd::OBF::StreetIndex* CityBlockIndex::add_streets() {
  return streets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::StreetIndex >&
CityBlockIndex::streets() const {
  return streets_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::StreetIndex >*
CityBlockIndex::mutable_streets() {
  return &streets_;
}

// -------------------------------------------------------------------

// StreetIndex

// required string name = 1;
inline bool StreetIndex::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StreetIndex::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StreetIndex::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StreetIndex::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& StreetIndex::name() const {
  return *name_;
}
inline void StreetIndex::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StreetIndex::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StreetIndex::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StreetIndex::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* StreetIndex::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StreetIndex::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name_en = 2;
inline bool StreetIndex::has_name_en() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StreetIndex::set_has_name_en() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StreetIndex::clear_has_name_en() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StreetIndex::clear_name_en() {
  if (name_en_ != &::google::protobuf::internal::kEmptyString) {
    name_en_->clear();
  }
  clear_has_name_en();
}
inline const ::std::string& StreetIndex::name_en() const {
  return *name_en_;
}
inline void StreetIndex::set_name_en(const ::std::string& value) {
  set_has_name_en();
  if (name_en_ == &::google::protobuf::internal::kEmptyString) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void StreetIndex::set_name_en(const char* value) {
  set_has_name_en();
  if (name_en_ == &::google::protobuf::internal::kEmptyString) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void StreetIndex::set_name_en(const char* value, size_t size) {
  set_has_name_en();
  if (name_en_ == &::google::protobuf::internal::kEmptyString) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StreetIndex::mutable_name_en() {
  set_has_name_en();
  if (name_en_ == &::google::protobuf::internal::kEmptyString) {
    name_en_ = new ::std::string;
  }
  return name_en_;
}
inline ::std::string* StreetIndex::release_name_en() {
  clear_has_name_en();
  if (name_en_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_en_;
    name_en_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StreetIndex::set_allocated_name_en(::std::string* name_en) {
  if (name_en_ != &::google::protobuf::internal::kEmptyString) {
    delete name_en_;
  }
  if (name_en) {
    set_has_name_en();
    name_en_ = name_en;
  } else {
    clear_has_name_en();
    name_en_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required sint32 x = 3;
inline bool StreetIndex::has_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StreetIndex::set_has_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StreetIndex::clear_has_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StreetIndex::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 StreetIndex::x() const {
  return x_;
}
inline void StreetIndex::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required sint32 y = 4;
inline bool StreetIndex::has_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StreetIndex::set_has_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StreetIndex::clear_has_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StreetIndex::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 StreetIndex::y() const {
  return y_;
}
inline void StreetIndex::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// repeated .OsmAnd.OBF.StreetIntersection intersections = 5;
inline int StreetIndex::intersections_size() const {
  return intersections_.size();
}
inline void StreetIndex::clear_intersections() {
  intersections_.Clear();
}
inline const ::OsmAnd::OBF::StreetIntersection& StreetIndex::intersections(int index) const {
  return intersections_.Get(index);
}
inline ::OsmAnd::OBF::StreetIntersection* StreetIndex::mutable_intersections(int index) {
  return intersections_.Mutable(index);
}
inline ::OsmAnd::OBF::StreetIntersection* StreetIndex::add_intersections() {
  return intersections_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::StreetIntersection >&
StreetIndex::intersections() const {
  return intersections_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::StreetIntersection >*
StreetIndex::mutable_intersections() {
  return &intersections_;
}

// optional uint64 id = 6;
inline bool StreetIndex::has_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StreetIndex::set_has_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StreetIndex::clear_has_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StreetIndex::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 StreetIndex::id() const {
  return id_;
}
inline void StreetIndex::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// repeated uint32 attributeTagIds = 7;
inline int StreetIndex::attributetagids_size() const {
  return attributetagids_.size();
}
inline void StreetIndex::clear_attributetagids() {
  attributetagids_.Clear();
}
inline ::google::protobuf::uint32 StreetIndex::attributetagids(int index) const {
  return attributetagids_.Get(index);
}
inline void StreetIndex::set_attributetagids(int index, ::google::protobuf::uint32 value) {
  attributetagids_.Set(index, value);
}
inline void StreetIndex::add_attributetagids(::google::protobuf::uint32 value) {
  attributetagids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
StreetIndex::attributetagids() const {
  return attributetagids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
StreetIndex::mutable_attributetagids() {
  return &attributetagids_;
}

// repeated string attributeValues = 8;
inline int StreetIndex::attributevalues_size() const {
  return attributevalues_.size();
}
inline void StreetIndex::clear_attributevalues() {
  attributevalues_.Clear();
}
inline const ::std::string& StreetIndex::attributevalues(int index) const {
  return attributevalues_.Get(index);
}
inline ::std::string* StreetIndex::mutable_attributevalues(int index) {
  return attributevalues_.Mutable(index);
}
inline void StreetIndex::set_attributevalues(int index, const ::std::string& value) {
  attributevalues_.Mutable(index)->assign(value);
}
inline void StreetIndex::set_attributevalues(int index, const char* value) {
  attributevalues_.Mutable(index)->assign(value);
}
inline void StreetIndex::set_attributevalues(int index, const char* value, size_t size) {
  attributevalues_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StreetIndex::add_attributevalues() {
  return attributevalues_.Add();
}
inline void StreetIndex::add_attributevalues(const ::std::string& value) {
  attributevalues_.Add()->assign(value);
}
inline void StreetIndex::add_attributevalues(const char* value) {
  attributevalues_.Add()->assign(value);
}
inline void StreetIndex::add_attributevalues(const char* value, size_t size) {
  attributevalues_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StreetIndex::attributevalues() const {
  return attributevalues_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StreetIndex::mutable_attributevalues() {
  return &attributevalues_;
}

// repeated .OsmAnd.OBF.BuildingIndex buildings = 12;
inline int StreetIndex::buildings_size() const {
  return buildings_.size();
}
inline void StreetIndex::clear_buildings() {
  buildings_.Clear();
}
inline const ::OsmAnd::OBF::BuildingIndex& StreetIndex::buildings(int index) const {
  return buildings_.Get(index);
}
inline ::OsmAnd::OBF::BuildingIndex* StreetIndex::mutable_buildings(int index) {
  return buildings_.Mutable(index);
}
inline ::OsmAnd::OBF::BuildingIndex* StreetIndex::add_buildings() {
  return buildings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::BuildingIndex >&
StreetIndex::buildings() const {
  return buildings_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::BuildingIndex >*
StreetIndex::mutable_buildings() {
  return &buildings_;
}

// -------------------------------------------------------------------

// StreetIntersection

// required string name = 2;
inline bool StreetIntersection::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StreetIntersection::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StreetIntersection::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StreetIntersection::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& StreetIntersection::name() const {
  return *name_;
}
inline void StreetIntersection::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StreetIntersection::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StreetIntersection::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StreetIntersection::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* StreetIntersection::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StreetIntersection::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name_en = 3;
inline bool StreetIntersection::has_name_en() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StreetIntersection::set_has_name_en() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StreetIntersection::clear_has_name_en() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StreetIntersection::clear_name_en() {
  if (name_en_ != &::google::protobuf::internal::kEmptyString) {
    name_en_->clear();
  }
  clear_has_name_en();
}
inline const ::std::string& StreetIntersection::name_en() const {
  return *name_en_;
}
inline void StreetIntersection::set_name_en(const ::std::string& value) {
  set_has_name_en();
  if (name_en_ == &::google::protobuf::internal::kEmptyString) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void StreetIntersection::set_name_en(const char* value) {
  set_has_name_en();
  if (name_en_ == &::google::protobuf::internal::kEmptyString) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void StreetIntersection::set_name_en(const char* value, size_t size) {
  set_has_name_en();
  if (name_en_ == &::google::protobuf::internal::kEmptyString) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StreetIntersection::mutable_name_en() {
  set_has_name_en();
  if (name_en_ == &::google::protobuf::internal::kEmptyString) {
    name_en_ = new ::std::string;
  }
  return name_en_;
}
inline ::std::string* StreetIntersection::release_name_en() {
  clear_has_name_en();
  if (name_en_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_en_;
    name_en_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StreetIntersection::set_allocated_name_en(::std::string* name_en) {
  if (name_en_ != &::google::protobuf::internal::kEmptyString) {
    delete name_en_;
  }
  if (name_en) {
    set_has_name_en();
    name_en_ = name_en;
  } else {
    clear_has_name_en();
    name_en_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required sint32 intersectedX = 4;
inline bool StreetIntersection::has_intersectedx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StreetIntersection::set_has_intersectedx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StreetIntersection::clear_has_intersectedx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StreetIntersection::clear_intersectedx() {
  intersectedx_ = 0;
  clear_has_intersectedx();
}
inline ::google::protobuf::int32 StreetIntersection::intersectedx() const {
  return intersectedx_;
}
inline void StreetIntersection::set_intersectedx(::google::protobuf::int32 value) {
  set_has_intersectedx();
  intersectedx_ = value;
}

// required sint32 intersectedY = 5;
inline bool StreetIntersection::has_intersectedy() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StreetIntersection::set_has_intersectedy() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StreetIntersection::clear_has_intersectedy() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StreetIntersection::clear_intersectedy() {
  intersectedy_ = 0;
  clear_has_intersectedy();
}
inline ::google::protobuf::int32 StreetIntersection::intersectedy() const {
  return intersectedy_;
}
inline void StreetIntersection::set_intersectedy(::google::protobuf::int32 value) {
  set_has_intersectedy();
  intersectedy_ = value;
}

// repeated uint32 attributeTagIds = 7;
inline int StreetIntersection::attributetagids_size() const {
  return attributetagids_.size();
}
inline void StreetIntersection::clear_attributetagids() {
  attributetagids_.Clear();
}
inline ::google::protobuf::uint32 StreetIntersection::attributetagids(int index) const {
  return attributetagids_.Get(index);
}
inline void StreetIntersection::set_attributetagids(int index, ::google::protobuf::uint32 value) {
  attributetagids_.Set(index, value);
}
inline void StreetIntersection::add_attributetagids(::google::protobuf::uint32 value) {
  attributetagids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
StreetIntersection::attributetagids() const {
  return attributetagids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
StreetIntersection::mutable_attributetagids() {
  return &attributetagids_;
}

// repeated string attributeValues = 8;
inline int StreetIntersection::attributevalues_size() const {
  return attributevalues_.size();
}
inline void StreetIntersection::clear_attributevalues() {
  attributevalues_.Clear();
}
inline const ::std::string& StreetIntersection::attributevalues(int index) const {
  return attributevalues_.Get(index);
}
inline ::std::string* StreetIntersection::mutable_attributevalues(int index) {
  return attributevalues_.Mutable(index);
}
inline void StreetIntersection::set_attributevalues(int index, const ::std::string& value) {
  attributevalues_.Mutable(index)->assign(value);
}
inline void StreetIntersection::set_attributevalues(int index, const char* value) {
  attributevalues_.Mutable(index)->assign(value);
}
inline void StreetIntersection::set_attributevalues(int index, const char* value, size_t size) {
  attributevalues_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StreetIntersection::add_attributevalues() {
  return attributevalues_.Add();
}
inline void StreetIntersection::add_attributevalues(const ::std::string& value) {
  attributevalues_.Add()->assign(value);
}
inline void StreetIntersection::add_attributevalues(const char* value) {
  attributevalues_.Add()->assign(value);
}
inline void StreetIntersection::add_attributevalues(const char* value, size_t size) {
  attributevalues_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StreetIntersection::attributevalues() const {
  return attributevalues_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StreetIntersection::mutable_attributevalues() {
  return &attributevalues_;
}

// -------------------------------------------------------------------

// BuildingIndex

// required string name = 1;
inline bool BuildingIndex::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuildingIndex::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuildingIndex::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuildingIndex::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& BuildingIndex::name() const {
  return *name_;
}
inline void BuildingIndex::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BuildingIndex::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BuildingIndex::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuildingIndex::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* BuildingIndex::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BuildingIndex::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name_en = 2;
inline bool BuildingIndex::has_name_en() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuildingIndex::set_has_name_en() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuildingIndex::clear_has_name_en() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuildingIndex::clear_name_en() {
  if (name_en_ != &::google::protobuf::internal::kEmptyString) {
    name_en_->clear();
  }
  clear_has_name_en();
}
inline const ::std::string& BuildingIndex::name_en() const {
  return *name_en_;
}
inline void BuildingIndex::set_name_en(const ::std::string& value) {
  set_has_name_en();
  if (name_en_ == &::google::protobuf::internal::kEmptyString) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void BuildingIndex::set_name_en(const char* value) {
  set_has_name_en();
  if (name_en_ == &::google::protobuf::internal::kEmptyString) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(value);
}
inline void BuildingIndex::set_name_en(const char* value, size_t size) {
  set_has_name_en();
  if (name_en_ == &::google::protobuf::internal::kEmptyString) {
    name_en_ = new ::std::string;
  }
  name_en_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuildingIndex::mutable_name_en() {
  set_has_name_en();
  if (name_en_ == &::google::protobuf::internal::kEmptyString) {
    name_en_ = new ::std::string;
  }
  return name_en_;
}
inline ::std::string* BuildingIndex::release_name_en() {
  clear_has_name_en();
  if (name_en_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_en_;
    name_en_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BuildingIndex::set_allocated_name_en(::std::string* name_en) {
  if (name_en_ != &::google::protobuf::internal::kEmptyString) {
    delete name_en_;
  }
  if (name_en) {
    set_has_name_en();
    name_en_ = name_en;
  } else {
    clear_has_name_en();
    name_en_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name2 = 3;
inline bool BuildingIndex::has_name2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuildingIndex::set_has_name2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuildingIndex::clear_has_name2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuildingIndex::clear_name2() {
  if (name2_ != &::google::protobuf::internal::kEmptyString) {
    name2_->clear();
  }
  clear_has_name2();
}
inline const ::std::string& BuildingIndex::name2() const {
  return *name2_;
}
inline void BuildingIndex::set_name2(const ::std::string& value) {
  set_has_name2();
  if (name2_ == &::google::protobuf::internal::kEmptyString) {
    name2_ = new ::std::string;
  }
  name2_->assign(value);
}
inline void BuildingIndex::set_name2(const char* value) {
  set_has_name2();
  if (name2_ == &::google::protobuf::internal::kEmptyString) {
    name2_ = new ::std::string;
  }
  name2_->assign(value);
}
inline void BuildingIndex::set_name2(const char* value, size_t size) {
  set_has_name2();
  if (name2_ == &::google::protobuf::internal::kEmptyString) {
    name2_ = new ::std::string;
  }
  name2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuildingIndex::mutable_name2() {
  set_has_name2();
  if (name2_ == &::google::protobuf::internal::kEmptyString) {
    name2_ = new ::std::string;
  }
  return name2_;
}
inline ::std::string* BuildingIndex::release_name2() {
  clear_has_name2();
  if (name2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name2_;
    name2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BuildingIndex::set_allocated_name2(::std::string* name2) {
  if (name2_ != &::google::protobuf::internal::kEmptyString) {
    delete name2_;
  }
  if (name2) {
    set_has_name2();
    name2_ = name2;
  } else {
    clear_has_name2();
    name2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name_en2 = 4;
inline bool BuildingIndex::has_name_en2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BuildingIndex::set_has_name_en2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BuildingIndex::clear_has_name_en2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BuildingIndex::clear_name_en2() {
  if (name_en2_ != &::google::protobuf::internal::kEmptyString) {
    name_en2_->clear();
  }
  clear_has_name_en2();
}
inline const ::std::string& BuildingIndex::name_en2() const {
  return *name_en2_;
}
inline void BuildingIndex::set_name_en2(const ::std::string& value) {
  set_has_name_en2();
  if (name_en2_ == &::google::protobuf::internal::kEmptyString) {
    name_en2_ = new ::std::string;
  }
  name_en2_->assign(value);
}
inline void BuildingIndex::set_name_en2(const char* value) {
  set_has_name_en2();
  if (name_en2_ == &::google::protobuf::internal::kEmptyString) {
    name_en2_ = new ::std::string;
  }
  name_en2_->assign(value);
}
inline void BuildingIndex::set_name_en2(const char* value, size_t size) {
  set_has_name_en2();
  if (name_en2_ == &::google::protobuf::internal::kEmptyString) {
    name_en2_ = new ::std::string;
  }
  name_en2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuildingIndex::mutable_name_en2() {
  set_has_name_en2();
  if (name_en2_ == &::google::protobuf::internal::kEmptyString) {
    name_en2_ = new ::std::string;
  }
  return name_en2_;
}
inline ::std::string* BuildingIndex::release_name_en2() {
  clear_has_name_en2();
  if (name_en2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_en2_;
    name_en2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BuildingIndex::set_allocated_name_en2(::std::string* name_en2) {
  if (name_en2_ != &::google::protobuf::internal::kEmptyString) {
    delete name_en2_;
  }
  if (name_en2) {
    set_has_name_en2();
    name_en2_ = name_en2;
  } else {
    clear_has_name_en2();
    name_en2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sint32 interpolation = 5;
inline bool BuildingIndex::has_interpolation() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BuildingIndex::set_has_interpolation() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BuildingIndex::clear_has_interpolation() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BuildingIndex::clear_interpolation() {
  interpolation_ = 0;
  clear_has_interpolation();
}
inline ::google::protobuf::int32 BuildingIndex::interpolation() const {
  return interpolation_;
}
inline void BuildingIndex::set_interpolation(::google::protobuf::int32 value) {
  set_has_interpolation();
  interpolation_ = value;
}

// required sint32 x = 7;
inline bool BuildingIndex::has_x() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BuildingIndex::set_has_x() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BuildingIndex::clear_has_x() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BuildingIndex::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 BuildingIndex::x() const {
  return x_;
}
inline void BuildingIndex::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required sint32 y = 8;
inline bool BuildingIndex::has_y() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BuildingIndex::set_has_y() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BuildingIndex::clear_has_y() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BuildingIndex::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 BuildingIndex::y() const {
  return y_;
}
inline void BuildingIndex::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// optional sint32 x2 = 9;
inline bool BuildingIndex::has_x2() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BuildingIndex::set_has_x2() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BuildingIndex::clear_has_x2() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BuildingIndex::clear_x2() {
  x2_ = 0;
  clear_has_x2();
}
inline ::google::protobuf::int32 BuildingIndex::x2() const {
  return x2_;
}
inline void BuildingIndex::set_x2(::google::protobuf::int32 value) {
  set_has_x2();
  x2_ = value;
}

// optional sint32 y2 = 10;
inline bool BuildingIndex::has_y2() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BuildingIndex::set_has_y2() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BuildingIndex::clear_has_y2() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BuildingIndex::clear_y2() {
  y2_ = 0;
  clear_has_y2();
}
inline ::google::protobuf::int32 BuildingIndex::y2() const {
  return y2_;
}
inline void BuildingIndex::set_y2(::google::protobuf::int32 value) {
  set_has_y2();
  y2_ = value;
}

// optional uint64 id = 13;
inline bool BuildingIndex::has_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BuildingIndex::set_has_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BuildingIndex::clear_has_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BuildingIndex::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 BuildingIndex::id() const {
  return id_;
}
inline void BuildingIndex::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional string postcode = 14;
inline bool BuildingIndex::has_postcode() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BuildingIndex::set_has_postcode() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BuildingIndex::clear_has_postcode() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BuildingIndex::clear_postcode() {
  if (postcode_ != &::google::protobuf::internal::kEmptyString) {
    postcode_->clear();
  }
  clear_has_postcode();
}
inline const ::std::string& BuildingIndex::postcode() const {
  return *postcode_;
}
inline void BuildingIndex::set_postcode(const ::std::string& value) {
  set_has_postcode();
  if (postcode_ == &::google::protobuf::internal::kEmptyString) {
    postcode_ = new ::std::string;
  }
  postcode_->assign(value);
}
inline void BuildingIndex::set_postcode(const char* value) {
  set_has_postcode();
  if (postcode_ == &::google::protobuf::internal::kEmptyString) {
    postcode_ = new ::std::string;
  }
  postcode_->assign(value);
}
inline void BuildingIndex::set_postcode(const char* value, size_t size) {
  set_has_postcode();
  if (postcode_ == &::google::protobuf::internal::kEmptyString) {
    postcode_ = new ::std::string;
  }
  postcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuildingIndex::mutable_postcode() {
  set_has_postcode();
  if (postcode_ == &::google::protobuf::internal::kEmptyString) {
    postcode_ = new ::std::string;
  }
  return postcode_;
}
inline ::std::string* BuildingIndex::release_postcode() {
  clear_has_postcode();
  if (postcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = postcode_;
    postcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BuildingIndex::set_allocated_postcode(::std::string* postcode) {
  if (postcode_ != &::google::protobuf::internal::kEmptyString) {
    delete postcode_;
  }
  if (postcode) {
    set_has_postcode();
    postcode_ = postcode;
  } else {
    clear_has_postcode();
    postcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated uint32 attributeTagIds = 15;
inline int BuildingIndex::attributetagids_size() const {
  return attributetagids_.size();
}
inline void BuildingIndex::clear_attributetagids() {
  attributetagids_.Clear();
}
inline ::google::protobuf::uint32 BuildingIndex::attributetagids(int index) const {
  return attributetagids_.Get(index);
}
inline void BuildingIndex::set_attributetagids(int index, ::google::protobuf::uint32 value) {
  attributetagids_.Set(index, value);
}
inline void BuildingIndex::add_attributetagids(::google::protobuf::uint32 value) {
  attributetagids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
BuildingIndex::attributetagids() const {
  return attributetagids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
BuildingIndex::mutable_attributetagids() {
  return &attributetagids_;
}

// repeated string attributeValues = 16;
inline int BuildingIndex::attributevalues_size() const {
  return attributevalues_.size();
}
inline void BuildingIndex::clear_attributevalues() {
  attributevalues_.Clear();
}
inline const ::std::string& BuildingIndex::attributevalues(int index) const {
  return attributevalues_.Get(index);
}
inline ::std::string* BuildingIndex::mutable_attributevalues(int index) {
  return attributevalues_.Mutable(index);
}
inline void BuildingIndex::set_attributevalues(int index, const ::std::string& value) {
  attributevalues_.Mutable(index)->assign(value);
}
inline void BuildingIndex::set_attributevalues(int index, const char* value) {
  attributevalues_.Mutable(index)->assign(value);
}
inline void BuildingIndex::set_attributevalues(int index, const char* value, size_t size) {
  attributevalues_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuildingIndex::add_attributevalues() {
  return attributevalues_.Add();
}
inline void BuildingIndex::add_attributevalues(const ::std::string& value) {
  attributevalues_.Add()->assign(value);
}
inline void BuildingIndex::add_attributevalues(const char* value) {
  attributevalues_.Add()->assign(value);
}
inline void BuildingIndex::add_attributevalues(const char* value, size_t size) {
  attributevalues_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BuildingIndex::attributevalues() const {
  return attributevalues_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BuildingIndex::mutable_attributevalues() {
  return &attributevalues_;
}

// repeated uint32 attributeTagIds2 = 17;
inline int BuildingIndex::attributetagids2_size() const {
  return attributetagids2_.size();
}
inline void BuildingIndex::clear_attributetagids2() {
  attributetagids2_.Clear();
}
inline ::google::protobuf::uint32 BuildingIndex::attributetagids2(int index) const {
  return attributetagids2_.Get(index);
}
inline void BuildingIndex::set_attributetagids2(int index, ::google::protobuf::uint32 value) {
  attributetagids2_.Set(index, value);
}
inline void BuildingIndex::add_attributetagids2(::google::protobuf::uint32 value) {
  attributetagids2_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
BuildingIndex::attributetagids2() const {
  return attributetagids2_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
BuildingIndex::mutable_attributetagids2() {
  return &attributetagids2_;
}

// repeated string attributeValues2 = 18;
inline int BuildingIndex::attributevalues2_size() const {
  return attributevalues2_.size();
}
inline void BuildingIndex::clear_attributevalues2() {
  attributevalues2_.Clear();
}
inline const ::std::string& BuildingIndex::attributevalues2(int index) const {
  return attributevalues2_.Get(index);
}
inline ::std::string* BuildingIndex::mutable_attributevalues2(int index) {
  return attributevalues2_.Mutable(index);
}
inline void BuildingIndex::set_attributevalues2(int index, const ::std::string& value) {
  attributevalues2_.Mutable(index)->assign(value);
}
inline void BuildingIndex::set_attributevalues2(int index, const char* value) {
  attributevalues2_.Mutable(index)->assign(value);
}
inline void BuildingIndex::set_attributevalues2(int index, const char* value, size_t size) {
  attributevalues2_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuildingIndex::add_attributevalues2() {
  return attributevalues2_.Add();
}
inline void BuildingIndex::add_attributevalues2(const ::std::string& value) {
  attributevalues2_.Add()->assign(value);
}
inline void BuildingIndex::add_attributevalues2(const char* value) {
  attributevalues2_.Add()->assign(value);
}
inline void BuildingIndex::add_attributevalues2(const char* value, size_t size) {
  attributevalues2_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BuildingIndex::attributevalues2() const {
  return attributevalues2_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BuildingIndex::mutable_attributevalues2() {
  return &attributevalues2_;
}

// -------------------------------------------------------------------

// TransportRoutes

// repeated .OsmAnd.OBF.TransportRoute routes = 6;
inline int TransportRoutes::routes_size() const {
  return routes_.size();
}
inline void TransportRoutes::clear_routes() {
  routes_.Clear();
}
inline const ::OsmAnd::OBF::TransportRoute& TransportRoutes::routes(int index) const {
  return routes_.Get(index);
}
inline ::OsmAnd::OBF::TransportRoute* TransportRoutes::mutable_routes(int index) {
  return routes_.Mutable(index);
}
inline ::OsmAnd::OBF::TransportRoute* TransportRoutes::add_routes() {
  return routes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportRoute >&
TransportRoutes::routes() const {
  return routes_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportRoute >*
TransportRoutes::mutable_routes() {
  return &routes_;
}

// -------------------------------------------------------------------

// TransportRoute

// required uint64 id = 1;
inline bool TransportRoute::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransportRoute::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransportRoute::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransportRoute::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 TransportRoute::id() const {
  return id_;
}
inline void TransportRoute::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 type = 3;
inline bool TransportRoute::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransportRoute::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransportRoute::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransportRoute::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 TransportRoute::type() const {
  return type_;
}
inline void TransportRoute::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 operator = 4;
inline bool TransportRoute::has_operator_() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransportRoute::set_has_operator_() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransportRoute::clear_has_operator_() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransportRoute::clear_operator_() {
  operator__ = 0u;
  clear_has_operator_();
}
inline ::google::protobuf::uint32 TransportRoute::operator_() const {
  return operator__;
}
inline void TransportRoute::set_operator_(::google::protobuf::uint32 value) {
  set_has_operator_();
  operator__ = value;
}

// optional string ref = 5;
inline bool TransportRoute::has_ref() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransportRoute::set_has_ref() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransportRoute::clear_has_ref() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransportRoute::clear_ref() {
  if (ref_ != &::google::protobuf::internal::kEmptyString) {
    ref_->clear();
  }
  clear_has_ref();
}
inline const ::std::string& TransportRoute::ref() const {
  return *ref_;
}
inline void TransportRoute::set_ref(const ::std::string& value) {
  set_has_ref();
  if (ref_ == &::google::protobuf::internal::kEmptyString) {
    ref_ = new ::std::string;
  }
  ref_->assign(value);
}
inline void TransportRoute::set_ref(const char* value) {
  set_has_ref();
  if (ref_ == &::google::protobuf::internal::kEmptyString) {
    ref_ = new ::std::string;
  }
  ref_->assign(value);
}
inline void TransportRoute::set_ref(const char* value, size_t size) {
  set_has_ref();
  if (ref_ == &::google::protobuf::internal::kEmptyString) {
    ref_ = new ::std::string;
  }
  ref_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransportRoute::mutable_ref() {
  set_has_ref();
  if (ref_ == &::google::protobuf::internal::kEmptyString) {
    ref_ = new ::std::string;
  }
  return ref_;
}
inline ::std::string* TransportRoute::release_ref() {
  clear_has_ref();
  if (ref_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ref_;
    ref_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransportRoute::set_allocated_ref(::std::string* ref) {
  if (ref_ != &::google::protobuf::internal::kEmptyString) {
    delete ref_;
  }
  if (ref) {
    set_has_ref();
    ref_ = ref;
  } else {
    clear_has_ref();
    ref_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 name = 6;
inline bool TransportRoute::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TransportRoute::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TransportRoute::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TransportRoute::clear_name() {
  name_ = 0u;
  clear_has_name();
}
inline ::google::protobuf::uint32 TransportRoute::name() const {
  return name_;
}
inline void TransportRoute::set_name(::google::protobuf::uint32 value) {
  set_has_name();
  name_ = value;
}

// optional uint32 name_en = 7;
inline bool TransportRoute::has_name_en() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TransportRoute::set_has_name_en() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TransportRoute::clear_has_name_en() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TransportRoute::clear_name_en() {
  name_en_ = 0u;
  clear_has_name_en();
}
inline ::google::protobuf::uint32 TransportRoute::name_en() const {
  return name_en_;
}
inline void TransportRoute::set_name_en(::google::protobuf::uint32 value) {
  set_has_name_en();
  name_en_ = value;
}

// optional uint32 distance = 8;
inline bool TransportRoute::has_distance() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TransportRoute::set_has_distance() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TransportRoute::clear_has_distance() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TransportRoute::clear_distance() {
  distance_ = 0u;
  clear_has_distance();
}
inline ::google::protobuf::uint32 TransportRoute::distance() const {
  return distance_;
}
inline void TransportRoute::set_distance(::google::protobuf::uint32 value) {
  set_has_distance();
  distance_ = value;
}

// optional uint32 color = 9;
inline bool TransportRoute::has_color() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TransportRoute::set_has_color() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TransportRoute::clear_has_color() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TransportRoute::clear_color() {
  color_ = 0u;
  clear_has_color();
}
inline ::google::protobuf::uint32 TransportRoute::color() const {
  return color_;
}
inline void TransportRoute::set_color(::google::protobuf::uint32 value) {
  set_has_color();
  color_ = value;
}

// repeated .OsmAnd.OBF.TransportRouteStop directStops = 15;
inline int TransportRoute::directstops_size() const {
  return directstops_.size();
}
inline void TransportRoute::clear_directstops() {
  directstops_.Clear();
}
inline const ::OsmAnd::OBF::TransportRouteStop& TransportRoute::directstops(int index) const {
  return directstops_.Get(index);
}
inline ::OsmAnd::OBF::TransportRouteStop* TransportRoute::mutable_directstops(int index) {
  return directstops_.Mutable(index);
}
inline ::OsmAnd::OBF::TransportRouteStop* TransportRoute::add_directstops() {
  return directstops_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportRouteStop >&
TransportRoute::directstops() const {
  return directstops_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportRouteStop >*
TransportRoute::mutable_directstops() {
  return &directstops_;
}

// repeated .OsmAnd.OBF.TransportRouteStop reverseStops = 16;
inline int TransportRoute::reversestops_size() const {
  return reversestops_.size();
}
inline void TransportRoute::clear_reversestops() {
  reversestops_.Clear();
}
inline const ::OsmAnd::OBF::TransportRouteStop& TransportRoute::reversestops(int index) const {
  return reversestops_.Get(index);
}
inline ::OsmAnd::OBF::TransportRouteStop* TransportRoute::mutable_reversestops(int index) {
  return reversestops_.Mutable(index);
}
inline ::OsmAnd::OBF::TransportRouteStop* TransportRoute::add_reversestops() {
  return reversestops_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportRouteStop >&
TransportRoute::reversestops() const {
  return reversestops_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportRouteStop >*
TransportRoute::mutable_reversestops() {
  return &reversestops_;
}

// optional bytes geometry = 17;
inline bool TransportRoute::has_geometry() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TransportRoute::set_has_geometry() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TransportRoute::clear_has_geometry() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TransportRoute::clear_geometry() {
  if (geometry_ != &::google::protobuf::internal::kEmptyString) {
    geometry_->clear();
  }
  clear_has_geometry();
}
inline const ::std::string& TransportRoute::geometry() const {
  return *geometry_;
}
inline void TransportRoute::set_geometry(const ::std::string& value) {
  set_has_geometry();
  if (geometry_ == &::google::protobuf::internal::kEmptyString) {
    geometry_ = new ::std::string;
  }
  geometry_->assign(value);
}
inline void TransportRoute::set_geometry(const char* value) {
  set_has_geometry();
  if (geometry_ == &::google::protobuf::internal::kEmptyString) {
    geometry_ = new ::std::string;
  }
  geometry_->assign(value);
}
inline void TransportRoute::set_geometry(const void* value, size_t size) {
  set_has_geometry();
  if (geometry_ == &::google::protobuf::internal::kEmptyString) {
    geometry_ = new ::std::string;
  }
  geometry_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransportRoute::mutable_geometry() {
  set_has_geometry();
  if (geometry_ == &::google::protobuf::internal::kEmptyString) {
    geometry_ = new ::std::string;
  }
  return geometry_;
}
inline ::std::string* TransportRoute::release_geometry() {
  clear_has_geometry();
  if (geometry_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = geometry_;
    geometry_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransportRoute::set_allocated_geometry(::std::string* geometry) {
  if (geometry_ != &::google::protobuf::internal::kEmptyString) {
    delete geometry_;
  }
  if (geometry) {
    set_has_geometry();
    geometry_ = geometry;
  } else {
    clear_has_geometry();
    geometry_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .OsmAnd.OBF.TransportRouteSchedule scheduleTrip = 18;
inline int TransportRoute::scheduletrip_size() const {
  return scheduletrip_.size();
}
inline void TransportRoute::clear_scheduletrip() {
  scheduletrip_.Clear();
}
inline const ::OsmAnd::OBF::TransportRouteSchedule& TransportRoute::scheduletrip(int index) const {
  return scheduletrip_.Get(index);
}
inline ::OsmAnd::OBF::TransportRouteSchedule* TransportRoute::mutable_scheduletrip(int index) {
  return scheduletrip_.Mutable(index);
}
inline ::OsmAnd::OBF::TransportRouteSchedule* TransportRoute::add_scheduletrip() {
  return scheduletrip_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportRouteSchedule >&
TransportRoute::scheduletrip() const {
  return scheduletrip_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportRouteSchedule >*
TransportRoute::mutable_scheduletrip() {
  return &scheduletrip_;
}

// repeated uint32 attributeTagIds = 19;
inline int TransportRoute::attributetagids_size() const {
  return attributetagids_.size();
}
inline void TransportRoute::clear_attributetagids() {
  attributetagids_.Clear();
}
inline ::google::protobuf::uint32 TransportRoute::attributetagids(int index) const {
  return attributetagids_.Get(index);
}
inline void TransportRoute::set_attributetagids(int index, ::google::protobuf::uint32 value) {
  attributetagids_.Set(index, value);
}
inline void TransportRoute::add_attributetagids(::google::protobuf::uint32 value) {
  attributetagids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TransportRoute::attributetagids() const {
  return attributetagids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TransportRoute::mutable_attributetagids() {
  return &attributetagids_;
}

// repeated bytes attributeTextTagValues = 20;
inline int TransportRoute::attributetexttagvalues_size() const {
  return attributetexttagvalues_.size();
}
inline void TransportRoute::clear_attributetexttagvalues() {
  attributetexttagvalues_.Clear();
}
inline const ::std::string& TransportRoute::attributetexttagvalues(int index) const {
  return attributetexttagvalues_.Get(index);
}
inline ::std::string* TransportRoute::mutable_attributetexttagvalues(int index) {
  return attributetexttagvalues_.Mutable(index);
}
inline void TransportRoute::set_attributetexttagvalues(int index, const ::std::string& value) {
  attributetexttagvalues_.Mutable(index)->assign(value);
}
inline void TransportRoute::set_attributetexttagvalues(int index, const char* value) {
  attributetexttagvalues_.Mutable(index)->assign(value);
}
inline void TransportRoute::set_attributetexttagvalues(int index, const void* value, size_t size) {
  attributetexttagvalues_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransportRoute::add_attributetexttagvalues() {
  return attributetexttagvalues_.Add();
}
inline void TransportRoute::add_attributetexttagvalues(const ::std::string& value) {
  attributetexttagvalues_.Add()->assign(value);
}
inline void TransportRoute::add_attributetexttagvalues(const char* value) {
  attributetexttagvalues_.Add()->assign(value);
}
inline void TransportRoute::add_attributetexttagvalues(const void* value, size_t size) {
  attributetexttagvalues_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TransportRoute::attributetexttagvalues() const {
  return attributetexttagvalues_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TransportRoute::mutable_attributetexttagvalues() {
  return &attributetexttagvalues_;
}

// -------------------------------------------------------------------

// IncompleteTransportRoutes

// repeated .OsmAnd.OBF.IncompleteTransportRoute routes = 6;
inline int IncompleteTransportRoutes::routes_size() const {
  return routes_.size();
}
inline void IncompleteTransportRoutes::clear_routes() {
  routes_.Clear();
}
inline const ::OsmAnd::OBF::IncompleteTransportRoute& IncompleteTransportRoutes::routes(int index) const {
  return routes_.Get(index);
}
inline ::OsmAnd::OBF::IncompleteTransportRoute* IncompleteTransportRoutes::mutable_routes(int index) {
  return routes_.Mutable(index);
}
inline ::OsmAnd::OBF::IncompleteTransportRoute* IncompleteTransportRoutes::add_routes() {
  return routes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::IncompleteTransportRoute >&
IncompleteTransportRoutes::routes() const {
  return routes_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::IncompleteTransportRoute >*
IncompleteTransportRoutes::mutable_routes() {
  return &routes_;
}

// -------------------------------------------------------------------

// IncompleteTransportRoute

// required uint64 id = 1;
inline bool IncompleteTransportRoute::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IncompleteTransportRoute::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IncompleteTransportRoute::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IncompleteTransportRoute::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 IncompleteTransportRoute::id() const {
  return id_;
}
inline void IncompleteTransportRoute::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 type = 3;
inline bool IncompleteTransportRoute::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IncompleteTransportRoute::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IncompleteTransportRoute::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IncompleteTransportRoute::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 IncompleteTransportRoute::type() const {
  return type_;
}
inline void IncompleteTransportRoute::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 operator = 4;
inline bool IncompleteTransportRoute::has_operator_() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IncompleteTransportRoute::set_has_operator_() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IncompleteTransportRoute::clear_has_operator_() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IncompleteTransportRoute::clear_operator_() {
  operator__ = 0u;
  clear_has_operator_();
}
inline ::google::protobuf::uint32 IncompleteTransportRoute::operator_() const {
  return operator__;
}
inline void IncompleteTransportRoute::set_operator_(::google::protobuf::uint32 value) {
  set_has_operator_();
  operator__ = value;
}

// optional uint32 ref = 5;
inline bool IncompleteTransportRoute::has_ref() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IncompleteTransportRoute::set_has_ref() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IncompleteTransportRoute::clear_has_ref() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IncompleteTransportRoute::clear_ref() {
  ref_ = 0u;
  clear_has_ref();
}
inline ::google::protobuf::uint32 IncompleteTransportRoute::ref() const {
  return ref_;
}
inline void IncompleteTransportRoute::set_ref(::google::protobuf::uint32 value) {
  set_has_ref();
  ref_ = value;
}

// required uint32 routeRef = 7;
inline bool IncompleteTransportRoute::has_routeref() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IncompleteTransportRoute::set_has_routeref() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IncompleteTransportRoute::clear_has_routeref() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IncompleteTransportRoute::clear_routeref() {
  routeref_ = 0u;
  clear_has_routeref();
}
inline ::google::protobuf::uint32 IncompleteTransportRoute::routeref() const {
  return routeref_;
}
inline void IncompleteTransportRoute::set_routeref(::google::protobuf::uint32 value) {
  set_has_routeref();
  routeref_ = value;
}

// repeated uint32 missingStops = 8;
inline int IncompleteTransportRoute::missingstops_size() const {
  return missingstops_.size();
}
inline void IncompleteTransportRoute::clear_missingstops() {
  missingstops_.Clear();
}
inline ::google::protobuf::uint32 IncompleteTransportRoute::missingstops(int index) const {
  return missingstops_.Get(index);
}
inline void IncompleteTransportRoute::set_missingstops(int index, ::google::protobuf::uint32 value) {
  missingstops_.Set(index, value);
}
inline void IncompleteTransportRoute::add_missingstops(::google::protobuf::uint32 value) {
  missingstops_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
IncompleteTransportRoute::missingstops() const {
  return missingstops_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
IncompleteTransportRoute::mutable_missingstops() {
  return &missingstops_;
}

// -------------------------------------------------------------------

// TransportRouteSchedule

// optional bytes avgStopIntervals = 1;
inline bool TransportRouteSchedule::has_avgstopintervals() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransportRouteSchedule::set_has_avgstopintervals() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransportRouteSchedule::clear_has_avgstopintervals() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransportRouteSchedule::clear_avgstopintervals() {
  if (avgstopintervals_ != &::google::protobuf::internal::kEmptyString) {
    avgstopintervals_->clear();
  }
  clear_has_avgstopintervals();
}
inline const ::std::string& TransportRouteSchedule::avgstopintervals() const {
  return *avgstopintervals_;
}
inline void TransportRouteSchedule::set_avgstopintervals(const ::std::string& value) {
  set_has_avgstopintervals();
  if (avgstopintervals_ == &::google::protobuf::internal::kEmptyString) {
    avgstopintervals_ = new ::std::string;
  }
  avgstopintervals_->assign(value);
}
inline void TransportRouteSchedule::set_avgstopintervals(const char* value) {
  set_has_avgstopintervals();
  if (avgstopintervals_ == &::google::protobuf::internal::kEmptyString) {
    avgstopintervals_ = new ::std::string;
  }
  avgstopintervals_->assign(value);
}
inline void TransportRouteSchedule::set_avgstopintervals(const void* value, size_t size) {
  set_has_avgstopintervals();
  if (avgstopintervals_ == &::google::protobuf::internal::kEmptyString) {
    avgstopintervals_ = new ::std::string;
  }
  avgstopintervals_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransportRouteSchedule::mutable_avgstopintervals() {
  set_has_avgstopintervals();
  if (avgstopintervals_ == &::google::protobuf::internal::kEmptyString) {
    avgstopintervals_ = new ::std::string;
  }
  return avgstopintervals_;
}
inline ::std::string* TransportRouteSchedule::release_avgstopintervals() {
  clear_has_avgstopintervals();
  if (avgstopintervals_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avgstopintervals_;
    avgstopintervals_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransportRouteSchedule::set_allocated_avgstopintervals(::std::string* avgstopintervals) {
  if (avgstopintervals_ != &::google::protobuf::internal::kEmptyString) {
    delete avgstopintervals_;
  }
  if (avgstopintervals) {
    set_has_avgstopintervals();
    avgstopintervals_ = avgstopintervals;
  } else {
    clear_has_avgstopintervals();
    avgstopintervals_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes avgWaitIntervals = 2;
inline bool TransportRouteSchedule::has_avgwaitintervals() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransportRouteSchedule::set_has_avgwaitintervals() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransportRouteSchedule::clear_has_avgwaitintervals() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransportRouteSchedule::clear_avgwaitintervals() {
  if (avgwaitintervals_ != &::google::protobuf::internal::kEmptyString) {
    avgwaitintervals_->clear();
  }
  clear_has_avgwaitintervals();
}
inline const ::std::string& TransportRouteSchedule::avgwaitintervals() const {
  return *avgwaitintervals_;
}
inline void TransportRouteSchedule::set_avgwaitintervals(const ::std::string& value) {
  set_has_avgwaitintervals();
  if (avgwaitintervals_ == &::google::protobuf::internal::kEmptyString) {
    avgwaitintervals_ = new ::std::string;
  }
  avgwaitintervals_->assign(value);
}
inline void TransportRouteSchedule::set_avgwaitintervals(const char* value) {
  set_has_avgwaitintervals();
  if (avgwaitintervals_ == &::google::protobuf::internal::kEmptyString) {
    avgwaitintervals_ = new ::std::string;
  }
  avgwaitintervals_->assign(value);
}
inline void TransportRouteSchedule::set_avgwaitintervals(const void* value, size_t size) {
  set_has_avgwaitintervals();
  if (avgwaitintervals_ == &::google::protobuf::internal::kEmptyString) {
    avgwaitintervals_ = new ::std::string;
  }
  avgwaitintervals_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransportRouteSchedule::mutable_avgwaitintervals() {
  set_has_avgwaitintervals();
  if (avgwaitintervals_ == &::google::protobuf::internal::kEmptyString) {
    avgwaitintervals_ = new ::std::string;
  }
  return avgwaitintervals_;
}
inline ::std::string* TransportRouteSchedule::release_avgwaitintervals() {
  clear_has_avgwaitintervals();
  if (avgwaitintervals_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avgwaitintervals_;
    avgwaitintervals_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransportRouteSchedule::set_allocated_avgwaitintervals(::std::string* avgwaitintervals) {
  if (avgwaitintervals_ != &::google::protobuf::internal::kEmptyString) {
    delete avgwaitintervals_;
  }
  if (avgwaitintervals) {
    set_has_avgwaitintervals();
    avgwaitintervals_ = avgwaitintervals;
  } else {
    clear_has_avgwaitintervals();
    avgwaitintervals_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes tripIntervals = 3;
inline bool TransportRouteSchedule::has_tripintervals() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransportRouteSchedule::set_has_tripintervals() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransportRouteSchedule::clear_has_tripintervals() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransportRouteSchedule::clear_tripintervals() {
  if (tripintervals_ != &::google::protobuf::internal::kEmptyString) {
    tripintervals_->clear();
  }
  clear_has_tripintervals();
}
inline const ::std::string& TransportRouteSchedule::tripintervals() const {
  return *tripintervals_;
}
inline void TransportRouteSchedule::set_tripintervals(const ::std::string& value) {
  set_has_tripintervals();
  if (tripintervals_ == &::google::protobuf::internal::kEmptyString) {
    tripintervals_ = new ::std::string;
  }
  tripintervals_->assign(value);
}
inline void TransportRouteSchedule::set_tripintervals(const char* value) {
  set_has_tripintervals();
  if (tripintervals_ == &::google::protobuf::internal::kEmptyString) {
    tripintervals_ = new ::std::string;
  }
  tripintervals_->assign(value);
}
inline void TransportRouteSchedule::set_tripintervals(const void* value, size_t size) {
  set_has_tripintervals();
  if (tripintervals_ == &::google::protobuf::internal::kEmptyString) {
    tripintervals_ = new ::std::string;
  }
  tripintervals_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransportRouteSchedule::mutable_tripintervals() {
  set_has_tripintervals();
  if (tripintervals_ == &::google::protobuf::internal::kEmptyString) {
    tripintervals_ = new ::std::string;
  }
  return tripintervals_;
}
inline ::std::string* TransportRouteSchedule::release_tripintervals() {
  clear_has_tripintervals();
  if (tripintervals_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tripintervals_;
    tripintervals_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransportRouteSchedule::set_allocated_tripintervals(::std::string* tripintervals) {
  if (tripintervals_ != &::google::protobuf::internal::kEmptyString) {
    delete tripintervals_;
  }
  if (tripintervals) {
    set_has_tripintervals();
    tripintervals_ = tripintervals;
  } else {
    clear_has_tripintervals();
    tripintervals_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .OsmAnd.OBF.TransportRouteScheduleException exceptions = 8;
inline int TransportRouteSchedule::exceptions_size() const {
  return exceptions_.size();
}
inline void TransportRouteSchedule::clear_exceptions() {
  exceptions_.Clear();
}
inline const ::OsmAnd::OBF::TransportRouteScheduleException& TransportRouteSchedule::exceptions(int index) const {
  return exceptions_.Get(index);
}
inline ::OsmAnd::OBF::TransportRouteScheduleException* TransportRouteSchedule::mutable_exceptions(int index) {
  return exceptions_.Mutable(index);
}
inline ::OsmAnd::OBF::TransportRouteScheduleException* TransportRouteSchedule::add_exceptions() {
  return exceptions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportRouteScheduleException >&
TransportRouteSchedule::exceptions() const {
  return exceptions_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportRouteScheduleException >*
TransportRouteSchedule::mutable_exceptions() {
  return &exceptions_;
}

// -------------------------------------------------------------------

// TransportRouteScheduleException

// repeated uint32 tripIndexes = 1;
inline int TransportRouteScheduleException::tripindexes_size() const {
  return tripindexes_.size();
}
inline void TransportRouteScheduleException::clear_tripindexes() {
  tripindexes_.Clear();
}
inline ::google::protobuf::uint32 TransportRouteScheduleException::tripindexes(int index) const {
  return tripindexes_.Get(index);
}
inline void TransportRouteScheduleException::set_tripindexes(int index, ::google::protobuf::uint32 value) {
  tripindexes_.Set(index, value);
}
inline void TransportRouteScheduleException::add_tripindexes(::google::protobuf::uint32 value) {
  tripindexes_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TransportRouteScheduleException::tripindexes() const {
  return tripindexes_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TransportRouteScheduleException::mutable_tripindexes() {
  return &tripindexes_;
}

// repeated uint32 stopIndexes = 2;
inline int TransportRouteScheduleException::stopindexes_size() const {
  return stopindexes_.size();
}
inline void TransportRouteScheduleException::clear_stopindexes() {
  stopindexes_.Clear();
}
inline ::google::protobuf::uint32 TransportRouteScheduleException::stopindexes(int index) const {
  return stopindexes_.Get(index);
}
inline void TransportRouteScheduleException::set_stopindexes(int index, ::google::protobuf::uint32 value) {
  stopindexes_.Set(index, value);
}
inline void TransportRouteScheduleException::add_stopindexes(::google::protobuf::uint32 value) {
  stopindexes_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TransportRouteScheduleException::stopindexes() const {
  return stopindexes_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TransportRouteScheduleException::mutable_stopindexes() {
  return &stopindexes_;
}

// optional bool available = 3;
inline bool TransportRouteScheduleException::has_available() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransportRouteScheduleException::set_has_available() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransportRouteScheduleException::clear_has_available() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransportRouteScheduleException::clear_available() {
  available_ = false;
  clear_has_available();
}
inline bool TransportRouteScheduleException::available() const {
  return available_;
}
inline void TransportRouteScheduleException::set_available(bool value) {
  set_has_available();
  available_ = value;
}

// repeated uint32 delayArrival = 5;
inline int TransportRouteScheduleException::delayarrival_size() const {
  return delayarrival_.size();
}
inline void TransportRouteScheduleException::clear_delayarrival() {
  delayarrival_.Clear();
}
inline ::google::protobuf::uint32 TransportRouteScheduleException::delayarrival(int index) const {
  return delayarrival_.Get(index);
}
inline void TransportRouteScheduleException::set_delayarrival(int index, ::google::protobuf::uint32 value) {
  delayarrival_.Set(index, value);
}
inline void TransportRouteScheduleException::add_delayarrival(::google::protobuf::uint32 value) {
  delayarrival_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TransportRouteScheduleException::delayarrival() const {
  return delayarrival_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TransportRouteScheduleException::mutable_delayarrival() {
  return &delayarrival_;
}

// repeated int32 deltaWaitInterval = 6;
inline int TransportRouteScheduleException::deltawaitinterval_size() const {
  return deltawaitinterval_.size();
}
inline void TransportRouteScheduleException::clear_deltawaitinterval() {
  deltawaitinterval_.Clear();
}
inline ::google::protobuf::int32 TransportRouteScheduleException::deltawaitinterval(int index) const {
  return deltawaitinterval_.Get(index);
}
inline void TransportRouteScheduleException::set_deltawaitinterval(int index, ::google::protobuf::int32 value) {
  deltawaitinterval_.Set(index, value);
}
inline void TransportRouteScheduleException::add_deltawaitinterval(::google::protobuf::int32 value) {
  deltawaitinterval_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TransportRouteScheduleException::deltawaitinterval() const {
  return deltawaitinterval_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TransportRouteScheduleException::mutable_deltawaitinterval() {
  return &deltawaitinterval_;
}

// repeated uint32 dayOfWeekRestriction = 7;
inline int TransportRouteScheduleException::dayofweekrestriction_size() const {
  return dayofweekrestriction_.size();
}
inline void TransportRouteScheduleException::clear_dayofweekrestriction() {
  dayofweekrestriction_.Clear();
}
inline ::google::protobuf::uint32 TransportRouteScheduleException::dayofweekrestriction(int index) const {
  return dayofweekrestriction_.Get(index);
}
inline void TransportRouteScheduleException::set_dayofweekrestriction(int index, ::google::protobuf::uint32 value) {
  dayofweekrestriction_.Set(index, value);
}
inline void TransportRouteScheduleException::add_dayofweekrestriction(::google::protobuf::uint32 value) {
  dayofweekrestriction_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TransportRouteScheduleException::dayofweekrestriction() const {
  return dayofweekrestriction_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TransportRouteScheduleException::mutable_dayofweekrestriction() {
  return &dayofweekrestriction_;
}

// repeated uint32 dayOfYearRestriction = 8;
inline int TransportRouteScheduleException::dayofyearrestriction_size() const {
  return dayofyearrestriction_.size();
}
inline void TransportRouteScheduleException::clear_dayofyearrestriction() {
  dayofyearrestriction_.Clear();
}
inline ::google::protobuf::uint32 TransportRouteScheduleException::dayofyearrestriction(int index) const {
  return dayofyearrestriction_.Get(index);
}
inline void TransportRouteScheduleException::set_dayofyearrestriction(int index, ::google::protobuf::uint32 value) {
  dayofyearrestriction_.Set(index, value);
}
inline void TransportRouteScheduleException::add_dayofyearrestriction(::google::protobuf::uint32 value) {
  dayofyearrestriction_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TransportRouteScheduleException::dayofyearrestriction() const {
  return dayofyearrestriction_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TransportRouteScheduleException::mutable_dayofyearrestriction() {
  return &dayofyearrestriction_;
}

// -------------------------------------------------------------------

// TransportRouteStop

// required sint64 id = 1;
inline bool TransportRouteStop::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransportRouteStop::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransportRouteStop::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransportRouteStop::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 TransportRouteStop::id() const {
  return id_;
}
inline void TransportRouteStop::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// required sint32 dx = 2;
inline bool TransportRouteStop::has_dx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransportRouteStop::set_has_dx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransportRouteStop::clear_has_dx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransportRouteStop::clear_dx() {
  dx_ = 0;
  clear_has_dx();
}
inline ::google::protobuf::int32 TransportRouteStop::dx() const {
  return dx_;
}
inline void TransportRouteStop::set_dx(::google::protobuf::int32 value) {
  set_has_dx();
  dx_ = value;
}

// required sint32 dy = 3;
inline bool TransportRouteStop::has_dy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransportRouteStop::set_has_dy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransportRouteStop::clear_has_dy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransportRouteStop::clear_dy() {
  dy_ = 0;
  clear_has_dy();
}
inline ::google::protobuf::int32 TransportRouteStop::dy() const {
  return dy_;
}
inline void TransportRouteStop::set_dy(::google::protobuf::int32 value) {
  set_has_dy();
  dy_ = value;
}

// required uint32 name = 6;
inline bool TransportRouteStop::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransportRouteStop::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransportRouteStop::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransportRouteStop::clear_name() {
  name_ = 0u;
  clear_has_name();
}
inline ::google::protobuf::uint32 TransportRouteStop::name() const {
  return name_;
}
inline void TransportRouteStop::set_name(::google::protobuf::uint32 value) {
  set_has_name();
  name_ = value;
}

// optional uint32 name_en = 7;
inline bool TransportRouteStop::has_name_en() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TransportRouteStop::set_has_name_en() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TransportRouteStop::clear_has_name_en() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TransportRouteStop::clear_name_en() {
  name_en_ = 0u;
  clear_has_name_en();
}
inline ::google::protobuf::uint32 TransportRouteStop::name_en() const {
  return name_en_;
}
inline void TransportRouteStop::set_name_en(::google::protobuf::uint32 value) {
  set_has_name_en();
  name_en_ = value;
}

// -------------------------------------------------------------------

// TransportStop

// required sint32 dx = 1;
inline bool TransportStop::has_dx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransportStop::set_has_dx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransportStop::clear_has_dx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransportStop::clear_dx() {
  dx_ = 0;
  clear_has_dx();
}
inline ::google::protobuf::int32 TransportStop::dx() const {
  return dx_;
}
inline void TransportStop::set_dx(::google::protobuf::int32 value) {
  set_has_dx();
  dx_ = value;
}

// required sint32 dy = 2;
inline bool TransportStop::has_dy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransportStop::set_has_dy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransportStop::clear_has_dy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransportStop::clear_dy() {
  dy_ = 0;
  clear_has_dy();
}
inline ::google::protobuf::int32 TransportStop::dy() const {
  return dy_;
}
inline void TransportStop::set_dy(::google::protobuf::int32 value) {
  set_has_dy();
  dy_ = value;
}

// required sint64 id = 5;
inline bool TransportStop::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransportStop::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransportStop::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransportStop::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 TransportStop::id() const {
  return id_;
}
inline void TransportStop::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// required uint32 name = 6;
inline bool TransportStop::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransportStop::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransportStop::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransportStop::clear_name() {
  name_ = 0u;
  clear_has_name();
}
inline ::google::protobuf::uint32 TransportStop::name() const {
  return name_;
}
inline void TransportStop::set_name(::google::protobuf::uint32 value) {
  set_has_name();
  name_ = value;
}

// optional uint32 name_en = 7;
inline bool TransportStop::has_name_en() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TransportStop::set_has_name_en() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TransportStop::clear_has_name_en() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TransportStop::clear_name_en() {
  name_en_ = 0u;
  clear_has_name_en();
}
inline ::google::protobuf::uint32 TransportStop::name_en() const {
  return name_en_;
}
inline void TransportStop::set_name_en(::google::protobuf::uint32 value) {
  set_has_name_en();
  name_en_ = value;
}

// optional bytes additionalNamePairs = 8;
inline bool TransportStop::has_additionalnamepairs() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TransportStop::set_has_additionalnamepairs() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TransportStop::clear_has_additionalnamepairs() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TransportStop::clear_additionalnamepairs() {
  if (additionalnamepairs_ != &::google::protobuf::internal::kEmptyString) {
    additionalnamepairs_->clear();
  }
  clear_has_additionalnamepairs();
}
inline const ::std::string& TransportStop::additionalnamepairs() const {
  return *additionalnamepairs_;
}
inline void TransportStop::set_additionalnamepairs(const ::std::string& value) {
  set_has_additionalnamepairs();
  if (additionalnamepairs_ == &::google::protobuf::internal::kEmptyString) {
    additionalnamepairs_ = new ::std::string;
  }
  additionalnamepairs_->assign(value);
}
inline void TransportStop::set_additionalnamepairs(const char* value) {
  set_has_additionalnamepairs();
  if (additionalnamepairs_ == &::google::protobuf::internal::kEmptyString) {
    additionalnamepairs_ = new ::std::string;
  }
  additionalnamepairs_->assign(value);
}
inline void TransportStop::set_additionalnamepairs(const void* value, size_t size) {
  set_has_additionalnamepairs();
  if (additionalnamepairs_ == &::google::protobuf::internal::kEmptyString) {
    additionalnamepairs_ = new ::std::string;
  }
  additionalnamepairs_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransportStop::mutable_additionalnamepairs() {
  set_has_additionalnamepairs();
  if (additionalnamepairs_ == &::google::protobuf::internal::kEmptyString) {
    additionalnamepairs_ = new ::std::string;
  }
  return additionalnamepairs_;
}
inline ::std::string* TransportStop::release_additionalnamepairs() {
  clear_has_additionalnamepairs();
  if (additionalnamepairs_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = additionalnamepairs_;
    additionalnamepairs_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransportStop::set_allocated_additionalnamepairs(::std::string* additionalnamepairs) {
  if (additionalnamepairs_ != &::google::protobuf::internal::kEmptyString) {
    delete additionalnamepairs_;
  }
  if (additionalnamepairs) {
    set_has_additionalnamepairs();
    additionalnamepairs_ = additionalnamepairs;
  } else {
    clear_has_additionalnamepairs();
    additionalnamepairs_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .OsmAnd.OBF.TransportStopExit exits = 9;
inline int TransportStop::exits_size() const {
  return exits_.size();
}
inline void TransportStop::clear_exits() {
  exits_.Clear();
}
inline const ::OsmAnd::OBF::TransportStopExit& TransportStop::exits(int index) const {
  return exits_.Get(index);
}
inline ::OsmAnd::OBF::TransportStopExit* TransportStop::mutable_exits(int index) {
  return exits_.Mutable(index);
}
inline ::OsmAnd::OBF::TransportStopExit* TransportStop::add_exits() {
  return exits_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportStopExit >&
TransportStop::exits() const {
  return exits_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportStopExit >*
TransportStop::mutable_exits() {
  return &exits_;
}

// repeated uint32 routes = 16;
inline int TransportStop::routes_size() const {
  return routes_.size();
}
inline void TransportStop::clear_routes() {
  routes_.Clear();
}
inline ::google::protobuf::uint32 TransportStop::routes(int index) const {
  return routes_.Get(index);
}
inline void TransportStop::set_routes(int index, ::google::protobuf::uint32 value) {
  routes_.Set(index, value);
}
inline void TransportStop::add_routes(::google::protobuf::uint32 value) {
  routes_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TransportStop::routes() const {
  return routes_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TransportStop::mutable_routes() {
  return &routes_;
}

// repeated uint64 deletedRoutesIds = 20;
inline int TransportStop::deletedroutesids_size() const {
  return deletedroutesids_.size();
}
inline void TransportStop::clear_deletedroutesids() {
  deletedroutesids_.Clear();
}
inline ::google::protobuf::uint64 TransportStop::deletedroutesids(int index) const {
  return deletedroutesids_.Get(index);
}
inline void TransportStop::set_deletedroutesids(int index, ::google::protobuf::uint64 value) {
  deletedroutesids_.Set(index, value);
}
inline void TransportStop::add_deletedroutesids(::google::protobuf::uint64 value) {
  deletedroutesids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
TransportStop::deletedroutesids() const {
  return deletedroutesids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
TransportStop::mutable_deletedroutesids() {
  return &deletedroutesids_;
}

// repeated uint64 routesIds = 22;
inline int TransportStop::routesids_size() const {
  return routesids_.size();
}
inline void TransportStop::clear_routesids() {
  routesids_.Clear();
}
inline ::google::protobuf::uint64 TransportStop::routesids(int index) const {
  return routesids_.Get(index);
}
inline void TransportStop::set_routesids(int index, ::google::protobuf::uint64 value) {
  routesids_.Set(index, value);
}
inline void TransportStop::add_routesids(::google::protobuf::uint64 value) {
  routesids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
TransportStop::routesids() const {
  return routesids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
TransportStop::mutable_routesids() {
  return &routesids_;
}

// -------------------------------------------------------------------

// TransportStopExit

// required sint32 dx = 1;
inline bool TransportStopExit::has_dx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransportStopExit::set_has_dx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransportStopExit::clear_has_dx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransportStopExit::clear_dx() {
  dx_ = 0;
  clear_has_dx();
}
inline ::google::protobuf::int32 TransportStopExit::dx() const {
  return dx_;
}
inline void TransportStopExit::set_dx(::google::protobuf::int32 value) {
  set_has_dx();
  dx_ = value;
}

// required sint32 dy = 2;
inline bool TransportStopExit::has_dy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransportStopExit::set_has_dy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransportStopExit::clear_has_dy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransportStopExit::clear_dy() {
  dy_ = 0;
  clear_has_dy();
}
inline ::google::protobuf::int32 TransportStopExit::dy() const {
  return dy_;
}
inline void TransportStopExit::set_dy(::google::protobuf::int32 value) {
  set_has_dy();
  dy_ = value;
}

// required uint32 ref = 3;
inline bool TransportStopExit::has_ref() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransportStopExit::set_has_ref() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransportStopExit::clear_has_ref() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransportStopExit::clear_ref() {
  ref_ = 0u;
  clear_has_ref();
}
inline ::google::protobuf::uint32 TransportStopExit::ref() const {
  return ref_;
}
inline void TransportStopExit::set_ref(::google::protobuf::uint32 value) {
  set_has_ref();
  ref_ = value;
}

// -------------------------------------------------------------------

// TransportStopsTree

// required sint32 left = 1;
inline bool TransportStopsTree::has_left() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransportStopsTree::set_has_left() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransportStopsTree::clear_has_left() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransportStopsTree::clear_left() {
  left_ = 0;
  clear_has_left();
}
inline ::google::protobuf::int32 TransportStopsTree::left() const {
  return left_;
}
inline void TransportStopsTree::set_left(::google::protobuf::int32 value) {
  set_has_left();
  left_ = value;
}

// required sint32 right = 2;
inline bool TransportStopsTree::has_right() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransportStopsTree::set_has_right() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransportStopsTree::clear_has_right() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransportStopsTree::clear_right() {
  right_ = 0;
  clear_has_right();
}
inline ::google::protobuf::int32 TransportStopsTree::right() const {
  return right_;
}
inline void TransportStopsTree::set_right(::google::protobuf::int32 value) {
  set_has_right();
  right_ = value;
}

// required sint32 top = 3;
inline bool TransportStopsTree::has_top() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransportStopsTree::set_has_top() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransportStopsTree::clear_has_top() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransportStopsTree::clear_top() {
  top_ = 0;
  clear_has_top();
}
inline ::google::protobuf::int32 TransportStopsTree::top() const {
  return top_;
}
inline void TransportStopsTree::set_top(::google::protobuf::int32 value) {
  set_has_top();
  top_ = value;
}

// required sint32 bottom = 4;
inline bool TransportStopsTree::has_bottom() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransportStopsTree::set_has_bottom() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransportStopsTree::clear_has_bottom() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransportStopsTree::clear_bottom() {
  bottom_ = 0;
  clear_has_bottom();
}
inline ::google::protobuf::int32 TransportStopsTree::bottom() const {
  return bottom_;
}
inline void TransportStopsTree::set_bottom(::google::protobuf::int32 value) {
  set_has_bottom();
  bottom_ = value;
}

// repeated .OsmAnd.OBF.TransportStopsTree subtrees = 7;
inline int TransportStopsTree::subtrees_size() const {
  return subtrees_.size();
}
inline void TransportStopsTree::clear_subtrees() {
  subtrees_.Clear();
}
inline const ::OsmAnd::OBF::TransportStopsTree& TransportStopsTree::subtrees(int index) const {
  return subtrees_.Get(index);
}
inline ::OsmAnd::OBF::TransportStopsTree* TransportStopsTree::mutable_subtrees(int index) {
  return subtrees_.Mutable(index);
}
inline ::OsmAnd::OBF::TransportStopsTree* TransportStopsTree::add_subtrees() {
  return subtrees_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportStopsTree >&
TransportStopsTree::subtrees() const {
  return subtrees_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportStopsTree >*
TransportStopsTree::mutable_subtrees() {
  return &subtrees_;
}

// repeated .OsmAnd.OBF.TransportStop leafs = 8;
inline int TransportStopsTree::leafs_size() const {
  return leafs_.size();
}
inline void TransportStopsTree::clear_leafs() {
  leafs_.Clear();
}
inline const ::OsmAnd::OBF::TransportStop& TransportStopsTree::leafs(int index) const {
  return leafs_.Get(index);
}
inline ::OsmAnd::OBF::TransportStop* TransportStopsTree::mutable_leafs(int index) {
  return leafs_.Mutable(index);
}
inline ::OsmAnd::OBF::TransportStop* TransportStopsTree::add_leafs() {
  return leafs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportStop >&
TransportStopsTree::leafs() const {
  return leafs_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::TransportStop >*
TransportStopsTree::mutable_leafs() {
  return &leafs_;
}

// optional uint64 baseId = 16;
inline bool TransportStopsTree::has_baseid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TransportStopsTree::set_has_baseid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TransportStopsTree::clear_has_baseid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TransportStopsTree::clear_baseid() {
  baseid_ = GOOGLE_ULONGLONG(0);
  clear_has_baseid();
}
inline ::google::protobuf::uint64 TransportStopsTree::baseid() const {
  return baseid_;
}
inline void TransportStopsTree::set_baseid(::google::protobuf::uint64 value) {
  set_has_baseid();
  baseid_ = value;
}

// -------------------------------------------------------------------

// OsmAndTransportIndex

// optional string name = 1;
inline bool OsmAndTransportIndex::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsmAndTransportIndex::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsmAndTransportIndex::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsmAndTransportIndex::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& OsmAndTransportIndex::name() const {
  return *name_;
}
inline void OsmAndTransportIndex::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndTransportIndex::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndTransportIndex::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndTransportIndex::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* OsmAndTransportIndex::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OsmAndTransportIndex::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .OsmAnd.OBF.TransportRoutes routes = 3;
inline bool OsmAndTransportIndex::has_routes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OsmAndTransportIndex::set_has_routes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OsmAndTransportIndex::clear_has_routes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OsmAndTransportIndex::clear_routes() {
  if (routes_ != NULL) routes_->::OsmAnd::OBF::TransportRoutes::Clear();
  clear_has_routes();
}
inline const ::OsmAnd::OBF::TransportRoutes& OsmAndTransportIndex::routes() const {
  return routes_ != NULL ? *routes_ : *default_instance_->routes_;
}
inline ::OsmAnd::OBF::TransportRoutes* OsmAndTransportIndex::mutable_routes() {
  set_has_routes();
  if (routes_ == NULL) routes_ = new ::OsmAnd::OBF::TransportRoutes;
  return routes_;
}
inline ::OsmAnd::OBF::TransportRoutes* OsmAndTransportIndex::release_routes() {
  clear_has_routes();
  ::OsmAnd::OBF::TransportRoutes* temp = routes_;
  routes_ = NULL;
  return temp;
}
inline void OsmAndTransportIndex::set_allocated_routes(::OsmAnd::OBF::TransportRoutes* routes) {
  delete routes_;
  routes_ = routes;
  if (routes) {
    set_has_routes();
  } else {
    clear_has_routes();
  }
}

// optional .OsmAnd.OBF.TransportStopsTree stops = 6;
inline bool OsmAndTransportIndex::has_stops() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OsmAndTransportIndex::set_has_stops() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OsmAndTransportIndex::clear_has_stops() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OsmAndTransportIndex::clear_stops() {
  if (stops_ != NULL) stops_->::OsmAnd::OBF::TransportStopsTree::Clear();
  clear_has_stops();
}
inline const ::OsmAnd::OBF::TransportStopsTree& OsmAndTransportIndex::stops() const {
  return stops_ != NULL ? *stops_ : *default_instance_->stops_;
}
inline ::OsmAnd::OBF::TransportStopsTree* OsmAndTransportIndex::mutable_stops() {
  set_has_stops();
  if (stops_ == NULL) stops_ = new ::OsmAnd::OBF::TransportStopsTree;
  return stops_;
}
inline ::OsmAnd::OBF::TransportStopsTree* OsmAndTransportIndex::release_stops() {
  clear_has_stops();
  ::OsmAnd::OBF::TransportStopsTree* temp = stops_;
  stops_ = NULL;
  return temp;
}
inline void OsmAndTransportIndex::set_allocated_stops(::OsmAnd::OBF::TransportStopsTree* stops) {
  delete stops_;
  stops_ = stops;
  if (stops) {
    set_has_stops();
  } else {
    clear_has_stops();
  }
}

// optional .OsmAnd.OBF.IncompleteTransportRoutes incompleteRoutes = 8;
inline bool OsmAndTransportIndex::has_incompleteroutes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OsmAndTransportIndex::set_has_incompleteroutes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OsmAndTransportIndex::clear_has_incompleteroutes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OsmAndTransportIndex::clear_incompleteroutes() {
  if (incompleteroutes_ != NULL) incompleteroutes_->::OsmAnd::OBF::IncompleteTransportRoutes::Clear();
  clear_has_incompleteroutes();
}
inline const ::OsmAnd::OBF::IncompleteTransportRoutes& OsmAndTransportIndex::incompleteroutes() const {
  return incompleteroutes_ != NULL ? *incompleteroutes_ : *default_instance_->incompleteroutes_;
}
inline ::OsmAnd::OBF::IncompleteTransportRoutes* OsmAndTransportIndex::mutable_incompleteroutes() {
  set_has_incompleteroutes();
  if (incompleteroutes_ == NULL) incompleteroutes_ = new ::OsmAnd::OBF::IncompleteTransportRoutes;
  return incompleteroutes_;
}
inline ::OsmAnd::OBF::IncompleteTransportRoutes* OsmAndTransportIndex::release_incompleteroutes() {
  clear_has_incompleteroutes();
  ::OsmAnd::OBF::IncompleteTransportRoutes* temp = incompleteroutes_;
  incompleteroutes_ = NULL;
  return temp;
}
inline void OsmAndTransportIndex::set_allocated_incompleteroutes(::OsmAnd::OBF::IncompleteTransportRoutes* incompleteroutes) {
  delete incompleteroutes_;
  incompleteroutes_ = incompleteroutes;
  if (incompleteroutes) {
    set_has_incompleteroutes();
  } else {
    clear_has_incompleteroutes();
  }
}

// required .OsmAnd.OBF.StringTable stringTable = 9;
inline bool OsmAndTransportIndex::has_stringtable() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OsmAndTransportIndex::set_has_stringtable() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OsmAndTransportIndex::clear_has_stringtable() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OsmAndTransportIndex::clear_stringtable() {
  if (stringtable_ != NULL) stringtable_->::OsmAnd::OBF::StringTable::Clear();
  clear_has_stringtable();
}
inline const ::OsmAnd::OBF::StringTable& OsmAndTransportIndex::stringtable() const {
  return stringtable_ != NULL ? *stringtable_ : *default_instance_->stringtable_;
}
inline ::OsmAnd::OBF::StringTable* OsmAndTransportIndex::mutable_stringtable() {
  set_has_stringtable();
  if (stringtable_ == NULL) stringtable_ = new ::OsmAnd::OBF::StringTable;
  return stringtable_;
}
inline ::OsmAnd::OBF::StringTable* OsmAndTransportIndex::release_stringtable() {
  clear_has_stringtable();
  ::OsmAnd::OBF::StringTable* temp = stringtable_;
  stringtable_ = NULL;
  return temp;
}
inline void OsmAndTransportIndex::set_allocated_stringtable(::OsmAnd::OBF::StringTable* stringtable) {
  delete stringtable_;
  stringtable_ = stringtable;
  if (stringtable) {
    set_has_stringtable();
  } else {
    clear_has_stringtable();
  }
}

// -------------------------------------------------------------------

// OsmAndPoiIndex

// required string name = 1;
inline bool OsmAndPoiIndex::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsmAndPoiIndex::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsmAndPoiIndex::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsmAndPoiIndex::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& OsmAndPoiIndex::name() const {
  return *name_;
}
inline void OsmAndPoiIndex::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndPoiIndex::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndPoiIndex::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndPoiIndex::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* OsmAndPoiIndex::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OsmAndPoiIndex::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .OsmAnd.OBF.OsmAndTileBox boundaries = 2;
inline bool OsmAndPoiIndex::has_boundaries() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OsmAndPoiIndex::set_has_boundaries() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OsmAndPoiIndex::clear_has_boundaries() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OsmAndPoiIndex::clear_boundaries() {
  if (boundaries_ != NULL) boundaries_->::OsmAnd::OBF::OsmAndTileBox::Clear();
  clear_has_boundaries();
}
inline const ::OsmAnd::OBF::OsmAndTileBox& OsmAndPoiIndex::boundaries() const {
  return boundaries_ != NULL ? *boundaries_ : *default_instance_->boundaries_;
}
inline ::OsmAnd::OBF::OsmAndTileBox* OsmAndPoiIndex::mutable_boundaries() {
  set_has_boundaries();
  if (boundaries_ == NULL) boundaries_ = new ::OsmAnd::OBF::OsmAndTileBox;
  return boundaries_;
}
inline ::OsmAnd::OBF::OsmAndTileBox* OsmAndPoiIndex::release_boundaries() {
  clear_has_boundaries();
  ::OsmAnd::OBF::OsmAndTileBox* temp = boundaries_;
  boundaries_ = NULL;
  return temp;
}
inline void OsmAndPoiIndex::set_allocated_boundaries(::OsmAnd::OBF::OsmAndTileBox* boundaries) {
  delete boundaries_;
  boundaries_ = boundaries;
  if (boundaries) {
    set_has_boundaries();
  } else {
    clear_has_boundaries();
  }
}

// repeated .OsmAnd.OBF.OsmAndCategoryTable categoriesTable = 3;
inline int OsmAndPoiIndex::categoriestable_size() const {
  return categoriestable_.size();
}
inline void OsmAndPoiIndex::clear_categoriestable() {
  categoriestable_.Clear();
}
inline const ::OsmAnd::OBF::OsmAndCategoryTable& OsmAndPoiIndex::categoriestable(int index) const {
  return categoriestable_.Get(index);
}
inline ::OsmAnd::OBF::OsmAndCategoryTable* OsmAndPoiIndex::mutable_categoriestable(int index) {
  return categoriestable_.Mutable(index);
}
inline ::OsmAnd::OBF::OsmAndCategoryTable* OsmAndPoiIndex::add_categoriestable() {
  return categoriestable_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndCategoryTable >&
OsmAndPoiIndex::categoriestable() const {
  return categoriestable_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndCategoryTable >*
OsmAndPoiIndex::mutable_categoriestable() {
  return &categoriestable_;
}

// optional .OsmAnd.OBF.OsmAndPoiNameIndex nameIndex = 4;
inline bool OsmAndPoiIndex::has_nameindex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OsmAndPoiIndex::set_has_nameindex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OsmAndPoiIndex::clear_has_nameindex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OsmAndPoiIndex::clear_nameindex() {
  if (nameindex_ != NULL) nameindex_->::OsmAnd::OBF::OsmAndPoiNameIndex::Clear();
  clear_has_nameindex();
}
inline const ::OsmAnd::OBF::OsmAndPoiNameIndex& OsmAndPoiIndex::nameindex() const {
  return nameindex_ != NULL ? *nameindex_ : *default_instance_->nameindex_;
}
inline ::OsmAnd::OBF::OsmAndPoiNameIndex* OsmAndPoiIndex::mutable_nameindex() {
  set_has_nameindex();
  if (nameindex_ == NULL) nameindex_ = new ::OsmAnd::OBF::OsmAndPoiNameIndex;
  return nameindex_;
}
inline ::OsmAnd::OBF::OsmAndPoiNameIndex* OsmAndPoiIndex::release_nameindex() {
  clear_has_nameindex();
  ::OsmAnd::OBF::OsmAndPoiNameIndex* temp = nameindex_;
  nameindex_ = NULL;
  return temp;
}
inline void OsmAndPoiIndex::set_allocated_nameindex(::OsmAnd::OBF::OsmAndPoiNameIndex* nameindex) {
  delete nameindex_;
  nameindex_ = nameindex;
  if (nameindex) {
    set_has_nameindex();
  } else {
    clear_has_nameindex();
  }
}

// optional .OsmAnd.OBF.OsmAndSubtypesTable subtypesTable = 5;
inline bool OsmAndPoiIndex::has_subtypestable() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OsmAndPoiIndex::set_has_subtypestable() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OsmAndPoiIndex::clear_has_subtypestable() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OsmAndPoiIndex::clear_subtypestable() {
  if (subtypestable_ != NULL) subtypestable_->::OsmAnd::OBF::OsmAndSubtypesTable::Clear();
  clear_has_subtypestable();
}
inline const ::OsmAnd::OBF::OsmAndSubtypesTable& OsmAndPoiIndex::subtypestable() const {
  return subtypestable_ != NULL ? *subtypestable_ : *default_instance_->subtypestable_;
}
inline ::OsmAnd::OBF::OsmAndSubtypesTable* OsmAndPoiIndex::mutable_subtypestable() {
  set_has_subtypestable();
  if (subtypestable_ == NULL) subtypestable_ = new ::OsmAnd::OBF::OsmAndSubtypesTable;
  return subtypestable_;
}
inline ::OsmAnd::OBF::OsmAndSubtypesTable* OsmAndPoiIndex::release_subtypestable() {
  clear_has_subtypestable();
  ::OsmAnd::OBF::OsmAndSubtypesTable* temp = subtypestable_;
  subtypestable_ = NULL;
  return temp;
}
inline void OsmAndPoiIndex::set_allocated_subtypestable(::OsmAnd::OBF::OsmAndSubtypesTable* subtypestable) {
  delete subtypestable_;
  subtypestable_ = subtypestable;
  if (subtypestable) {
    set_has_subtypestable();
  } else {
    clear_has_subtypestable();
  }
}

// repeated .OsmAnd.OBF.OsmAndPoiBox boxes = 6;
inline int OsmAndPoiIndex::boxes_size() const {
  return boxes_.size();
}
inline void OsmAndPoiIndex::clear_boxes() {
  boxes_.Clear();
}
inline const ::OsmAnd::OBF::OsmAndPoiBox& OsmAndPoiIndex::boxes(int index) const {
  return boxes_.Get(index);
}
inline ::OsmAnd::OBF::OsmAndPoiBox* OsmAndPoiIndex::mutable_boxes(int index) {
  return boxes_.Mutable(index);
}
inline ::OsmAnd::OBF::OsmAndPoiBox* OsmAndPoiIndex::add_boxes() {
  return boxes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiBox >&
OsmAndPoiIndex::boxes() const {
  return boxes_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiBox >*
OsmAndPoiIndex::mutable_boxes() {
  return &boxes_;
}

// repeated .OsmAnd.OBF.OsmAndPoiBoxData poiData = 9;
inline int OsmAndPoiIndex::poidata_size() const {
  return poidata_.size();
}
inline void OsmAndPoiIndex::clear_poidata() {
  poidata_.Clear();
}
inline const ::OsmAnd::OBF::OsmAndPoiBoxData& OsmAndPoiIndex::poidata(int index) const {
  return poidata_.Get(index);
}
inline ::OsmAnd::OBF::OsmAndPoiBoxData* OsmAndPoiIndex::mutable_poidata(int index) {
  return poidata_.Mutable(index);
}
inline ::OsmAnd::OBF::OsmAndPoiBoxData* OsmAndPoiIndex::add_poidata() {
  return poidata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiBoxData >&
OsmAndPoiIndex::poidata() const {
  return poidata_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiBoxData >*
OsmAndPoiIndex::mutable_poidata() {
  return &poidata_;
}

// -------------------------------------------------------------------

// OsmAndPoiNameIndex_OsmAndPoiNameIndexData

// repeated .OsmAnd.OBF.OsmAndPoiNameIndexDataAtom atoms = 3;
inline int OsmAndPoiNameIndex_OsmAndPoiNameIndexData::atoms_size() const {
  return atoms_.size();
}
inline void OsmAndPoiNameIndex_OsmAndPoiNameIndexData::clear_atoms() {
  atoms_.Clear();
}
inline const ::OsmAnd::OBF::OsmAndPoiNameIndexDataAtom& OsmAndPoiNameIndex_OsmAndPoiNameIndexData::atoms(int index) const {
  return atoms_.Get(index);
}
inline ::OsmAnd::OBF::OsmAndPoiNameIndexDataAtom* OsmAndPoiNameIndex_OsmAndPoiNameIndexData::mutable_atoms(int index) {
  return atoms_.Mutable(index);
}
inline ::OsmAnd::OBF::OsmAndPoiNameIndexDataAtom* OsmAndPoiNameIndex_OsmAndPoiNameIndexData::add_atoms() {
  return atoms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiNameIndexDataAtom >&
OsmAndPoiNameIndex_OsmAndPoiNameIndexData::atoms() const {
  return atoms_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiNameIndexDataAtom >*
OsmAndPoiNameIndex_OsmAndPoiNameIndexData::mutable_atoms() {
  return &atoms_;
}

// -------------------------------------------------------------------

// OsmAndPoiNameIndex

// required .OsmAnd.OBF.IndexedStringTable table = 3;
inline bool OsmAndPoiNameIndex::has_table() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsmAndPoiNameIndex::set_has_table() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsmAndPoiNameIndex::clear_has_table() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsmAndPoiNameIndex::clear_table() {
  if (table_ != NULL) table_->::OsmAnd::OBF::IndexedStringTable::Clear();
  clear_has_table();
}
inline const ::OsmAnd::OBF::IndexedStringTable& OsmAndPoiNameIndex::table() const {
  return table_ != NULL ? *table_ : *default_instance_->table_;
}
inline ::OsmAnd::OBF::IndexedStringTable* OsmAndPoiNameIndex::mutable_table() {
  set_has_table();
  if (table_ == NULL) table_ = new ::OsmAnd::OBF::IndexedStringTable;
  return table_;
}
inline ::OsmAnd::OBF::IndexedStringTable* OsmAndPoiNameIndex::release_table() {
  clear_has_table();
  ::OsmAnd::OBF::IndexedStringTable* temp = table_;
  table_ = NULL;
  return temp;
}
inline void OsmAndPoiNameIndex::set_allocated_table(::OsmAnd::OBF::IndexedStringTable* table) {
  delete table_;
  table_ = table;
  if (table) {
    set_has_table();
  } else {
    clear_has_table();
  }
}

// repeated .OsmAnd.OBF.OsmAndPoiNameIndex.OsmAndPoiNameIndexData data = 5;
inline int OsmAndPoiNameIndex::data_size() const {
  return data_.size();
}
inline void OsmAndPoiNameIndex::clear_data() {
  data_.Clear();
}
inline const ::OsmAnd::OBF::OsmAndPoiNameIndex_OsmAndPoiNameIndexData& OsmAndPoiNameIndex::data(int index) const {
  return data_.Get(index);
}
inline ::OsmAnd::OBF::OsmAndPoiNameIndex_OsmAndPoiNameIndexData* OsmAndPoiNameIndex::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::OsmAnd::OBF::OsmAndPoiNameIndex_OsmAndPoiNameIndexData* OsmAndPoiNameIndex::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiNameIndex_OsmAndPoiNameIndexData >&
OsmAndPoiNameIndex::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiNameIndex_OsmAndPoiNameIndexData >*
OsmAndPoiNameIndex::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// OsmAndPoiNameIndexDataAtom

// optional uint32 zoom = 2;
inline bool OsmAndPoiNameIndexDataAtom::has_zoom() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsmAndPoiNameIndexDataAtom::set_has_zoom() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsmAndPoiNameIndexDataAtom::clear_has_zoom() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsmAndPoiNameIndexDataAtom::clear_zoom() {
  zoom_ = 0u;
  clear_has_zoom();
}
inline ::google::protobuf::uint32 OsmAndPoiNameIndexDataAtom::zoom() const {
  return zoom_;
}
inline void OsmAndPoiNameIndexDataAtom::set_zoom(::google::protobuf::uint32 value) {
  set_has_zoom();
  zoom_ = value;
}

// optional uint32 x = 3;
inline bool OsmAndPoiNameIndexDataAtom::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OsmAndPoiNameIndexDataAtom::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OsmAndPoiNameIndexDataAtom::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OsmAndPoiNameIndexDataAtom::clear_x() {
  x_ = 0u;
  clear_has_x();
}
inline ::google::protobuf::uint32 OsmAndPoiNameIndexDataAtom::x() const {
  return x_;
}
inline void OsmAndPoiNameIndexDataAtom::set_x(::google::protobuf::uint32 value) {
  set_has_x();
  x_ = value;
}

// optional uint32 y = 4;
inline bool OsmAndPoiNameIndexDataAtom::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OsmAndPoiNameIndexDataAtom::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OsmAndPoiNameIndexDataAtom::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OsmAndPoiNameIndexDataAtom::clear_y() {
  y_ = 0u;
  clear_has_y();
}
inline ::google::protobuf::uint32 OsmAndPoiNameIndexDataAtom::y() const {
  return y_;
}
inline void OsmAndPoiNameIndexDataAtom::set_y(::google::protobuf::uint32 value) {
  set_has_y();
  y_ = value;
}

// optional fixed32 shiftTo = 14;
inline bool OsmAndPoiNameIndexDataAtom::has_shiftto() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OsmAndPoiNameIndexDataAtom::set_has_shiftto() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OsmAndPoiNameIndexDataAtom::clear_has_shiftto() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OsmAndPoiNameIndexDataAtom::clear_shiftto() {
  shiftto_ = 0u;
  clear_has_shiftto();
}
inline ::google::protobuf::uint32 OsmAndPoiNameIndexDataAtom::shiftto() const {
  return shiftto_;
}
inline void OsmAndPoiNameIndexDataAtom::set_shiftto(::google::protobuf::uint32 value) {
  set_has_shiftto();
  shiftto_ = value;
}

// -------------------------------------------------------------------

// OsmAndCategoryTable

// required string category = 1;
inline bool OsmAndCategoryTable::has_category() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsmAndCategoryTable::set_has_category() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsmAndCategoryTable::clear_has_category() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsmAndCategoryTable::clear_category() {
  if (category_ != &::google::protobuf::internal::kEmptyString) {
    category_->clear();
  }
  clear_has_category();
}
inline const ::std::string& OsmAndCategoryTable::category() const {
  return *category_;
}
inline void OsmAndCategoryTable::set_category(const ::std::string& value) {
  set_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    category_ = new ::std::string;
  }
  category_->assign(value);
}
inline void OsmAndCategoryTable::set_category(const char* value) {
  set_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    category_ = new ::std::string;
  }
  category_->assign(value);
}
inline void OsmAndCategoryTable::set_category(const char* value, size_t size) {
  set_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    category_ = new ::std::string;
  }
  category_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndCategoryTable::mutable_category() {
  set_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    category_ = new ::std::string;
  }
  return category_;
}
inline ::std::string* OsmAndCategoryTable::release_category() {
  clear_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = category_;
    category_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OsmAndCategoryTable::set_allocated_category(::std::string* category) {
  if (category_ != &::google::protobuf::internal::kEmptyString) {
    delete category_;
  }
  if (category) {
    set_has_category();
    category_ = category;
  } else {
    clear_has_category();
    category_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string subcategories = 3;
inline int OsmAndCategoryTable::subcategories_size() const {
  return subcategories_.size();
}
inline void OsmAndCategoryTable::clear_subcategories() {
  subcategories_.Clear();
}
inline const ::std::string& OsmAndCategoryTable::subcategories(int index) const {
  return subcategories_.Get(index);
}
inline ::std::string* OsmAndCategoryTable::mutable_subcategories(int index) {
  return subcategories_.Mutable(index);
}
inline void OsmAndCategoryTable::set_subcategories(int index, const ::std::string& value) {
  subcategories_.Mutable(index)->assign(value);
}
inline void OsmAndCategoryTable::set_subcategories(int index, const char* value) {
  subcategories_.Mutable(index)->assign(value);
}
inline void OsmAndCategoryTable::set_subcategories(int index, const char* value, size_t size) {
  subcategories_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndCategoryTable::add_subcategories() {
  return subcategories_.Add();
}
inline void OsmAndCategoryTable::add_subcategories(const ::std::string& value) {
  subcategories_.Add()->assign(value);
}
inline void OsmAndCategoryTable::add_subcategories(const char* value) {
  subcategories_.Add()->assign(value);
}
inline void OsmAndCategoryTable::add_subcategories(const char* value, size_t size) {
  subcategories_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OsmAndCategoryTable::subcategories() const {
  return subcategories_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OsmAndCategoryTable::mutable_subcategories() {
  return &subcategories_;
}

// -------------------------------------------------------------------

// OsmAndSubtypesTable

// repeated .OsmAnd.OBF.OsmAndPoiSubtype subtypes = 4;
inline int OsmAndSubtypesTable::subtypes_size() const {
  return subtypes_.size();
}
inline void OsmAndSubtypesTable::clear_subtypes() {
  subtypes_.Clear();
}
inline const ::OsmAnd::OBF::OsmAndPoiSubtype& OsmAndSubtypesTable::subtypes(int index) const {
  return subtypes_.Get(index);
}
inline ::OsmAnd::OBF::OsmAndPoiSubtype* OsmAndSubtypesTable::mutable_subtypes(int index) {
  return subtypes_.Mutable(index);
}
inline ::OsmAnd::OBF::OsmAndPoiSubtype* OsmAndSubtypesTable::add_subtypes() {
  return subtypes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiSubtype >&
OsmAndSubtypesTable::subtypes() const {
  return subtypes_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiSubtype >*
OsmAndSubtypesTable::mutable_subtypes() {
  return &subtypes_;
}

// -------------------------------------------------------------------

// OsmAndPoiSubtype

// required string name = 1;
inline bool OsmAndPoiSubtype::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsmAndPoiSubtype::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsmAndPoiSubtype::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsmAndPoiSubtype::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& OsmAndPoiSubtype::name() const {
  return *name_;
}
inline void OsmAndPoiSubtype::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndPoiSubtype::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndPoiSubtype::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndPoiSubtype::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* OsmAndPoiSubtype::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OsmAndPoiSubtype::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string tagname = 2;
inline bool OsmAndPoiSubtype::has_tagname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OsmAndPoiSubtype::set_has_tagname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OsmAndPoiSubtype::clear_has_tagname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OsmAndPoiSubtype::clear_tagname() {
  if (tagname_ != &::google::protobuf::internal::kEmptyString) {
    tagname_->clear();
  }
  clear_has_tagname();
}
inline const ::std::string& OsmAndPoiSubtype::tagname() const {
  return *tagname_;
}
inline void OsmAndPoiSubtype::set_tagname(const ::std::string& value) {
  set_has_tagname();
  if (tagname_ == &::google::protobuf::internal::kEmptyString) {
    tagname_ = new ::std::string;
  }
  tagname_->assign(value);
}
inline void OsmAndPoiSubtype::set_tagname(const char* value) {
  set_has_tagname();
  if (tagname_ == &::google::protobuf::internal::kEmptyString) {
    tagname_ = new ::std::string;
  }
  tagname_->assign(value);
}
inline void OsmAndPoiSubtype::set_tagname(const char* value, size_t size) {
  set_has_tagname();
  if (tagname_ == &::google::protobuf::internal::kEmptyString) {
    tagname_ = new ::std::string;
  }
  tagname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndPoiSubtype::mutable_tagname() {
  set_has_tagname();
  if (tagname_ == &::google::protobuf::internal::kEmptyString) {
    tagname_ = new ::std::string;
  }
  return tagname_;
}
inline ::std::string* OsmAndPoiSubtype::release_tagname() {
  clear_has_tagname();
  if (tagname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tagname_;
    tagname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OsmAndPoiSubtype::set_allocated_tagname(::std::string* tagname) {
  if (tagname_ != &::google::protobuf::internal::kEmptyString) {
    delete tagname_;
  }
  if (tagname) {
    set_has_tagname();
    tagname_ = tagname;
  } else {
    clear_has_tagname();
    tagname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool isText = 3;
inline bool OsmAndPoiSubtype::has_istext() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OsmAndPoiSubtype::set_has_istext() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OsmAndPoiSubtype::clear_has_istext() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OsmAndPoiSubtype::clear_istext() {
  istext_ = false;
  clear_has_istext();
}
inline bool OsmAndPoiSubtype::istext() const {
  return istext_;
}
inline void OsmAndPoiSubtype::set_istext(bool value) {
  set_has_istext();
  istext_ = value;
}

// optional uint32 frequency = 5;
inline bool OsmAndPoiSubtype::has_frequency() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OsmAndPoiSubtype::set_has_frequency() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OsmAndPoiSubtype::clear_has_frequency() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OsmAndPoiSubtype::clear_frequency() {
  frequency_ = 0u;
  clear_has_frequency();
}
inline ::google::protobuf::uint32 OsmAndPoiSubtype::frequency() const {
  return frequency_;
}
inline void OsmAndPoiSubtype::set_frequency(::google::protobuf::uint32 value) {
  set_has_frequency();
  frequency_ = value;
}

// optional uint32 subtypeValuesSize = 6;
inline bool OsmAndPoiSubtype::has_subtypevaluessize() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OsmAndPoiSubtype::set_has_subtypevaluessize() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OsmAndPoiSubtype::clear_has_subtypevaluessize() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OsmAndPoiSubtype::clear_subtypevaluessize() {
  subtypevaluessize_ = 0u;
  clear_has_subtypevaluessize();
}
inline ::google::protobuf::uint32 OsmAndPoiSubtype::subtypevaluessize() const {
  return subtypevaluessize_;
}
inline void OsmAndPoiSubtype::set_subtypevaluessize(::google::protobuf::uint32 value) {
  set_has_subtypevaluessize();
  subtypevaluessize_ = value;
}

// repeated string subtypeValue = 8;
inline int OsmAndPoiSubtype::subtypevalue_size() const {
  return subtypevalue_.size();
}
inline void OsmAndPoiSubtype::clear_subtypevalue() {
  subtypevalue_.Clear();
}
inline const ::std::string& OsmAndPoiSubtype::subtypevalue(int index) const {
  return subtypevalue_.Get(index);
}
inline ::std::string* OsmAndPoiSubtype::mutable_subtypevalue(int index) {
  return subtypevalue_.Mutable(index);
}
inline void OsmAndPoiSubtype::set_subtypevalue(int index, const ::std::string& value) {
  subtypevalue_.Mutable(index)->assign(value);
}
inline void OsmAndPoiSubtype::set_subtypevalue(int index, const char* value) {
  subtypevalue_.Mutable(index)->assign(value);
}
inline void OsmAndPoiSubtype::set_subtypevalue(int index, const char* value, size_t size) {
  subtypevalue_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndPoiSubtype::add_subtypevalue() {
  return subtypevalue_.Add();
}
inline void OsmAndPoiSubtype::add_subtypevalue(const ::std::string& value) {
  subtypevalue_.Add()->assign(value);
}
inline void OsmAndPoiSubtype::add_subtypevalue(const char* value) {
  subtypevalue_.Add()->assign(value);
}
inline void OsmAndPoiSubtype::add_subtypevalue(const char* value, size_t size) {
  subtypevalue_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OsmAndPoiSubtype::subtypevalue() const {
  return subtypevalue_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OsmAndPoiSubtype::mutable_subtypevalue() {
  return &subtypevalue_;
}

// -------------------------------------------------------------------

// OsmAndPoiTagGroup

// required uint32 id = 1;
inline bool OsmAndPoiTagGroup::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsmAndPoiTagGroup::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsmAndPoiTagGroup::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsmAndPoiTagGroup::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 OsmAndPoiTagGroup::id() const {
  return id_;
}
inline void OsmAndPoiTagGroup::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// repeated string tagValues = 5;
inline int OsmAndPoiTagGroup::tagvalues_size() const {
  return tagvalues_.size();
}
inline void OsmAndPoiTagGroup::clear_tagvalues() {
  tagvalues_.Clear();
}
inline const ::std::string& OsmAndPoiTagGroup::tagvalues(int index) const {
  return tagvalues_.Get(index);
}
inline ::std::string* OsmAndPoiTagGroup::mutable_tagvalues(int index) {
  return tagvalues_.Mutable(index);
}
inline void OsmAndPoiTagGroup::set_tagvalues(int index, const ::std::string& value) {
  tagvalues_.Mutable(index)->assign(value);
}
inline void OsmAndPoiTagGroup::set_tagvalues(int index, const char* value) {
  tagvalues_.Mutable(index)->assign(value);
}
inline void OsmAndPoiTagGroup::set_tagvalues(int index, const char* value, size_t size) {
  tagvalues_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndPoiTagGroup::add_tagvalues() {
  return tagvalues_.Add();
}
inline void OsmAndPoiTagGroup::add_tagvalues(const ::std::string& value) {
  tagvalues_.Add()->assign(value);
}
inline void OsmAndPoiTagGroup::add_tagvalues(const char* value) {
  tagvalues_.Add()->assign(value);
}
inline void OsmAndPoiTagGroup::add_tagvalues(const char* value, size_t size) {
  tagvalues_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OsmAndPoiTagGroup::tagvalues() const {
  return tagvalues_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OsmAndPoiTagGroup::mutable_tagvalues() {
  return &tagvalues_;
}

// -------------------------------------------------------------------

// OsmAndPoiTagGroups

// repeated uint32 ids = 2 [packed = true];
inline int OsmAndPoiTagGroups::ids_size() const {
  return ids_.size();
}
inline void OsmAndPoiTagGroups::clear_ids() {
  ids_.Clear();
}
inline ::google::protobuf::uint32 OsmAndPoiTagGroups::ids(int index) const {
  return ids_.Get(index);
}
inline void OsmAndPoiTagGroups::set_ids(int index, ::google::protobuf::uint32 value) {
  ids_.Set(index, value);
}
inline void OsmAndPoiTagGroups::add_ids(::google::protobuf::uint32 value) {
  ids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
OsmAndPoiTagGroups::ids() const {
  return ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
OsmAndPoiTagGroups::mutable_ids() {
  return &ids_;
}

// repeated .OsmAnd.OBF.OsmAndPoiTagGroup groups = 5;
inline int OsmAndPoiTagGroups::groups_size() const {
  return groups_.size();
}
inline void OsmAndPoiTagGroups::clear_groups() {
  groups_.Clear();
}
inline const ::OsmAnd::OBF::OsmAndPoiTagGroup& OsmAndPoiTagGroups::groups(int index) const {
  return groups_.Get(index);
}
inline ::OsmAnd::OBF::OsmAndPoiTagGroup* OsmAndPoiTagGroups::mutable_groups(int index) {
  return groups_.Mutable(index);
}
inline ::OsmAnd::OBF::OsmAndPoiTagGroup* OsmAndPoiTagGroups::add_groups() {
  return groups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiTagGroup >&
OsmAndPoiTagGroups::groups() const {
  return groups_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiTagGroup >*
OsmAndPoiTagGroups::mutable_groups() {
  return &groups_;
}

// -------------------------------------------------------------------

// OsmAndPoiBox

// required uint32 zoom = 1;
inline bool OsmAndPoiBox::has_zoom() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsmAndPoiBox::set_has_zoom() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsmAndPoiBox::clear_has_zoom() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsmAndPoiBox::clear_zoom() {
  zoom_ = 0u;
  clear_has_zoom();
}
inline ::google::protobuf::uint32 OsmAndPoiBox::zoom() const {
  return zoom_;
}
inline void OsmAndPoiBox::set_zoom(::google::protobuf::uint32 value) {
  set_has_zoom();
  zoom_ = value;
}

// required sint32 left = 2;
inline bool OsmAndPoiBox::has_left() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OsmAndPoiBox::set_has_left() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OsmAndPoiBox::clear_has_left() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OsmAndPoiBox::clear_left() {
  left_ = 0;
  clear_has_left();
}
inline ::google::protobuf::int32 OsmAndPoiBox::left() const {
  return left_;
}
inline void OsmAndPoiBox::set_left(::google::protobuf::int32 value) {
  set_has_left();
  left_ = value;
}

// required sint32 top = 3;
inline bool OsmAndPoiBox::has_top() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OsmAndPoiBox::set_has_top() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OsmAndPoiBox::clear_has_top() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OsmAndPoiBox::clear_top() {
  top_ = 0;
  clear_has_top();
}
inline ::google::protobuf::int32 OsmAndPoiBox::top() const {
  return top_;
}
inline void OsmAndPoiBox::set_top(::google::protobuf::int32 value) {
  set_has_top();
  top_ = value;
}

// optional .OsmAnd.OBF.OsmAndPoiCategories categories = 4;
inline bool OsmAndPoiBox::has_categories() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OsmAndPoiBox::set_has_categories() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OsmAndPoiBox::clear_has_categories() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OsmAndPoiBox::clear_categories() {
  if (categories_ != NULL) categories_->::OsmAnd::OBF::OsmAndPoiCategories::Clear();
  clear_has_categories();
}
inline const ::OsmAnd::OBF::OsmAndPoiCategories& OsmAndPoiBox::categories() const {
  return categories_ != NULL ? *categories_ : *default_instance_->categories_;
}
inline ::OsmAnd::OBF::OsmAndPoiCategories* OsmAndPoiBox::mutable_categories() {
  set_has_categories();
  if (categories_ == NULL) categories_ = new ::OsmAnd::OBF::OsmAndPoiCategories;
  return categories_;
}
inline ::OsmAnd::OBF::OsmAndPoiCategories* OsmAndPoiBox::release_categories() {
  clear_has_categories();
  ::OsmAnd::OBF::OsmAndPoiCategories* temp = categories_;
  categories_ = NULL;
  return temp;
}
inline void OsmAndPoiBox::set_allocated_categories(::OsmAnd::OBF::OsmAndPoiCategories* categories) {
  delete categories_;
  categories_ = categories;
  if (categories) {
    set_has_categories();
  } else {
    clear_has_categories();
  }
}

// optional .OsmAnd.OBF.OsmAndPoiTagGroups tagGroups = 8;
inline bool OsmAndPoiBox::has_taggroups() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OsmAndPoiBox::set_has_taggroups() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OsmAndPoiBox::clear_has_taggroups() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OsmAndPoiBox::clear_taggroups() {
  if (taggroups_ != NULL) taggroups_->::OsmAnd::OBF::OsmAndPoiTagGroups::Clear();
  clear_has_taggroups();
}
inline const ::OsmAnd::OBF::OsmAndPoiTagGroups& OsmAndPoiBox::taggroups() const {
  return taggroups_ != NULL ? *taggroups_ : *default_instance_->taggroups_;
}
inline ::OsmAnd::OBF::OsmAndPoiTagGroups* OsmAndPoiBox::mutable_taggroups() {
  set_has_taggroups();
  if (taggroups_ == NULL) taggroups_ = new ::OsmAnd::OBF::OsmAndPoiTagGroups;
  return taggroups_;
}
inline ::OsmAnd::OBF::OsmAndPoiTagGroups* OsmAndPoiBox::release_taggroups() {
  clear_has_taggroups();
  ::OsmAnd::OBF::OsmAndPoiTagGroups* temp = taggroups_;
  taggroups_ = NULL;
  return temp;
}
inline void OsmAndPoiBox::set_allocated_taggroups(::OsmAnd::OBF::OsmAndPoiTagGroups* taggroups) {
  delete taggroups_;
  taggroups_ = taggroups;
  if (taggroups) {
    set_has_taggroups();
  } else {
    clear_has_taggroups();
  }
}

// repeated .OsmAnd.OBF.OsmAndPoiBox subBoxes = 10;
inline int OsmAndPoiBox::subboxes_size() const {
  return subboxes_.size();
}
inline void OsmAndPoiBox::clear_subboxes() {
  subboxes_.Clear();
}
inline const ::OsmAnd::OBF::OsmAndPoiBox& OsmAndPoiBox::subboxes(int index) const {
  return subboxes_.Get(index);
}
inline ::OsmAnd::OBF::OsmAndPoiBox* OsmAndPoiBox::mutable_subboxes(int index) {
  return subboxes_.Mutable(index);
}
inline ::OsmAnd::OBF::OsmAndPoiBox* OsmAndPoiBox::add_subboxes() {
  return subboxes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiBox >&
OsmAndPoiBox::subboxes() const {
  return subboxes_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiBox >*
OsmAndPoiBox::mutable_subboxes() {
  return &subboxes_;
}

// optional fixed32 shiftToData = 14;
inline bool OsmAndPoiBox::has_shifttodata() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OsmAndPoiBox::set_has_shifttodata() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OsmAndPoiBox::clear_has_shifttodata() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OsmAndPoiBox::clear_shifttodata() {
  shifttodata_ = 0u;
  clear_has_shifttodata();
}
inline ::google::protobuf::uint32 OsmAndPoiBox::shifttodata() const {
  return shifttodata_;
}
inline void OsmAndPoiBox::set_shifttodata(::google::protobuf::uint32 value) {
  set_has_shifttodata();
  shifttodata_ = value;
}

// -------------------------------------------------------------------

// OsmAndPoiCategories

// repeated uint32 categories = 3;
inline int OsmAndPoiCategories::categories_size() const {
  return categories_.size();
}
inline void OsmAndPoiCategories::clear_categories() {
  categories_.Clear();
}
inline ::google::protobuf::uint32 OsmAndPoiCategories::categories(int index) const {
  return categories_.Get(index);
}
inline void OsmAndPoiCategories::set_categories(int index, ::google::protobuf::uint32 value) {
  categories_.Set(index, value);
}
inline void OsmAndPoiCategories::add_categories(::google::protobuf::uint32 value) {
  categories_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
OsmAndPoiCategories::categories() const {
  return categories_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
OsmAndPoiCategories::mutable_categories() {
  return &categories_;
}

// repeated uint32 subcategories = 5;
inline int OsmAndPoiCategories::subcategories_size() const {
  return subcategories_.size();
}
inline void OsmAndPoiCategories::clear_subcategories() {
  subcategories_.Clear();
}
inline ::google::protobuf::uint32 OsmAndPoiCategories::subcategories(int index) const {
  return subcategories_.Get(index);
}
inline void OsmAndPoiCategories::set_subcategories(int index, ::google::protobuf::uint32 value) {
  subcategories_.Set(index, value);
}
inline void OsmAndPoiCategories::add_subcategories(::google::protobuf::uint32 value) {
  subcategories_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
OsmAndPoiCategories::subcategories() const {
  return subcategories_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
OsmAndPoiCategories::mutable_subcategories() {
  return &subcategories_;
}

// -------------------------------------------------------------------

// OsmAndPoiBoxData

// optional uint32 zoom = 1;
inline bool OsmAndPoiBoxData::has_zoom() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsmAndPoiBoxData::set_has_zoom() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsmAndPoiBoxData::clear_has_zoom() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsmAndPoiBoxData::clear_zoom() {
  zoom_ = 0u;
  clear_has_zoom();
}
inline ::google::protobuf::uint32 OsmAndPoiBoxData::zoom() const {
  return zoom_;
}
inline void OsmAndPoiBoxData::set_zoom(::google::protobuf::uint32 value) {
  set_has_zoom();
  zoom_ = value;
}

// optional uint32 x = 2;
inline bool OsmAndPoiBoxData::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OsmAndPoiBoxData::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OsmAndPoiBoxData::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OsmAndPoiBoxData::clear_x() {
  x_ = 0u;
  clear_has_x();
}
inline ::google::protobuf::uint32 OsmAndPoiBoxData::x() const {
  return x_;
}
inline void OsmAndPoiBoxData::set_x(::google::protobuf::uint32 value) {
  set_has_x();
  x_ = value;
}

// optional uint32 y = 3;
inline bool OsmAndPoiBoxData::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OsmAndPoiBoxData::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OsmAndPoiBoxData::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OsmAndPoiBoxData::clear_y() {
  y_ = 0u;
  clear_has_y();
}
inline ::google::protobuf::uint32 OsmAndPoiBoxData::y() const {
  return y_;
}
inline void OsmAndPoiBoxData::set_y(::google::protobuf::uint32 value) {
  set_has_y();
  y_ = value;
}

// repeated .OsmAnd.OBF.OsmAndPoiBoxDataAtom poiData = 5;
inline int OsmAndPoiBoxData::poidata_size() const {
  return poidata_.size();
}
inline void OsmAndPoiBoxData::clear_poidata() {
  poidata_.Clear();
}
inline const ::OsmAnd::OBF::OsmAndPoiBoxDataAtom& OsmAndPoiBoxData::poidata(int index) const {
  return poidata_.Get(index);
}
inline ::OsmAnd::OBF::OsmAndPoiBoxDataAtom* OsmAndPoiBoxData::mutable_poidata(int index) {
  return poidata_.Mutable(index);
}
inline ::OsmAnd::OBF::OsmAndPoiBoxDataAtom* OsmAndPoiBoxData::add_poidata() {
  return poidata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiBoxDataAtom >&
OsmAndPoiBoxData::poidata() const {
  return poidata_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndPoiBoxDataAtom >*
OsmAndPoiBoxData::mutable_poidata() {
  return &poidata_;
}

// -------------------------------------------------------------------

// OsmAndPoiBoxDataAtom

// required sint32 dx = 2;
inline bool OsmAndPoiBoxDataAtom::has_dx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsmAndPoiBoxDataAtom::set_has_dx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsmAndPoiBoxDataAtom::clear_has_dx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsmAndPoiBoxDataAtom::clear_dx() {
  dx_ = 0;
  clear_has_dx();
}
inline ::google::protobuf::int32 OsmAndPoiBoxDataAtom::dx() const {
  return dx_;
}
inline void OsmAndPoiBoxDataAtom::set_dx(::google::protobuf::int32 value) {
  set_has_dx();
  dx_ = value;
}

// required sint32 dy = 3;
inline bool OsmAndPoiBoxDataAtom::has_dy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OsmAndPoiBoxDataAtom::set_has_dy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OsmAndPoiBoxDataAtom::clear_has_dy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OsmAndPoiBoxDataAtom::clear_dy() {
  dy_ = 0;
  clear_has_dy();
}
inline ::google::protobuf::int32 OsmAndPoiBoxDataAtom::dy() const {
  return dy_;
}
inline void OsmAndPoiBoxDataAtom::set_dy(::google::protobuf::int32 value) {
  set_has_dy();
  dy_ = value;
}

// repeated uint32 categories = 4;
inline int OsmAndPoiBoxDataAtom::categories_size() const {
  return categories_.size();
}
inline void OsmAndPoiBoxDataAtom::clear_categories() {
  categories_.Clear();
}
inline ::google::protobuf::uint32 OsmAndPoiBoxDataAtom::categories(int index) const {
  return categories_.Get(index);
}
inline void OsmAndPoiBoxDataAtom::set_categories(int index, ::google::protobuf::uint32 value) {
  categories_.Set(index, value);
}
inline void OsmAndPoiBoxDataAtom::add_categories(::google::protobuf::uint32 value) {
  categories_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
OsmAndPoiBoxDataAtom::categories() const {
  return categories_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
OsmAndPoiBoxDataAtom::mutable_categories() {
  return &categories_;
}

// repeated uint32 subcategories = 5;
inline int OsmAndPoiBoxDataAtom::subcategories_size() const {
  return subcategories_.size();
}
inline void OsmAndPoiBoxDataAtom::clear_subcategories() {
  subcategories_.Clear();
}
inline ::google::protobuf::uint32 OsmAndPoiBoxDataAtom::subcategories(int index) const {
  return subcategories_.Get(index);
}
inline void OsmAndPoiBoxDataAtom::set_subcategories(int index, ::google::protobuf::uint32 value) {
  subcategories_.Set(index, value);
}
inline void OsmAndPoiBoxDataAtom::add_subcategories(::google::protobuf::uint32 value) {
  subcategories_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
OsmAndPoiBoxDataAtom::subcategories() const {
  return subcategories_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
OsmAndPoiBoxDataAtom::mutable_subcategories() {
  return &subcategories_;
}

// optional string name = 6;
inline bool OsmAndPoiBoxDataAtom::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OsmAndPoiBoxDataAtom::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OsmAndPoiBoxDataAtom::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OsmAndPoiBoxDataAtom::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& OsmAndPoiBoxDataAtom::name() const {
  return *name_;
}
inline void OsmAndPoiBoxDataAtom::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndPoiBoxDataAtom::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* OsmAndPoiBoxDataAtom::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OsmAndPoiBoxDataAtom::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nameEn = 7;
inline bool OsmAndPoiBoxDataAtom::has_nameen() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OsmAndPoiBoxDataAtom::set_has_nameen() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OsmAndPoiBoxDataAtom::clear_has_nameen() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OsmAndPoiBoxDataAtom::clear_nameen() {
  if (nameen_ != &::google::protobuf::internal::kEmptyString) {
    nameen_->clear();
  }
  clear_has_nameen();
}
inline const ::std::string& OsmAndPoiBoxDataAtom::nameen() const {
  return *nameen_;
}
inline void OsmAndPoiBoxDataAtom::set_nameen(const ::std::string& value) {
  set_has_nameen();
  if (nameen_ == &::google::protobuf::internal::kEmptyString) {
    nameen_ = new ::std::string;
  }
  nameen_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_nameen(const char* value) {
  set_has_nameen();
  if (nameen_ == &::google::protobuf::internal::kEmptyString) {
    nameen_ = new ::std::string;
  }
  nameen_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_nameen(const char* value, size_t size) {
  set_has_nameen();
  if (nameen_ == &::google::protobuf::internal::kEmptyString) {
    nameen_ = new ::std::string;
  }
  nameen_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndPoiBoxDataAtom::mutable_nameen() {
  set_has_nameen();
  if (nameen_ == &::google::protobuf::internal::kEmptyString) {
    nameen_ = new ::std::string;
  }
  return nameen_;
}
inline ::std::string* OsmAndPoiBoxDataAtom::release_nameen() {
  clear_has_nameen();
  if (nameen_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nameen_;
    nameen_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OsmAndPoiBoxDataAtom::set_allocated_nameen(::std::string* nameen) {
  if (nameen_ != &::google::protobuf::internal::kEmptyString) {
    delete nameen_;
  }
  if (nameen) {
    set_has_nameen();
    nameen_ = nameen;
  } else {
    clear_has_nameen();
    nameen_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 id = 8;
inline bool OsmAndPoiBoxDataAtom::has_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OsmAndPoiBoxDataAtom::set_has_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OsmAndPoiBoxDataAtom::clear_has_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OsmAndPoiBoxDataAtom::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 OsmAndPoiBoxDataAtom::id() const {
  return id_;
}
inline void OsmAndPoiBoxDataAtom::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional string openingHours = 10;
inline bool OsmAndPoiBoxDataAtom::has_openinghours() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OsmAndPoiBoxDataAtom::set_has_openinghours() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OsmAndPoiBoxDataAtom::clear_has_openinghours() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OsmAndPoiBoxDataAtom::clear_openinghours() {
  if (openinghours_ != &::google::protobuf::internal::kEmptyString) {
    openinghours_->clear();
  }
  clear_has_openinghours();
}
inline const ::std::string& OsmAndPoiBoxDataAtom::openinghours() const {
  return *openinghours_;
}
inline void OsmAndPoiBoxDataAtom::set_openinghours(const ::std::string& value) {
  set_has_openinghours();
  if (openinghours_ == &::google::protobuf::internal::kEmptyString) {
    openinghours_ = new ::std::string;
  }
  openinghours_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_openinghours(const char* value) {
  set_has_openinghours();
  if (openinghours_ == &::google::protobuf::internal::kEmptyString) {
    openinghours_ = new ::std::string;
  }
  openinghours_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_openinghours(const char* value, size_t size) {
  set_has_openinghours();
  if (openinghours_ == &::google::protobuf::internal::kEmptyString) {
    openinghours_ = new ::std::string;
  }
  openinghours_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndPoiBoxDataAtom::mutable_openinghours() {
  set_has_openinghours();
  if (openinghours_ == &::google::protobuf::internal::kEmptyString) {
    openinghours_ = new ::std::string;
  }
  return openinghours_;
}
inline ::std::string* OsmAndPoiBoxDataAtom::release_openinghours() {
  clear_has_openinghours();
  if (openinghours_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = openinghours_;
    openinghours_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OsmAndPoiBoxDataAtom::set_allocated_openinghours(::std::string* openinghours) {
  if (openinghours_ != &::google::protobuf::internal::kEmptyString) {
    delete openinghours_;
  }
  if (openinghours) {
    set_has_openinghours();
    openinghours_ = openinghours;
  } else {
    clear_has_openinghours();
    openinghours_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string site = 11;
inline bool OsmAndPoiBoxDataAtom::has_site() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OsmAndPoiBoxDataAtom::set_has_site() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OsmAndPoiBoxDataAtom::clear_has_site() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OsmAndPoiBoxDataAtom::clear_site() {
  if (site_ != &::google::protobuf::internal::kEmptyString) {
    site_->clear();
  }
  clear_has_site();
}
inline const ::std::string& OsmAndPoiBoxDataAtom::site() const {
  return *site_;
}
inline void OsmAndPoiBoxDataAtom::set_site(const ::std::string& value) {
  set_has_site();
  if (site_ == &::google::protobuf::internal::kEmptyString) {
    site_ = new ::std::string;
  }
  site_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_site(const char* value) {
  set_has_site();
  if (site_ == &::google::protobuf::internal::kEmptyString) {
    site_ = new ::std::string;
  }
  site_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_site(const char* value, size_t size) {
  set_has_site();
  if (site_ == &::google::protobuf::internal::kEmptyString) {
    site_ = new ::std::string;
  }
  site_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndPoiBoxDataAtom::mutable_site() {
  set_has_site();
  if (site_ == &::google::protobuf::internal::kEmptyString) {
    site_ = new ::std::string;
  }
  return site_;
}
inline ::std::string* OsmAndPoiBoxDataAtom::release_site() {
  clear_has_site();
  if (site_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = site_;
    site_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OsmAndPoiBoxDataAtom::set_allocated_site(::std::string* site) {
  if (site_ != &::google::protobuf::internal::kEmptyString) {
    delete site_;
  }
  if (site) {
    set_has_site();
    site_ = site;
  } else {
    clear_has_site();
    site_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string phone = 12;
inline bool OsmAndPoiBoxDataAtom::has_phone() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void OsmAndPoiBoxDataAtom::set_has_phone() {
  _has_bits_[0] |= 0x00000200u;
}
inline void OsmAndPoiBoxDataAtom::clear_has_phone() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void OsmAndPoiBoxDataAtom::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& OsmAndPoiBoxDataAtom::phone() const {
  return *phone_;
}
inline void OsmAndPoiBoxDataAtom::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndPoiBoxDataAtom::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* OsmAndPoiBoxDataAtom::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OsmAndPoiBoxDataAtom::set_allocated_phone(::std::string* phone) {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_;
  }
  if (phone) {
    set_has_phone();
    phone_ = phone;
  } else {
    clear_has_phone();
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string note = 13;
inline bool OsmAndPoiBoxDataAtom::has_note() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void OsmAndPoiBoxDataAtom::set_has_note() {
  _has_bits_[0] |= 0x00000400u;
}
inline void OsmAndPoiBoxDataAtom::clear_has_note() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void OsmAndPoiBoxDataAtom::clear_note() {
  if (note_ != &::google::protobuf::internal::kEmptyString) {
    note_->clear();
  }
  clear_has_note();
}
inline const ::std::string& OsmAndPoiBoxDataAtom::note() const {
  return *note_;
}
inline void OsmAndPoiBoxDataAtom::set_note(const ::std::string& value) {
  set_has_note();
  if (note_ == &::google::protobuf::internal::kEmptyString) {
    note_ = new ::std::string;
  }
  note_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_note(const char* value) {
  set_has_note();
  if (note_ == &::google::protobuf::internal::kEmptyString) {
    note_ = new ::std::string;
  }
  note_->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_note(const char* value, size_t size) {
  set_has_note();
  if (note_ == &::google::protobuf::internal::kEmptyString) {
    note_ = new ::std::string;
  }
  note_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndPoiBoxDataAtom::mutable_note() {
  set_has_note();
  if (note_ == &::google::protobuf::internal::kEmptyString) {
    note_ = new ::std::string;
  }
  return note_;
}
inline ::std::string* OsmAndPoiBoxDataAtom::release_note() {
  clear_has_note();
  if (note_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = note_;
    note_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OsmAndPoiBoxDataAtom::set_allocated_note(::std::string* note) {
  if (note_ != &::google::protobuf::internal::kEmptyString) {
    delete note_;
  }
  if (note) {
    set_has_note();
    note_ = note;
  } else {
    clear_has_note();
    note_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated uint32 textCategories = 14;
inline int OsmAndPoiBoxDataAtom::textcategories_size() const {
  return textcategories_.size();
}
inline void OsmAndPoiBoxDataAtom::clear_textcategories() {
  textcategories_.Clear();
}
inline ::google::protobuf::uint32 OsmAndPoiBoxDataAtom::textcategories(int index) const {
  return textcategories_.Get(index);
}
inline void OsmAndPoiBoxDataAtom::set_textcategories(int index, ::google::protobuf::uint32 value) {
  textcategories_.Set(index, value);
}
inline void OsmAndPoiBoxDataAtom::add_textcategories(::google::protobuf::uint32 value) {
  textcategories_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
OsmAndPoiBoxDataAtom::textcategories() const {
  return textcategories_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
OsmAndPoiBoxDataAtom::mutable_textcategories() {
  return &textcategories_;
}

// repeated string textValues = 15;
inline int OsmAndPoiBoxDataAtom::textvalues_size() const {
  return textvalues_.size();
}
inline void OsmAndPoiBoxDataAtom::clear_textvalues() {
  textvalues_.Clear();
}
inline const ::std::string& OsmAndPoiBoxDataAtom::textvalues(int index) const {
  return textvalues_.Get(index);
}
inline ::std::string* OsmAndPoiBoxDataAtom::mutable_textvalues(int index) {
  return textvalues_.Mutable(index);
}
inline void OsmAndPoiBoxDataAtom::set_textvalues(int index, const ::std::string& value) {
  textvalues_.Mutable(index)->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_textvalues(int index, const char* value) {
  textvalues_.Mutable(index)->assign(value);
}
inline void OsmAndPoiBoxDataAtom::set_textvalues(int index, const char* value, size_t size) {
  textvalues_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndPoiBoxDataAtom::add_textvalues() {
  return textvalues_.Add();
}
inline void OsmAndPoiBoxDataAtom::add_textvalues(const ::std::string& value) {
  textvalues_.Add()->assign(value);
}
inline void OsmAndPoiBoxDataAtom::add_textvalues(const char* value) {
  textvalues_.Add()->assign(value);
}
inline void OsmAndPoiBoxDataAtom::add_textvalues(const char* value, size_t size) {
  textvalues_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OsmAndPoiBoxDataAtom::textvalues() const {
  return textvalues_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OsmAndPoiBoxDataAtom::mutable_textvalues() {
  return &textvalues_;
}

// optional int32 precisionXY = 16;
inline bool OsmAndPoiBoxDataAtom::has_precisionxy() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void OsmAndPoiBoxDataAtom::set_has_precisionxy() {
  _has_bits_[0] |= 0x00002000u;
}
inline void OsmAndPoiBoxDataAtom::clear_has_precisionxy() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void OsmAndPoiBoxDataAtom::clear_precisionxy() {
  precisionxy_ = 0;
  clear_has_precisionxy();
}
inline ::google::protobuf::int32 OsmAndPoiBoxDataAtom::precisionxy() const {
  return precisionxy_;
}
inline void OsmAndPoiBoxDataAtom::set_precisionxy(::google::protobuf::int32 value) {
  set_has_precisionxy();
  precisionxy_ = value;
}

// repeated uint32 tagGroups = 17 [packed = true];
inline int OsmAndPoiBoxDataAtom::taggroups_size() const {
  return taggroups_.size();
}
inline void OsmAndPoiBoxDataAtom::clear_taggroups() {
  taggroups_.Clear();
}
inline ::google::protobuf::uint32 OsmAndPoiBoxDataAtom::taggroups(int index) const {
  return taggroups_.Get(index);
}
inline void OsmAndPoiBoxDataAtom::set_taggroups(int index, ::google::protobuf::uint32 value) {
  taggroups_.Set(index, value);
}
inline void OsmAndPoiBoxDataAtom::add_taggroups(::google::protobuf::uint32 value) {
  taggroups_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
OsmAndPoiBoxDataAtom::taggroups() const {
  return taggroups_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
OsmAndPoiBoxDataAtom::mutable_taggroups() {
  return &taggroups_;
}

// -------------------------------------------------------------------

// IdTable

// repeated sint64 routeId = 1;
inline int IdTable::routeid_size() const {
  return routeid_.size();
}
inline void IdTable::clear_routeid() {
  routeid_.Clear();
}
inline ::google::protobuf::int64 IdTable::routeid(int index) const {
  return routeid_.Get(index);
}
inline void IdTable::set_routeid(int index, ::google::protobuf::int64 value) {
  routeid_.Set(index, value);
}
inline void IdTable::add_routeid(::google::protobuf::int64 value) {
  routeid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
IdTable::routeid() const {
  return routeid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
IdTable::mutable_routeid() {
  return &routeid_;
}

// -------------------------------------------------------------------

// RestrictionData

// required int32 type = 1;
inline bool RestrictionData::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RestrictionData::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RestrictionData::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RestrictionData::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 RestrictionData::type() const {
  return type_;
}
inline void RestrictionData::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int32 from = 2;
inline bool RestrictionData::has_from() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RestrictionData::set_has_from() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RestrictionData::clear_has_from() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RestrictionData::clear_from() {
  from_ = 0;
  clear_has_from();
}
inline ::google::protobuf::int32 RestrictionData::from() const {
  return from_;
}
inline void RestrictionData::set_from(::google::protobuf::int32 value) {
  set_has_from();
  from_ = value;
}

// required int32 to = 3;
inline bool RestrictionData::has_to() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RestrictionData::set_has_to() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RestrictionData::clear_has_to() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RestrictionData::clear_to() {
  to_ = 0;
  clear_has_to();
}
inline ::google::protobuf::int32 RestrictionData::to() const {
  return to_;
}
inline void RestrictionData::set_to(::google::protobuf::int32 value) {
  set_has_to();
  to_ = value;
}

// optional int32 via = 4;
inline bool RestrictionData::has_via() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RestrictionData::set_has_via() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RestrictionData::clear_has_via() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RestrictionData::clear_via() {
  via_ = 0;
  clear_has_via();
}
inline ::google::protobuf::int32 RestrictionData::via() const {
  return via_;
}
inline void RestrictionData::set_via(::google::protobuf::int32 value) {
  set_has_via();
  via_ = value;
}

// -------------------------------------------------------------------

// RouteData

// required bytes points = 1;
inline bool RouteData::has_points() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RouteData::set_has_points() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RouteData::clear_has_points() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RouteData::clear_points() {
  if (points_ != &::google::protobuf::internal::kEmptyString) {
    points_->clear();
  }
  clear_has_points();
}
inline const ::std::string& RouteData::points() const {
  return *points_;
}
inline void RouteData::set_points(const ::std::string& value) {
  set_has_points();
  if (points_ == &::google::protobuf::internal::kEmptyString) {
    points_ = new ::std::string;
  }
  points_->assign(value);
}
inline void RouteData::set_points(const char* value) {
  set_has_points();
  if (points_ == &::google::protobuf::internal::kEmptyString) {
    points_ = new ::std::string;
  }
  points_->assign(value);
}
inline void RouteData::set_points(const void* value, size_t size) {
  set_has_points();
  if (points_ == &::google::protobuf::internal::kEmptyString) {
    points_ = new ::std::string;
  }
  points_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RouteData::mutable_points() {
  set_has_points();
  if (points_ == &::google::protobuf::internal::kEmptyString) {
    points_ = new ::std::string;
  }
  return points_;
}
inline ::std::string* RouteData::release_points() {
  clear_has_points();
  if (points_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = points_;
    points_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RouteData::set_allocated_points(::std::string* points) {
  if (points_ != &::google::protobuf::internal::kEmptyString) {
    delete points_;
  }
  if (points) {
    set_has_points();
    points_ = points;
  } else {
    clear_has_points();
    points_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes pointTypes = 4;
inline bool RouteData::has_pointtypes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RouteData::set_has_pointtypes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RouteData::clear_has_pointtypes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RouteData::clear_pointtypes() {
  if (pointtypes_ != &::google::protobuf::internal::kEmptyString) {
    pointtypes_->clear();
  }
  clear_has_pointtypes();
}
inline const ::std::string& RouteData::pointtypes() const {
  return *pointtypes_;
}
inline void RouteData::set_pointtypes(const ::std::string& value) {
  set_has_pointtypes();
  if (pointtypes_ == &::google::protobuf::internal::kEmptyString) {
    pointtypes_ = new ::std::string;
  }
  pointtypes_->assign(value);
}
inline void RouteData::set_pointtypes(const char* value) {
  set_has_pointtypes();
  if (pointtypes_ == &::google::protobuf::internal::kEmptyString) {
    pointtypes_ = new ::std::string;
  }
  pointtypes_->assign(value);
}
inline void RouteData::set_pointtypes(const void* value, size_t size) {
  set_has_pointtypes();
  if (pointtypes_ == &::google::protobuf::internal::kEmptyString) {
    pointtypes_ = new ::std::string;
  }
  pointtypes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RouteData::mutable_pointtypes() {
  set_has_pointtypes();
  if (pointtypes_ == &::google::protobuf::internal::kEmptyString) {
    pointtypes_ = new ::std::string;
  }
  return pointtypes_;
}
inline ::std::string* RouteData::release_pointtypes() {
  clear_has_pointtypes();
  if (pointtypes_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pointtypes_;
    pointtypes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RouteData::set_allocated_pointtypes(::std::string* pointtypes) {
  if (pointtypes_ != &::google::protobuf::internal::kEmptyString) {
    delete pointtypes_;
  }
  if (pointtypes) {
    set_has_pointtypes();
    pointtypes_ = pointtypes;
  } else {
    clear_has_pointtypes();
    pointtypes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes pointNames = 5;
inline bool RouteData::has_pointnames() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RouteData::set_has_pointnames() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RouteData::clear_has_pointnames() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RouteData::clear_pointnames() {
  if (pointnames_ != &::google::protobuf::internal::kEmptyString) {
    pointnames_->clear();
  }
  clear_has_pointnames();
}
inline const ::std::string& RouteData::pointnames() const {
  return *pointnames_;
}
inline void RouteData::set_pointnames(const ::std::string& value) {
  set_has_pointnames();
  if (pointnames_ == &::google::protobuf::internal::kEmptyString) {
    pointnames_ = new ::std::string;
  }
  pointnames_->assign(value);
}
inline void RouteData::set_pointnames(const char* value) {
  set_has_pointnames();
  if (pointnames_ == &::google::protobuf::internal::kEmptyString) {
    pointnames_ = new ::std::string;
  }
  pointnames_->assign(value);
}
inline void RouteData::set_pointnames(const void* value, size_t size) {
  set_has_pointnames();
  if (pointnames_ == &::google::protobuf::internal::kEmptyString) {
    pointnames_ = new ::std::string;
  }
  pointnames_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RouteData::mutable_pointnames() {
  set_has_pointnames();
  if (pointnames_ == &::google::protobuf::internal::kEmptyString) {
    pointnames_ = new ::std::string;
  }
  return pointnames_;
}
inline ::std::string* RouteData::release_pointnames() {
  clear_has_pointnames();
  if (pointnames_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pointnames_;
    pointnames_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RouteData::set_allocated_pointnames(::std::string* pointnames) {
  if (pointnames_ != &::google::protobuf::internal::kEmptyString) {
    delete pointnames_;
  }
  if (pointnames) {
    set_has_pointnames();
    pointnames_ = pointnames;
  } else {
    clear_has_pointnames();
    pointnames_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes types = 7;
inline bool RouteData::has_types() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RouteData::set_has_types() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RouteData::clear_has_types() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RouteData::clear_types() {
  if (types_ != &::google::protobuf::internal::kEmptyString) {
    types_->clear();
  }
  clear_has_types();
}
inline const ::std::string& RouteData::types() const {
  return *types_;
}
inline void RouteData::set_types(const ::std::string& value) {
  set_has_types();
  if (types_ == &::google::protobuf::internal::kEmptyString) {
    types_ = new ::std::string;
  }
  types_->assign(value);
}
inline void RouteData::set_types(const char* value) {
  set_has_types();
  if (types_ == &::google::protobuf::internal::kEmptyString) {
    types_ = new ::std::string;
  }
  types_->assign(value);
}
inline void RouteData::set_types(const void* value, size_t size) {
  set_has_types();
  if (types_ == &::google::protobuf::internal::kEmptyString) {
    types_ = new ::std::string;
  }
  types_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RouteData::mutable_types() {
  set_has_types();
  if (types_ == &::google::protobuf::internal::kEmptyString) {
    types_ = new ::std::string;
  }
  return types_;
}
inline ::std::string* RouteData::release_types() {
  clear_has_types();
  if (types_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = types_;
    types_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RouteData::set_allocated_types(::std::string* types) {
  if (types_ != &::google::protobuf::internal::kEmptyString) {
    delete types_;
  }
  if (types) {
    set_has_types();
    types_ = types;
  } else {
    clear_has_types();
    types_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 routeId = 12;
inline bool RouteData::has_routeid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RouteData::set_has_routeid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RouteData::clear_has_routeid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RouteData::clear_routeid() {
  routeid_ = 0;
  clear_has_routeid();
}
inline ::google::protobuf::int32 RouteData::routeid() const {
  return routeid_;
}
inline void RouteData::set_routeid(::google::protobuf::int32 value) {
  set_has_routeid();
  routeid_ = value;
}

// optional bytes stringNames = 14;
inline bool RouteData::has_stringnames() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RouteData::set_has_stringnames() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RouteData::clear_has_stringnames() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RouteData::clear_stringnames() {
  if (stringnames_ != &::google::protobuf::internal::kEmptyString) {
    stringnames_->clear();
  }
  clear_has_stringnames();
}
inline const ::std::string& RouteData::stringnames() const {
  return *stringnames_;
}
inline void RouteData::set_stringnames(const ::std::string& value) {
  set_has_stringnames();
  if (stringnames_ == &::google::protobuf::internal::kEmptyString) {
    stringnames_ = new ::std::string;
  }
  stringnames_->assign(value);
}
inline void RouteData::set_stringnames(const char* value) {
  set_has_stringnames();
  if (stringnames_ == &::google::protobuf::internal::kEmptyString) {
    stringnames_ = new ::std::string;
  }
  stringnames_->assign(value);
}
inline void RouteData::set_stringnames(const void* value, size_t size) {
  set_has_stringnames();
  if (stringnames_ == &::google::protobuf::internal::kEmptyString) {
    stringnames_ = new ::std::string;
  }
  stringnames_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RouteData::mutable_stringnames() {
  set_has_stringnames();
  if (stringnames_ == &::google::protobuf::internal::kEmptyString) {
    stringnames_ = new ::std::string;
  }
  return stringnames_;
}
inline ::std::string* RouteData::release_stringnames() {
  clear_has_stringnames();
  if (stringnames_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stringnames_;
    stringnames_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RouteData::set_allocated_stringnames(::std::string* stringnames) {
  if (stringnames_ != &::google::protobuf::internal::kEmptyString) {
    delete stringnames_;
  }
  if (stringnames) {
    set_has_stringnames();
    stringnames_ = stringnames;
  } else {
    clear_has_stringnames();
    stringnames_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// OsmAndRoutingIndex_RouteEncodingRule

// required string tag = 3;
inline bool OsmAndRoutingIndex_RouteEncodingRule::has_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsmAndRoutingIndex_RouteEncodingRule::set_has_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsmAndRoutingIndex_RouteEncodingRule::clear_has_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsmAndRoutingIndex_RouteEncodingRule::clear_tag() {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& OsmAndRoutingIndex_RouteEncodingRule::tag() const {
  return *tag_;
}
inline void OsmAndRoutingIndex_RouteEncodingRule::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void OsmAndRoutingIndex_RouteEncodingRule::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void OsmAndRoutingIndex_RouteEncodingRule::set_tag(const char* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndRoutingIndex_RouteEncodingRule::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  return tag_;
}
inline ::std::string* OsmAndRoutingIndex_RouteEncodingRule::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OsmAndRoutingIndex_RouteEncodingRule::set_allocated_tag(::std::string* tag) {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    delete tag_;
  }
  if (tag) {
    set_has_tag();
    tag_ = tag;
  } else {
    clear_has_tag();
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 5;
inline bool OsmAndRoutingIndex_RouteEncodingRule::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OsmAndRoutingIndex_RouteEncodingRule::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OsmAndRoutingIndex_RouteEncodingRule::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OsmAndRoutingIndex_RouteEncodingRule::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& OsmAndRoutingIndex_RouteEncodingRule::value() const {
  return *value_;
}
inline void OsmAndRoutingIndex_RouteEncodingRule::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void OsmAndRoutingIndex_RouteEncodingRule::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void OsmAndRoutingIndex_RouteEncodingRule::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndRoutingIndex_RouteEncodingRule::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* OsmAndRoutingIndex_RouteEncodingRule::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OsmAndRoutingIndex_RouteEncodingRule::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 id = 7;
inline bool OsmAndRoutingIndex_RouteEncodingRule::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OsmAndRoutingIndex_RouteEncodingRule::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OsmAndRoutingIndex_RouteEncodingRule::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OsmAndRoutingIndex_RouteEncodingRule::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 OsmAndRoutingIndex_RouteEncodingRule::id() const {
  return id_;
}
inline void OsmAndRoutingIndex_RouteEncodingRule::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// OsmAndRoutingIndex_RouteDataBox

// required sint32 left = 1;
inline bool OsmAndRoutingIndex_RouteDataBox::has_left() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsmAndRoutingIndex_RouteDataBox::set_has_left() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsmAndRoutingIndex_RouteDataBox::clear_has_left() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsmAndRoutingIndex_RouteDataBox::clear_left() {
  left_ = 0;
  clear_has_left();
}
inline ::google::protobuf::int32 OsmAndRoutingIndex_RouteDataBox::left() const {
  return left_;
}
inline void OsmAndRoutingIndex_RouteDataBox::set_left(::google::protobuf::int32 value) {
  set_has_left();
  left_ = value;
}

// required sint32 right = 2;
inline bool OsmAndRoutingIndex_RouteDataBox::has_right() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OsmAndRoutingIndex_RouteDataBox::set_has_right() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OsmAndRoutingIndex_RouteDataBox::clear_has_right() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OsmAndRoutingIndex_RouteDataBox::clear_right() {
  right_ = 0;
  clear_has_right();
}
inline ::google::protobuf::int32 OsmAndRoutingIndex_RouteDataBox::right() const {
  return right_;
}
inline void OsmAndRoutingIndex_RouteDataBox::set_right(::google::protobuf::int32 value) {
  set_has_right();
  right_ = value;
}

// required sint32 top = 3;
inline bool OsmAndRoutingIndex_RouteDataBox::has_top() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OsmAndRoutingIndex_RouteDataBox::set_has_top() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OsmAndRoutingIndex_RouteDataBox::clear_has_top() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OsmAndRoutingIndex_RouteDataBox::clear_top() {
  top_ = 0;
  clear_has_top();
}
inline ::google::protobuf::int32 OsmAndRoutingIndex_RouteDataBox::top() const {
  return top_;
}
inline void OsmAndRoutingIndex_RouteDataBox::set_top(::google::protobuf::int32 value) {
  set_has_top();
  top_ = value;
}

// required sint32 bottom = 4;
inline bool OsmAndRoutingIndex_RouteDataBox::has_bottom() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OsmAndRoutingIndex_RouteDataBox::set_has_bottom() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OsmAndRoutingIndex_RouteDataBox::clear_has_bottom() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OsmAndRoutingIndex_RouteDataBox::clear_bottom() {
  bottom_ = 0;
  clear_has_bottom();
}
inline ::google::protobuf::int32 OsmAndRoutingIndex_RouteDataBox::bottom() const {
  return bottom_;
}
inline void OsmAndRoutingIndex_RouteDataBox::set_bottom(::google::protobuf::int32 value) {
  set_has_bottom();
  bottom_ = value;
}

// optional fixed32 shiftToData = 5;
inline bool OsmAndRoutingIndex_RouteDataBox::has_shifttodata() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OsmAndRoutingIndex_RouteDataBox::set_has_shifttodata() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OsmAndRoutingIndex_RouteDataBox::clear_has_shifttodata() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OsmAndRoutingIndex_RouteDataBox::clear_shifttodata() {
  shifttodata_ = 0u;
  clear_has_shifttodata();
}
inline ::google::protobuf::uint32 OsmAndRoutingIndex_RouteDataBox::shifttodata() const {
  return shifttodata_;
}
inline void OsmAndRoutingIndex_RouteDataBox::set_shifttodata(::google::protobuf::uint32 value) {
  set_has_shifttodata();
  shifttodata_ = value;
}

// repeated .OsmAnd.OBF.OsmAndRoutingIndex.RouteDataBox boxes = 7;
inline int OsmAndRoutingIndex_RouteDataBox::boxes_size() const {
  return boxes_.size();
}
inline void OsmAndRoutingIndex_RouteDataBox::clear_boxes() {
  boxes_.Clear();
}
inline const ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox& OsmAndRoutingIndex_RouteDataBox::boxes(int index) const {
  return boxes_.Get(index);
}
inline ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox* OsmAndRoutingIndex_RouteDataBox::mutable_boxes(int index) {
  return boxes_.Mutable(index);
}
inline ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox* OsmAndRoutingIndex_RouteDataBox::add_boxes() {
  return boxes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox >&
OsmAndRoutingIndex_RouteDataBox::boxes() const {
  return boxes_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox >*
OsmAndRoutingIndex_RouteDataBox::mutable_boxes() {
  return &boxes_;
}

// -------------------------------------------------------------------

// OsmAndRoutingIndex_RouteDataBlock

// optional .OsmAnd.OBF.IdTable idTable = 5;
inline bool OsmAndRoutingIndex_RouteDataBlock::has_idtable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsmAndRoutingIndex_RouteDataBlock::set_has_idtable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsmAndRoutingIndex_RouteDataBlock::clear_has_idtable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsmAndRoutingIndex_RouteDataBlock::clear_idtable() {
  if (idtable_ != NULL) idtable_->::OsmAnd::OBF::IdTable::Clear();
  clear_has_idtable();
}
inline const ::OsmAnd::OBF::IdTable& OsmAndRoutingIndex_RouteDataBlock::idtable() const {
  return idtable_ != NULL ? *idtable_ : *default_instance_->idtable_;
}
inline ::OsmAnd::OBF::IdTable* OsmAndRoutingIndex_RouteDataBlock::mutable_idtable() {
  set_has_idtable();
  if (idtable_ == NULL) idtable_ = new ::OsmAnd::OBF::IdTable;
  return idtable_;
}
inline ::OsmAnd::OBF::IdTable* OsmAndRoutingIndex_RouteDataBlock::release_idtable() {
  clear_has_idtable();
  ::OsmAnd::OBF::IdTable* temp = idtable_;
  idtable_ = NULL;
  return temp;
}
inline void OsmAndRoutingIndex_RouteDataBlock::set_allocated_idtable(::OsmAnd::OBF::IdTable* idtable) {
  delete idtable_;
  idtable_ = idtable;
  if (idtable) {
    set_has_idtable();
  } else {
    clear_has_idtable();
  }
}

// repeated .OsmAnd.OBF.RouteData dataObjects = 6;
inline int OsmAndRoutingIndex_RouteDataBlock::dataobjects_size() const {
  return dataobjects_.size();
}
inline void OsmAndRoutingIndex_RouteDataBlock::clear_dataobjects() {
  dataobjects_.Clear();
}
inline const ::OsmAnd::OBF::RouteData& OsmAndRoutingIndex_RouteDataBlock::dataobjects(int index) const {
  return dataobjects_.Get(index);
}
inline ::OsmAnd::OBF::RouteData* OsmAndRoutingIndex_RouteDataBlock::mutable_dataobjects(int index) {
  return dataobjects_.Mutable(index);
}
inline ::OsmAnd::OBF::RouteData* OsmAndRoutingIndex_RouteDataBlock::add_dataobjects() {
  return dataobjects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::RouteData >&
OsmAndRoutingIndex_RouteDataBlock::dataobjects() const {
  return dataobjects_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::RouteData >*
OsmAndRoutingIndex_RouteDataBlock::mutable_dataobjects() {
  return &dataobjects_;
}

// repeated .OsmAnd.OBF.RestrictionData restrictions = 7;
inline int OsmAndRoutingIndex_RouteDataBlock::restrictions_size() const {
  return restrictions_.size();
}
inline void OsmAndRoutingIndex_RouteDataBlock::clear_restrictions() {
  restrictions_.Clear();
}
inline const ::OsmAnd::OBF::RestrictionData& OsmAndRoutingIndex_RouteDataBlock::restrictions(int index) const {
  return restrictions_.Get(index);
}
inline ::OsmAnd::OBF::RestrictionData* OsmAndRoutingIndex_RouteDataBlock::mutable_restrictions(int index) {
  return restrictions_.Mutable(index);
}
inline ::OsmAnd::OBF::RestrictionData* OsmAndRoutingIndex_RouteDataBlock::add_restrictions() {
  return restrictions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::RestrictionData >&
OsmAndRoutingIndex_RouteDataBlock::restrictions() const {
  return restrictions_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::RestrictionData >*
OsmAndRoutingIndex_RouteDataBlock::mutable_restrictions() {
  return &restrictions_;
}

// optional .OsmAnd.OBF.StringTable stringTable = 8;
inline bool OsmAndRoutingIndex_RouteDataBlock::has_stringtable() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OsmAndRoutingIndex_RouteDataBlock::set_has_stringtable() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OsmAndRoutingIndex_RouteDataBlock::clear_has_stringtable() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OsmAndRoutingIndex_RouteDataBlock::clear_stringtable() {
  if (stringtable_ != NULL) stringtable_->::OsmAnd::OBF::StringTable::Clear();
  clear_has_stringtable();
}
inline const ::OsmAnd::OBF::StringTable& OsmAndRoutingIndex_RouteDataBlock::stringtable() const {
  return stringtable_ != NULL ? *stringtable_ : *default_instance_->stringtable_;
}
inline ::OsmAnd::OBF::StringTable* OsmAndRoutingIndex_RouteDataBlock::mutable_stringtable() {
  set_has_stringtable();
  if (stringtable_ == NULL) stringtable_ = new ::OsmAnd::OBF::StringTable;
  return stringtable_;
}
inline ::OsmAnd::OBF::StringTable* OsmAndRoutingIndex_RouteDataBlock::release_stringtable() {
  clear_has_stringtable();
  ::OsmAnd::OBF::StringTable* temp = stringtable_;
  stringtable_ = NULL;
  return temp;
}
inline void OsmAndRoutingIndex_RouteDataBlock::set_allocated_stringtable(::OsmAnd::OBF::StringTable* stringtable) {
  delete stringtable_;
  stringtable_ = stringtable;
  if (stringtable) {
    set_has_stringtable();
  } else {
    clear_has_stringtable();
  }
}

// -------------------------------------------------------------------

// OsmAndRoutingIndex

// required string name = 1;
inline bool OsmAndRoutingIndex::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsmAndRoutingIndex::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsmAndRoutingIndex::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsmAndRoutingIndex::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& OsmAndRoutingIndex::name() const {
  return *name_;
}
inline void OsmAndRoutingIndex::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndRoutingIndex::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndRoutingIndex::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndRoutingIndex::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* OsmAndRoutingIndex::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OsmAndRoutingIndex::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .OsmAnd.OBF.OsmAndRoutingIndex.RouteEncodingRule rules = 2;
inline int OsmAndRoutingIndex::rules_size() const {
  return rules_.size();
}
inline void OsmAndRoutingIndex::clear_rules() {
  rules_.Clear();
}
inline const ::OsmAnd::OBF::OsmAndRoutingIndex_RouteEncodingRule& OsmAndRoutingIndex::rules(int index) const {
  return rules_.Get(index);
}
inline ::OsmAnd::OBF::OsmAndRoutingIndex_RouteEncodingRule* OsmAndRoutingIndex::mutable_rules(int index) {
  return rules_.Mutable(index);
}
inline ::OsmAnd::OBF::OsmAndRoutingIndex_RouteEncodingRule* OsmAndRoutingIndex::add_rules() {
  return rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndRoutingIndex_RouteEncodingRule >&
OsmAndRoutingIndex::rules() const {
  return rules_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndRoutingIndex_RouteEncodingRule >*
OsmAndRoutingIndex::mutable_rules() {
  return &rules_;
}

// repeated .OsmAnd.OBF.OsmAndRoutingIndex.RouteDataBox rootBoxes = 3;
inline int OsmAndRoutingIndex::rootboxes_size() const {
  return rootboxes_.size();
}
inline void OsmAndRoutingIndex::clear_rootboxes() {
  rootboxes_.Clear();
}
inline const ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox& OsmAndRoutingIndex::rootboxes(int index) const {
  return rootboxes_.Get(index);
}
inline ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox* OsmAndRoutingIndex::mutable_rootboxes(int index) {
  return rootboxes_.Mutable(index);
}
inline ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox* OsmAndRoutingIndex::add_rootboxes() {
  return rootboxes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox >&
OsmAndRoutingIndex::rootboxes() const {
  return rootboxes_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox >*
OsmAndRoutingIndex::mutable_rootboxes() {
  return &rootboxes_;
}

// repeated .OsmAnd.OBF.OsmAndRoutingIndex.RouteDataBox basemapBoxes = 4;
inline int OsmAndRoutingIndex::basemapboxes_size() const {
  return basemapboxes_.size();
}
inline void OsmAndRoutingIndex::clear_basemapboxes() {
  basemapboxes_.Clear();
}
inline const ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox& OsmAndRoutingIndex::basemapboxes(int index) const {
  return basemapboxes_.Get(index);
}
inline ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox* OsmAndRoutingIndex::mutable_basemapboxes(int index) {
  return basemapboxes_.Mutable(index);
}
inline ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox* OsmAndRoutingIndex::add_basemapboxes() {
  return basemapboxes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox >&
OsmAndRoutingIndex::basemapboxes() const {
  return basemapboxes_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBox >*
OsmAndRoutingIndex::mutable_basemapboxes() {
  return &basemapboxes_;
}

// repeated .OsmAnd.OBF.OsmAndRoutingIndex.RouteDataBlock blocks = 5;
inline int OsmAndRoutingIndex::blocks_size() const {
  return blocks_.size();
}
inline void OsmAndRoutingIndex::clear_blocks() {
  blocks_.Clear();
}
inline const ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBlock& OsmAndRoutingIndex::blocks(int index) const {
  return blocks_.Get(index);
}
inline ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBlock* OsmAndRoutingIndex::mutable_blocks(int index) {
  return blocks_.Mutable(index);
}
inline ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBlock* OsmAndRoutingIndex::add_blocks() {
  return blocks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBlock >&
OsmAndRoutingIndex::blocks() const {
  return blocks_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndRoutingIndex_RouteDataBlock >*
OsmAndRoutingIndex::mutable_blocks() {
  return &blocks_;
}

// -------------------------------------------------------------------

// OsmAndHHRoutingIndex_HHRoutePointsBox

// required sint32 left = 2;
inline bool OsmAndHHRoutingIndex_HHRoutePointsBox::has_left() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsmAndHHRoutingIndex_HHRoutePointsBox::set_has_left() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsmAndHHRoutingIndex_HHRoutePointsBox::clear_has_left() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsmAndHHRoutingIndex_HHRoutePointsBox::clear_left() {
  left_ = 0;
  clear_has_left();
}
inline ::google::protobuf::int32 OsmAndHHRoutingIndex_HHRoutePointsBox::left() const {
  return left_;
}
inline void OsmAndHHRoutingIndex_HHRoutePointsBox::set_left(::google::protobuf::int32 value) {
  set_has_left();
  left_ = value;
}

// required sint32 right = 3;
inline bool OsmAndHHRoutingIndex_HHRoutePointsBox::has_right() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OsmAndHHRoutingIndex_HHRoutePointsBox::set_has_right() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OsmAndHHRoutingIndex_HHRoutePointsBox::clear_has_right() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OsmAndHHRoutingIndex_HHRoutePointsBox::clear_right() {
  right_ = 0;
  clear_has_right();
}
inline ::google::protobuf::int32 OsmAndHHRoutingIndex_HHRoutePointsBox::right() const {
  return right_;
}
inline void OsmAndHHRoutingIndex_HHRoutePointsBox::set_right(::google::protobuf::int32 value) {
  set_has_right();
  right_ = value;
}

// required sint32 top = 4;
inline bool OsmAndHHRoutingIndex_HHRoutePointsBox::has_top() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OsmAndHHRoutingIndex_HHRoutePointsBox::set_has_top() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OsmAndHHRoutingIndex_HHRoutePointsBox::clear_has_top() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OsmAndHHRoutingIndex_HHRoutePointsBox::clear_top() {
  top_ = 0;
  clear_has_top();
}
inline ::google::protobuf::int32 OsmAndHHRoutingIndex_HHRoutePointsBox::top() const {
  return top_;
}
inline void OsmAndHHRoutingIndex_HHRoutePointsBox::set_top(::google::protobuf::int32 value) {
  set_has_top();
  top_ = value;
}

// required sint32 bottom = 5;
inline bool OsmAndHHRoutingIndex_HHRoutePointsBox::has_bottom() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OsmAndHHRoutingIndex_HHRoutePointsBox::set_has_bottom() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OsmAndHHRoutingIndex_HHRoutePointsBox::clear_has_bottom() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OsmAndHHRoutingIndex_HHRoutePointsBox::clear_bottom() {
  bottom_ = 0;
  clear_has_bottom();
}
inline ::google::protobuf::int32 OsmAndHHRoutingIndex_HHRoutePointsBox::bottom() const {
  return bottom_;
}
inline void OsmAndHHRoutingIndex_HHRoutePointsBox::set_bottom(::google::protobuf::int32 value) {
  set_has_bottom();
  bottom_ = value;
}

// repeated .OsmAnd.OBF.OsmAndHHRoutingIndex.HHRoutePointsBox boxes = 6;
inline int OsmAndHHRoutingIndex_HHRoutePointsBox::boxes_size() const {
  return boxes_.size();
}
inline void OsmAndHHRoutingIndex_HHRoutePointsBox::clear_boxes() {
  boxes_.Clear();
}
inline const ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointsBox& OsmAndHHRoutingIndex_HHRoutePointsBox::boxes(int index) const {
  return boxes_.Get(index);
}
inline ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointsBox* OsmAndHHRoutingIndex_HHRoutePointsBox::mutable_boxes(int index) {
  return boxes_.Mutable(index);
}
inline ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointsBox* OsmAndHHRoutingIndex_HHRoutePointsBox::add_boxes() {
  return boxes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointsBox >&
OsmAndHHRoutingIndex_HHRoutePointsBox::boxes() const {
  return boxes_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointsBox >*
OsmAndHHRoutingIndex_HHRoutePointsBox::mutable_boxes() {
  return &boxes_;
}

// repeated .OsmAnd.OBF.OsmAndHHRoutingIndex.HHRouteNetworkPoint points = 7;
inline int OsmAndHHRoutingIndex_HHRoutePointsBox::points_size() const {
  return points_.size();
}
inline void OsmAndHHRoutingIndex_HHRoutePointsBox::clear_points() {
  points_.Clear();
}
inline const ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteNetworkPoint& OsmAndHHRoutingIndex_HHRoutePointsBox::points(int index) const {
  return points_.Get(index);
}
inline ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteNetworkPoint* OsmAndHHRoutingIndex_HHRoutePointsBox::mutable_points(int index) {
  return points_.Mutable(index);
}
inline ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteNetworkPoint* OsmAndHHRoutingIndex_HHRoutePointsBox::add_points() {
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteNetworkPoint >&
OsmAndHHRoutingIndex_HHRoutePointsBox::points() const {
  return points_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteNetworkPoint >*
OsmAndHHRoutingIndex_HHRoutePointsBox::mutable_points() {
  return &points_;
}

// -------------------------------------------------------------------

// OsmAndHHRoutingIndex_HHRouteNetworkPoint

// required int32 id = 1;
inline bool OsmAndHHRoutingIndex_HHRouteNetworkPoint::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 OsmAndHHRoutingIndex_HHRouteNetworkPoint::id() const {
  return id_;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required sint32 dx = 2;
inline bool OsmAndHHRoutingIndex_HHRouteNetworkPoint::has_dx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::set_has_dx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::clear_has_dx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::clear_dx() {
  dx_ = 0;
  clear_has_dx();
}
inline ::google::protobuf::int32 OsmAndHHRoutingIndex_HHRouteNetworkPoint::dx() const {
  return dx_;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::set_dx(::google::protobuf::int32 value) {
  set_has_dx();
  dx_ = value;
}

// required sint32 dy = 3;
inline bool OsmAndHHRoutingIndex_HHRouteNetworkPoint::has_dy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::set_has_dy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::clear_has_dy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::clear_dy() {
  dy_ = 0;
  clear_has_dy();
}
inline ::google::protobuf::int32 OsmAndHHRoutingIndex_HHRouteNetworkPoint::dy() const {
  return dy_;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::set_dy(::google::protobuf::int32 value) {
  set_has_dy();
  dy_ = value;
}

// required int32 globalId = 4;
inline bool OsmAndHHRoutingIndex_HHRouteNetworkPoint::has_globalid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::set_has_globalid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::clear_has_globalid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::clear_globalid() {
  globalid_ = 0;
  clear_has_globalid();
}
inline ::google::protobuf::int32 OsmAndHHRoutingIndex_HHRouteNetworkPoint::globalid() const {
  return globalid_;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::set_globalid(::google::protobuf::int32 value) {
  set_has_globalid();
  globalid_ = value;
}

// required int64 roadId = 5;
inline bool OsmAndHHRoutingIndex_HHRouteNetworkPoint::has_roadid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::set_has_roadid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::clear_has_roadid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::clear_roadid() {
  roadid_ = GOOGLE_LONGLONG(0);
  clear_has_roadid();
}
inline ::google::protobuf::int64 OsmAndHHRoutingIndex_HHRouteNetworkPoint::roadid() const {
  return roadid_;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::set_roadid(::google::protobuf::int64 value) {
  set_has_roadid();
  roadid_ = value;
}

// required int32 roadStartEndIndex = 6;
inline bool OsmAndHHRoutingIndex_HHRouteNetworkPoint::has_roadstartendindex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::set_has_roadstartendindex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::clear_has_roadstartendindex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::clear_roadstartendindex() {
  roadstartendindex_ = 0;
  clear_has_roadstartendindex();
}
inline ::google::protobuf::int32 OsmAndHHRoutingIndex_HHRouteNetworkPoint::roadstartendindex() const {
  return roadstartendindex_;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::set_roadstartendindex(::google::protobuf::int32 value) {
  set_has_roadstartendindex();
  roadstartendindex_ = value;
}

// optional int32 clusterId = 7;
inline bool OsmAndHHRoutingIndex_HHRouteNetworkPoint::has_clusterid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::set_has_clusterid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::clear_clusterid() {
  clusterid_ = 0;
  clear_has_clusterid();
}
inline ::google::protobuf::int32 OsmAndHHRoutingIndex_HHRouteNetworkPoint::clusterid() const {
  return clusterid_;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::set_clusterid(::google::protobuf::int32 value) {
  set_has_clusterid();
  clusterid_ = value;
}

// optional int32 dualPointId = 8;
inline bool OsmAndHHRoutingIndex_HHRouteNetworkPoint::has_dualpointid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::set_has_dualpointid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::clear_has_dualpointid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::clear_dualpointid() {
  dualpointid_ = 0;
  clear_has_dualpointid();
}
inline ::google::protobuf::int32 OsmAndHHRoutingIndex_HHRouteNetworkPoint::dualpointid() const {
  return dualpointid_;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::set_dualpointid(::google::protobuf::int32 value) {
  set_has_dualpointid();
  dualpointid_ = value;
}

// optional int32 dualClusterId = 9;
inline bool OsmAndHHRoutingIndex_HHRouteNetworkPoint::has_dualclusterid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::set_has_dualclusterid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::clear_has_dualclusterid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::clear_dualclusterid() {
  dualclusterid_ = 0;
  clear_has_dualclusterid();
}
inline ::google::protobuf::int32 OsmAndHHRoutingIndex_HHRouteNetworkPoint::dualclusterid() const {
  return dualclusterid_;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::set_dualclusterid(::google::protobuf::int32 value) {
  set_has_dualclusterid();
  dualclusterid_ = value;
}

// repeated int32 profileIds = 10;
inline int OsmAndHHRoutingIndex_HHRouteNetworkPoint::profileids_size() const {
  return profileids_.size();
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::clear_profileids() {
  profileids_.Clear();
}
inline ::google::protobuf::int32 OsmAndHHRoutingIndex_HHRouteNetworkPoint::profileids(int index) const {
  return profileids_.Get(index);
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::set_profileids(int index, ::google::protobuf::int32 value) {
  profileids_.Set(index, value);
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::add_profileids(::google::protobuf::int32 value) {
  profileids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
OsmAndHHRoutingIndex_HHRouteNetworkPoint::profileids() const {
  return profileids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
OsmAndHHRoutingIndex_HHRouteNetworkPoint::mutable_profileids() {
  return &profileids_;
}

// optional int32 partialInd = 11;
inline bool OsmAndHHRoutingIndex_HHRouteNetworkPoint::has_partialind() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::set_has_partialind() {
  _has_bits_[0] |= 0x00000400u;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::clear_has_partialind() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::clear_partialind() {
  partialind_ = 0;
  clear_has_partialind();
}
inline ::google::protobuf::int32 OsmAndHHRoutingIndex_HHRouteNetworkPoint::partialind() const {
  return partialind_;
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::set_partialind(::google::protobuf::int32 value) {
  set_has_partialind();
  partialind_ = value;
}

// repeated int32 tagValueIds = 12 [packed = true];
inline int OsmAndHHRoutingIndex_HHRouteNetworkPoint::tagvalueids_size() const {
  return tagvalueids_.size();
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::clear_tagvalueids() {
  tagvalueids_.Clear();
}
inline ::google::protobuf::int32 OsmAndHHRoutingIndex_HHRouteNetworkPoint::tagvalueids(int index) const {
  return tagvalueids_.Get(index);
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::set_tagvalueids(int index, ::google::protobuf::int32 value) {
  tagvalueids_.Set(index, value);
}
inline void OsmAndHHRoutingIndex_HHRouteNetworkPoint::add_tagvalueids(::google::protobuf::int32 value) {
  tagvalueids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
OsmAndHHRoutingIndex_HHRouteNetworkPoint::tagvalueids() const {
  return tagvalueids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
OsmAndHHRoutingIndex_HHRouteNetworkPoint::mutable_tagvalueids() {
  return &tagvalueids_;
}

// -------------------------------------------------------------------

// OsmAndHHRoutingIndex_HHRouteBlockSegments

// required int32 idRangeStart = 1;
inline bool OsmAndHHRoutingIndex_HHRouteBlockSegments::has_idrangestart() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsmAndHHRoutingIndex_HHRouteBlockSegments::set_has_idrangestart() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsmAndHHRoutingIndex_HHRouteBlockSegments::clear_has_idrangestart() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsmAndHHRoutingIndex_HHRouteBlockSegments::clear_idrangestart() {
  idrangestart_ = 0;
  clear_has_idrangestart();
}
inline ::google::protobuf::int32 OsmAndHHRoutingIndex_HHRouteBlockSegments::idrangestart() const {
  return idrangestart_;
}
inline void OsmAndHHRoutingIndex_HHRouteBlockSegments::set_idrangestart(::google::protobuf::int32 value) {
  set_has_idrangestart();
  idrangestart_ = value;
}

// required int32 idRangeLength = 2;
inline bool OsmAndHHRoutingIndex_HHRouteBlockSegments::has_idrangelength() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OsmAndHHRoutingIndex_HHRouteBlockSegments::set_has_idrangelength() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OsmAndHHRoutingIndex_HHRouteBlockSegments::clear_has_idrangelength() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OsmAndHHRoutingIndex_HHRouteBlockSegments::clear_idrangelength() {
  idrangelength_ = 0;
  clear_has_idrangelength();
}
inline ::google::protobuf::int32 OsmAndHHRoutingIndex_HHRouteBlockSegments::idrangelength() const {
  return idrangelength_;
}
inline void OsmAndHHRoutingIndex_HHRouteBlockSegments::set_idrangelength(::google::protobuf::int32 value) {
  set_has_idrangelength();
  idrangelength_ = value;
}

// optional int32 profileId = 3;
inline bool OsmAndHHRoutingIndex_HHRouteBlockSegments::has_profileid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OsmAndHHRoutingIndex_HHRouteBlockSegments::set_has_profileid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OsmAndHHRoutingIndex_HHRouteBlockSegments::clear_has_profileid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OsmAndHHRoutingIndex_HHRouteBlockSegments::clear_profileid() {
  profileid_ = 0;
  clear_has_profileid();
}
inline ::google::protobuf::int32 OsmAndHHRoutingIndex_HHRouteBlockSegments::profileid() const {
  return profileid_;
}
inline void OsmAndHHRoutingIndex_HHRouteBlockSegments::set_profileid(::google::protobuf::int32 value) {
  set_has_profileid();
  profileid_ = value;
}

// repeated .OsmAnd.OBF.OsmAndHHRoutingIndex.HHRouteBlockSegments innerBlocks = 6;
inline int OsmAndHHRoutingIndex_HHRouteBlockSegments::innerblocks_size() const {
  return innerblocks_.size();
}
inline void OsmAndHHRoutingIndex_HHRouteBlockSegments::clear_innerblocks() {
  innerblocks_.Clear();
}
inline const ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteBlockSegments& OsmAndHHRoutingIndex_HHRouteBlockSegments::innerblocks(int index) const {
  return innerblocks_.Get(index);
}
inline ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteBlockSegments* OsmAndHHRoutingIndex_HHRouteBlockSegments::mutable_innerblocks(int index) {
  return innerblocks_.Mutable(index);
}
inline ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteBlockSegments* OsmAndHHRoutingIndex_HHRouteBlockSegments::add_innerblocks() {
  return innerblocks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteBlockSegments >&
OsmAndHHRoutingIndex_HHRouteBlockSegments::innerblocks() const {
  return innerblocks_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteBlockSegments >*
OsmAndHHRoutingIndex_HHRouteBlockSegments::mutable_innerblocks() {
  return &innerblocks_;
}

// repeated .OsmAnd.OBF.OsmAndHHRoutingIndex.HHRoutePointSegments pointSegments = 4;
inline int OsmAndHHRoutingIndex_HHRouteBlockSegments::pointsegments_size() const {
  return pointsegments_.size();
}
inline void OsmAndHHRoutingIndex_HHRouteBlockSegments::clear_pointsegments() {
  pointsegments_.Clear();
}
inline const ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointSegments& OsmAndHHRoutingIndex_HHRouteBlockSegments::pointsegments(int index) const {
  return pointsegments_.Get(index);
}
inline ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointSegments* OsmAndHHRoutingIndex_HHRouteBlockSegments::mutable_pointsegments(int index) {
  return pointsegments_.Mutable(index);
}
inline ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointSegments* OsmAndHHRoutingIndex_HHRouteBlockSegments::add_pointsegments() {
  return pointsegments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointSegments >&
OsmAndHHRoutingIndex_HHRouteBlockSegments::pointsegments() const {
  return pointsegments_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointSegments >*
OsmAndHHRoutingIndex_HHRouteBlockSegments::mutable_pointsegments() {
  return &pointsegments_;
}

// -------------------------------------------------------------------

// OsmAndHHRoutingIndex_HHRoutePointSegments

// required bytes segmentsIn = 2;
inline bool OsmAndHHRoutingIndex_HHRoutePointSegments::has_segmentsin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsmAndHHRoutingIndex_HHRoutePointSegments::set_has_segmentsin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsmAndHHRoutingIndex_HHRoutePointSegments::clear_has_segmentsin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsmAndHHRoutingIndex_HHRoutePointSegments::clear_segmentsin() {
  if (segmentsin_ != &::google::protobuf::internal::kEmptyString) {
    segmentsin_->clear();
  }
  clear_has_segmentsin();
}
inline const ::std::string& OsmAndHHRoutingIndex_HHRoutePointSegments::segmentsin() const {
  return *segmentsin_;
}
inline void OsmAndHHRoutingIndex_HHRoutePointSegments::set_segmentsin(const ::std::string& value) {
  set_has_segmentsin();
  if (segmentsin_ == &::google::protobuf::internal::kEmptyString) {
    segmentsin_ = new ::std::string;
  }
  segmentsin_->assign(value);
}
inline void OsmAndHHRoutingIndex_HHRoutePointSegments::set_segmentsin(const char* value) {
  set_has_segmentsin();
  if (segmentsin_ == &::google::protobuf::internal::kEmptyString) {
    segmentsin_ = new ::std::string;
  }
  segmentsin_->assign(value);
}
inline void OsmAndHHRoutingIndex_HHRoutePointSegments::set_segmentsin(const void* value, size_t size) {
  set_has_segmentsin();
  if (segmentsin_ == &::google::protobuf::internal::kEmptyString) {
    segmentsin_ = new ::std::string;
  }
  segmentsin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndHHRoutingIndex_HHRoutePointSegments::mutable_segmentsin() {
  set_has_segmentsin();
  if (segmentsin_ == &::google::protobuf::internal::kEmptyString) {
    segmentsin_ = new ::std::string;
  }
  return segmentsin_;
}
inline ::std::string* OsmAndHHRoutingIndex_HHRoutePointSegments::release_segmentsin() {
  clear_has_segmentsin();
  if (segmentsin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = segmentsin_;
    segmentsin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OsmAndHHRoutingIndex_HHRoutePointSegments::set_allocated_segmentsin(::std::string* segmentsin) {
  if (segmentsin_ != &::google::protobuf::internal::kEmptyString) {
    delete segmentsin_;
  }
  if (segmentsin) {
    set_has_segmentsin();
    segmentsin_ = segmentsin;
  } else {
    clear_has_segmentsin();
    segmentsin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes segmentsOut = 3;
inline bool OsmAndHHRoutingIndex_HHRoutePointSegments::has_segmentsout() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OsmAndHHRoutingIndex_HHRoutePointSegments::set_has_segmentsout() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OsmAndHHRoutingIndex_HHRoutePointSegments::clear_has_segmentsout() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OsmAndHHRoutingIndex_HHRoutePointSegments::clear_segmentsout() {
  if (segmentsout_ != &::google::protobuf::internal::kEmptyString) {
    segmentsout_->clear();
  }
  clear_has_segmentsout();
}
inline const ::std::string& OsmAndHHRoutingIndex_HHRoutePointSegments::segmentsout() const {
  return *segmentsout_;
}
inline void OsmAndHHRoutingIndex_HHRoutePointSegments::set_segmentsout(const ::std::string& value) {
  set_has_segmentsout();
  if (segmentsout_ == &::google::protobuf::internal::kEmptyString) {
    segmentsout_ = new ::std::string;
  }
  segmentsout_->assign(value);
}
inline void OsmAndHHRoutingIndex_HHRoutePointSegments::set_segmentsout(const char* value) {
  set_has_segmentsout();
  if (segmentsout_ == &::google::protobuf::internal::kEmptyString) {
    segmentsout_ = new ::std::string;
  }
  segmentsout_->assign(value);
}
inline void OsmAndHHRoutingIndex_HHRoutePointSegments::set_segmentsout(const void* value, size_t size) {
  set_has_segmentsout();
  if (segmentsout_ == &::google::protobuf::internal::kEmptyString) {
    segmentsout_ = new ::std::string;
  }
  segmentsout_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndHHRoutingIndex_HHRoutePointSegments::mutable_segmentsout() {
  set_has_segmentsout();
  if (segmentsout_ == &::google::protobuf::internal::kEmptyString) {
    segmentsout_ = new ::std::string;
  }
  return segmentsout_;
}
inline ::std::string* OsmAndHHRoutingIndex_HHRoutePointSegments::release_segmentsout() {
  clear_has_segmentsout();
  if (segmentsout_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = segmentsout_;
    segmentsout_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OsmAndHHRoutingIndex_HHRoutePointSegments::set_allocated_segmentsout(::std::string* segmentsout) {
  if (segmentsout_ != &::google::protobuf::internal::kEmptyString) {
    delete segmentsout_;
  }
  if (segmentsout) {
    set_has_segmentsout();
    segmentsout_ = segmentsout;
  } else {
    clear_has_segmentsout();
    segmentsout_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// OsmAndHHRoutingIndex

// required int64 edition = 1;
inline bool OsmAndHHRoutingIndex::has_edition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsmAndHHRoutingIndex::set_has_edition() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsmAndHHRoutingIndex::clear_has_edition() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsmAndHHRoutingIndex::clear_edition() {
  edition_ = GOOGLE_LONGLONG(0);
  clear_has_edition();
}
inline ::google::protobuf::int64 OsmAndHHRoutingIndex::edition() const {
  return edition_;
}
inline void OsmAndHHRoutingIndex::set_edition(::google::protobuf::int64 value) {
  set_has_edition();
  edition_ = value;
}

// required string profile = 2;
inline bool OsmAndHHRoutingIndex::has_profile() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OsmAndHHRoutingIndex::set_has_profile() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OsmAndHHRoutingIndex::clear_has_profile() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OsmAndHHRoutingIndex::clear_profile() {
  if (profile_ != &::google::protobuf::internal::kEmptyString) {
    profile_->clear();
  }
  clear_has_profile();
}
inline const ::std::string& OsmAndHHRoutingIndex::profile() const {
  return *profile_;
}
inline void OsmAndHHRoutingIndex::set_profile(const ::std::string& value) {
  set_has_profile();
  if (profile_ == &::google::protobuf::internal::kEmptyString) {
    profile_ = new ::std::string;
  }
  profile_->assign(value);
}
inline void OsmAndHHRoutingIndex::set_profile(const char* value) {
  set_has_profile();
  if (profile_ == &::google::protobuf::internal::kEmptyString) {
    profile_ = new ::std::string;
  }
  profile_->assign(value);
}
inline void OsmAndHHRoutingIndex::set_profile(const char* value, size_t size) {
  set_has_profile();
  if (profile_ == &::google::protobuf::internal::kEmptyString) {
    profile_ = new ::std::string;
  }
  profile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndHHRoutingIndex::mutable_profile() {
  set_has_profile();
  if (profile_ == &::google::protobuf::internal::kEmptyString) {
    profile_ = new ::std::string;
  }
  return profile_;
}
inline ::std::string* OsmAndHHRoutingIndex::release_profile() {
  clear_has_profile();
  if (profile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = profile_;
    profile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OsmAndHHRoutingIndex::set_allocated_profile(::std::string* profile) {
  if (profile_ != &::google::protobuf::internal::kEmptyString) {
    delete profile_;
  }
  if (profile) {
    set_has_profile();
    profile_ = profile;
  } else {
    clear_has_profile();
    profile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string profileParams = 3;
inline int OsmAndHHRoutingIndex::profileparams_size() const {
  return profileparams_.size();
}
inline void OsmAndHHRoutingIndex::clear_profileparams() {
  profileparams_.Clear();
}
inline const ::std::string& OsmAndHHRoutingIndex::profileparams(int index) const {
  return profileparams_.Get(index);
}
inline ::std::string* OsmAndHHRoutingIndex::mutable_profileparams(int index) {
  return profileparams_.Mutable(index);
}
inline void OsmAndHHRoutingIndex::set_profileparams(int index, const ::std::string& value) {
  profileparams_.Mutable(index)->assign(value);
}
inline void OsmAndHHRoutingIndex::set_profileparams(int index, const char* value) {
  profileparams_.Mutable(index)->assign(value);
}
inline void OsmAndHHRoutingIndex::set_profileparams(int index, const char* value, size_t size) {
  profileparams_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndHHRoutingIndex::add_profileparams() {
  return profileparams_.Add();
}
inline void OsmAndHHRoutingIndex::add_profileparams(const ::std::string& value) {
  profileparams_.Add()->assign(value);
}
inline void OsmAndHHRoutingIndex::add_profileparams(const char* value) {
  profileparams_.Add()->assign(value);
}
inline void OsmAndHHRoutingIndex::add_profileparams(const char* value, size_t size) {
  profileparams_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OsmAndHHRoutingIndex::profileparams() const {
  return profileparams_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OsmAndHHRoutingIndex::mutable_profileparams() {
  return &profileparams_;
}

// optional .OsmAnd.OBF.StringTable tagValuesTable = 4;
inline bool OsmAndHHRoutingIndex::has_tagvaluestable() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OsmAndHHRoutingIndex::set_has_tagvaluestable() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OsmAndHHRoutingIndex::clear_has_tagvaluestable() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OsmAndHHRoutingIndex::clear_tagvaluestable() {
  if (tagvaluestable_ != NULL) tagvaluestable_->::OsmAnd::OBF::StringTable::Clear();
  clear_has_tagvaluestable();
}
inline const ::OsmAnd::OBF::StringTable& OsmAndHHRoutingIndex::tagvaluestable() const {
  return tagvaluestable_ != NULL ? *tagvaluestable_ : *default_instance_->tagvaluestable_;
}
inline ::OsmAnd::OBF::StringTable* OsmAndHHRoutingIndex::mutable_tagvaluestable() {
  set_has_tagvaluestable();
  if (tagvaluestable_ == NULL) tagvaluestable_ = new ::OsmAnd::OBF::StringTable;
  return tagvaluestable_;
}
inline ::OsmAnd::OBF::StringTable* OsmAndHHRoutingIndex::release_tagvaluestable() {
  clear_has_tagvaluestable();
  ::OsmAnd::OBF::StringTable* temp = tagvaluestable_;
  tagvaluestable_ = NULL;
  return temp;
}
inline void OsmAndHHRoutingIndex::set_allocated_tagvaluestable(::OsmAnd::OBF::StringTable* tagvaluestable) {
  delete tagvaluestable_;
  tagvaluestable_ = tagvaluestable;
  if (tagvaluestable) {
    set_has_tagvaluestable();
  } else {
    clear_has_tagvaluestable();
  }
}

// required .OsmAnd.OBF.OsmAndHHRoutingIndex.HHRoutePointsBox pointBoxes = 5;
inline bool OsmAndHHRoutingIndex::has_pointboxes() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OsmAndHHRoutingIndex::set_has_pointboxes() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OsmAndHHRoutingIndex::clear_has_pointboxes() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OsmAndHHRoutingIndex::clear_pointboxes() {
  if (pointboxes_ != NULL) pointboxes_->::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointsBox::Clear();
  clear_has_pointboxes();
}
inline const ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointsBox& OsmAndHHRoutingIndex::pointboxes() const {
  return pointboxes_ != NULL ? *pointboxes_ : *default_instance_->pointboxes_;
}
inline ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointsBox* OsmAndHHRoutingIndex::mutable_pointboxes() {
  set_has_pointboxes();
  if (pointboxes_ == NULL) pointboxes_ = new ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointsBox;
  return pointboxes_;
}
inline ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointsBox* OsmAndHHRoutingIndex::release_pointboxes() {
  clear_has_pointboxes();
  ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointsBox* temp = pointboxes_;
  pointboxes_ = NULL;
  return temp;
}
inline void OsmAndHHRoutingIndex::set_allocated_pointboxes(::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRoutePointsBox* pointboxes) {
  delete pointboxes_;
  pointboxes_ = pointboxes;
  if (pointboxes) {
    set_has_pointboxes();
  } else {
    clear_has_pointboxes();
  }
}

// repeated .OsmAnd.OBF.OsmAndHHRoutingIndex.HHRouteBlockSegments pointSegments = 6;
inline int OsmAndHHRoutingIndex::pointsegments_size() const {
  return pointsegments_.size();
}
inline void OsmAndHHRoutingIndex::clear_pointsegments() {
  pointsegments_.Clear();
}
inline const ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteBlockSegments& OsmAndHHRoutingIndex::pointsegments(int index) const {
  return pointsegments_.Get(index);
}
inline ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteBlockSegments* OsmAndHHRoutingIndex::mutable_pointsegments(int index) {
  return pointsegments_.Mutable(index);
}
inline ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteBlockSegments* OsmAndHHRoutingIndex::add_pointsegments() {
  return pointsegments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteBlockSegments >&
OsmAndHHRoutingIndex::pointsegments() const {
  return pointsegments_;
}
inline ::google::protobuf::RepeatedPtrField< ::OsmAnd::OBF::OsmAndHHRoutingIndex_HHRouteBlockSegments >*
OsmAndHHRoutingIndex::mutable_pointsegments() {
  return &pointsegments_;
}

// -------------------------------------------------------------------

// OsmAndOwner

// required string name = 1;
inline bool OsmAndOwner::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OsmAndOwner::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OsmAndOwner::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OsmAndOwner::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& OsmAndOwner::name() const {
  return *name_;
}
inline void OsmAndOwner::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndOwner::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void OsmAndOwner::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndOwner::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* OsmAndOwner::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OsmAndOwner::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string resource = 2;
inline bool OsmAndOwner::has_resource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OsmAndOwner::set_has_resource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OsmAndOwner::clear_has_resource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OsmAndOwner::clear_resource() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    resource_->clear();
  }
  clear_has_resource();
}
inline const ::std::string& OsmAndOwner::resource() const {
  return *resource_;
}
inline void OsmAndOwner::set_resource(const ::std::string& value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void OsmAndOwner::set_resource(const char* value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void OsmAndOwner::set_resource(const char* value, size_t size) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndOwner::mutable_resource() {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  return resource_;
}
inline ::std::string* OsmAndOwner::release_resource() {
  clear_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resource_;
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OsmAndOwner::set_allocated_resource(::std::string* resource) {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  if (resource) {
    set_has_resource();
    resource_ = resource;
  } else {
    clear_has_resource();
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string description = 3;
inline bool OsmAndOwner::has_description() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OsmAndOwner::set_has_description() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OsmAndOwner::clear_has_description() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OsmAndOwner::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& OsmAndOwner::description() const {
  return *description_;
}
inline void OsmAndOwner::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void OsmAndOwner::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void OsmAndOwner::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndOwner::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* OsmAndOwner::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OsmAndOwner::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pluginid = 4;
inline bool OsmAndOwner::has_pluginid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OsmAndOwner::set_has_pluginid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OsmAndOwner::clear_has_pluginid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OsmAndOwner::clear_pluginid() {
  if (pluginid_ != &::google::protobuf::internal::kEmptyString) {
    pluginid_->clear();
  }
  clear_has_pluginid();
}
inline const ::std::string& OsmAndOwner::pluginid() const {
  return *pluginid_;
}
inline void OsmAndOwner::set_pluginid(const ::std::string& value) {
  set_has_pluginid();
  if (pluginid_ == &::google::protobuf::internal::kEmptyString) {
    pluginid_ = new ::std::string;
  }
  pluginid_->assign(value);
}
inline void OsmAndOwner::set_pluginid(const char* value) {
  set_has_pluginid();
  if (pluginid_ == &::google::protobuf::internal::kEmptyString) {
    pluginid_ = new ::std::string;
  }
  pluginid_->assign(value);
}
inline void OsmAndOwner::set_pluginid(const char* value, size_t size) {
  set_has_pluginid();
  if (pluginid_ == &::google::protobuf::internal::kEmptyString) {
    pluginid_ = new ::std::string;
  }
  pluginid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OsmAndOwner::mutable_pluginid() {
  set_has_pluginid();
  if (pluginid_ == &::google::protobuf::internal::kEmptyString) {
    pluginid_ = new ::std::string;
  }
  return pluginid_;
}
inline ::std::string* OsmAndOwner::release_pluginid() {
  clear_has_pluginid();
  if (pluginid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pluginid_;
    pluginid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OsmAndOwner::set_allocated_pluginid(::std::string* pluginid) {
  if (pluginid_ != &::google::protobuf::internal::kEmptyString) {
    delete pluginid_;
  }
  if (pluginid) {
    set_has_pluginid();
    pluginid_ = pluginid;
  } else {
    clear_has_pluginid();
    pluginid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace OBF
}  // namespace OsmAnd

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OsmAnd::OBF::OsmAndAddressIndex_CitiesIndex_CitiesType>() {
  return ::OsmAnd::OBF::OsmAndAddressIndex_CitiesIndex_CitiesType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_OBF_2eproto__INCLUDED
