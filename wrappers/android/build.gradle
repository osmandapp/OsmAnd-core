buildscript {
    repositories {
        google()
        mavenCentral()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:8.7.3'
    }
}

apply plugin: 'com.android.library'
apply plugin: 'ivy-publish'

import org.apache.tools.ant.taskdefs.condition.Os

allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

android {
    namespace "net.osmand.core"
    compileSdk 35
    buildToolsVersion = "35.0.0"

    defaultConfig {
        minSdkVersion 24
        targetSdkVersion 34
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    // Enable the buildConfig feature, which is required for custom buildConfigFields.
    buildFeatures {
        buildConfig = true
    }

    sourceSets {
        main {
            manifest.srcFile "AndroidManifest.xml"
            java.srcDirs = ["./src", "./gen/java"]
            jniLibs.srcDirs = ["./jniLibs/NDK", "./jniLibs/Qt"]
            // jni.srcDirs is deprecated and should not be used.
            // Place C/C++ sources in src/main/cpp by default.
            assets.srcDirs = ["./assets"]
        }
    }

    aaptOptions {
        noCompress "qz", "png"
    }

    lintOptions {
        abortOnError false
    }

    buildTypes {
        debug {
            debuggable true
            jniDebuggable true
            buildConfigField "boolean", "USE_DEBUG_LIBRARIES", "true"
        }
        release {
            debuggable false
            jniDebuggable false
            buildConfigField "boolean", "USE_DEBUG_LIBRARIES", "false"
        }
    }

}

// Java sources generation tasks
task cleanupSwig(type: Delete) {
    description "Clean-up old generated SWIG Java interface"
    delete fileTree("./gen")
}

task swigGenerateJava(type: Exec) {
    description "Generate SWIG Java interface"
    dependsOn cleanupSwig
    // This makes the 'gen' directory available to the build
    outputs.dir(file("./gen/java"))

    if (Os.isFamily(Os.FAMILY_WINDOWS)) {
        commandLine "cmd", "/c", "bash --login " + file("../java/generate.sh").getAbsolutePath() + " " + projectDir.getAbsolutePath()
    } else {
        commandLine "sh", file("../java/generate.sh").getAbsolutePath(), projectDir.getAbsolutePath()
    }
}

// NDK libraries tasks
task cleanupNdkSharedLibs(type: Delete) {
    description "Clean-up NDK shared libraries"
    delete "./jniLibs/NDK"
}

task copyNdkSharedLibs(type: Copy) {
    description "Copy NDK shared libraries"
    dependsOn cleanupNdkSharedLibs

    from("$System.env.ANDROID_NDK/sources/cxx-stl/llvm-libc++/libs") {
        include "armeabi-v7a/libc++_shared.so"
        include "arm64-v8a/libc++_shared.so"
        include "x86/libc++_shared.so"
        include "x86_64/libc++_shared.so"
    }

    into "./jniLibs/NDK"
    includeEmptyDirs = false
}

// Qt shared libraries tasks
task cleanupQtSharedLibs(type: Delete) {
    description "Clean-up Qt shared libraries"
    delete "./jniLibs/Qt"
}

task copyQtSharedLibs(type: Copy) {
    description "Copy Qt shared libraries"
    dependsOn cleanupQtSharedLibs

    from("../../externals/qtbase-android") {
        include "upstream.patched.android.clang-*.shared/lib/libQt5Core.so"
        include "upstream.patched.android.clang-*.shared/lib/libQt5Network.so"
        include "upstream.patched.android.clang-*.shared/lib/libQt5Sql.so"
        eachFile { fileCopyDetails ->
            fileCopyDetails.path = fileCopyDetails.path.replaceAll(/.*upstream\.patched\.android\.clang\-(.*)\.shared\/lib\/(.*)/, '$1/$2')
        }
    }

    into "./jniLibs/Qt"
    includeEmptyDirs = false
}

// Qt JAR libraries tasks
task cleanupQtJarLibs(type: Delete) {
    description "Clean-up Qt JAR libraries"
    delete "./libs/Qt"
}

task copyQtJarLibs(type: Copy) {
    description "Copy Qt JAR libraries"
    dependsOn cleanupQtJarLibs

    from("../../externals/qtbase-android") {
        include "upstream.patched.android.clang-*.shared/jar/*.jar"
        eachFile { fileCopyDetails ->
            fileCopyDetails.path = fileCopyDetails.path.replaceAll(/.*upstream\.patched\.android\.clang\-.*\.shared\/jar\/(.*)/, '$1')
        }
    }

    into "./libs/Qt"
    includeEmptyDirs = false
}

task cleanupOsmAndResources(type: Delete) {
    description "Clean-up OsmAnd resources"
    delete "./assets/OsmAndCore_ResourcesBundle"
    delete "./assets/OsmAndCore_ResourcesBundle.index"
}

task copyOsmAndResources(type: Copy) {
    description "Copy OsmAnd resources"
    dependsOn cleanupOsmAndResources
    outputs.dir("./assets/OsmAndCore_ResourcesBundle") 
    from("../../../resources/rendering_styles") { include "default.render.xml", "default.map_styles_presets.xml"; eachFile { it.path = "map/styles/" + it.path } }
    from("../../../resources/rendering_styles/style-icons/map-icons-svg") { include "mx_*.svg", "c_mx_*.svg"; eachFile { it.path = "map/icons/" + it.path.replaceAll(/(c_)?mx_(.*)\.svg/, '$1$2.svg') } }
    from("../../../resources/rendering_styles/style-icons/map-shaders-svg") { include "h_*.svg", "c_h_*.svg"; eachFile { it.path = "map/shaders_and_shields/" + it.path.replaceAll(/(c_)?h_(.*)\.svg/, '$1$2.svg') } }
    from("../../../resources/rendering_styles/stubs/[ddf=1.0]") { include "*.png"; eachFile { it.path = "[ddf=1.0]/map/stubs/" + it.path } }
    from("../../../resources/rendering_styles/stubs/[ddf=1.5]") { include "*.png"; eachFile { it.path = "[ddf=1.5]/map/stubs/" + it.path } }
    from("../../../resources/rendering_styles/stubs/[ddf=2.0]") { include "*.png"; eachFile { it.path = "[ddf=2.0]/map/stubs/" + it.path } }
    from("../../../resources/rendering_styles/stubs/[ddf=3.0]") { include "*.png"; eachFile { it.path = "[ddf=3.0]/map/stubs/" + it.path } }
    from("../../../resources/rendering_styles/stubs") { include "*.png"; eachFile { it.path = "map/stubs/" + it.path } }
    from("../../../resources/routing") { include "routing.xml"; eachFile { it.path = "routing/" + it.path } }
    from("../../../resources/rendering_styles/fonts") { include "**/*.ttf"; eachFile { it.path = "map/fonts/" + it.path } }
    from("../../../resources/misc/icu4c") { include "*.dat"; eachFile { it.path = "misc/icu4c/" + it.path.replaceAll(/icudt\d+([lb])\.dat/, 'icu-data-$1.dat') } }
    into "./assets/OsmAndCore_ResourcesBundle"
    includeEmptyDirs = false
}

task indexOsmAndResources {
    dependsOn copyOsmAndResources
    description = "Index OsmAnd resources"
    def outputIndexFile = file("./assets/OsmAndCore_ResourcesBundle.index")
    inputs.dir("./assets/OsmAndCore_ResourcesBundle")
    outputs.file(outputIndexFile)

    doLast {
        def resources = fileTree("./assets/OsmAndCore_ResourcesBundle") {
            include "**/*.*"
        }.collect {
            it.toURI().normalize().path.substring(file("./assets/OsmAndCore_ResourcesBundle").toURI().normalize().path.length())
        }
        outputIndexFile.text = resources.join('\n')
    }
}

task packOsmAndResources(type: Exec) {
    description = "Pack OsmAnd resources"
    dependsOn copyOsmAndResources

    if (Os.isFamily(Os.FAMILY_WINDOWS)) {
        commandLine "cmd", "/c", "bash --login " + file("./pack-resources.sh").getAbsolutePath() + " " + projectDir.getAbsolutePath() + "/assets/OsmAndCore_ResourcesBundle"
    } else {
        commandLine "sh", file("./pack-resources.sh").getAbsolutePath(), projectDir.getAbsolutePath() + "/assets/OsmAndCore_ResourcesBundle"
    }
}


android.libraryVariants.all { variant ->
    def mergeJniLibsTask = tasks.findByName("merge${variant.name.capitalize()}JniLibFolders")
    if (mergeJniLibsTask != null) {
        mergeJniLibsTask.dependsOn copyNdkSharedLibs, copyQtSharedLibs
    }
    def packageAssetsTask = tasks.findByName("package${variant.name.capitalize()}Assets")
    if (packageAssetsTask != null) {
        packageAssetsTask.dependsOn indexOsmAndResources, packOsmAndResources, copyOsmAndResources // All tasks that modify /assets
    }
    def extractAnnotationsTask = tasks.findByName("extract${variant.name.capitalize()}Annotations")
    if (extractAnnotationsTask != null) {
        extractAnnotationsTask.dependsOn swigGenerateJava, copyQtJarLibs
    }
    def mergeJavaResourcesTask = tasks.findByName("merge${variant.name.capitalize()}JavaResource")
    if (mergeJavaResourcesTask != null) {
        mergeJavaResourcesTask.dependsOn copyQtJarLibs
    }
    def copyJarsTask = tasks.findByName("copy${variant.name.capitalize()}JniLibsProjectAndLocalJars")
    if (copyJarsTask != null) {
        copyJarsTask.dependsOn copyQtJarLibs
    }
}

afterEvaluate {
    android.libraryVariants.configureEach { variant ->
        variant.javaCompileProvider.configure {
            dependsOn swigGenerateJava, indexOsmAndResources, packOsmAndResources, copyNdkSharedLibs, copyQtSharedLibs, copyQtJarLibs
        }
    }
}


dependencies {
    implementation fileTree(dir: "libs", include: ["**/*.jar"])
    implementation project(":OsmAndCore_androidNative")
}

// // The publishing configuration needs to be deferred until after the Android plugin
// // has created all the variants and components. Using afterEvaluate solves this.
// afterEvaluate {
//     group = "net.osmand"
//     version = System.getenv("OSMAND_BINARIES_IVY_REVISION") ?: "master-snapshot"

//     publishing {
//         repositories {
//             ivy {
//                 name "localIvy" // Give the repository a name
//                 url = uri(System.getenv("OSMAND_BINARIES_IVY_ROOT") ?: layout.buildDirectory.dir("repo"))
//                 // The patternLayout is now configured inside the ivy repository block.
//                 patternLayout {
//                     artifact "[organisation]/[module]/[revision]/[artifact]-[revision].[ext]"
//                 }
//             }
//         }
//         publications {
//             // This publication will publish the AAR file, which is the standard for Android libraries.
//             releaseAar(IvyPublication) {
//                 // 'from components' is the modern way to specify what to publish.
//                 // 'release' is the component for the release build type.
//                 from components.release

//                 // The artifact details are often inferred, but can be customized.
//                 artifactId = "OsmAndCore_android"
//             }

//             // If you still need to publish the classes.jar specifically, you can define another publication.
//             // However, this is less common as the AAR contains the JAR.
//             releaseJar(IvyPublication) {
//                 from components.release
//                 artifact(tasks.named('bundleReleaseClassesJar')) {
//                     // This customizes the artifact, but it's taken from the component.
//                     // You might not need this if the AAR is sufficient.
//                 }
//                 artifactId = "OsmAndCore_android-classes" // Use a different artifactId to avoid conflicts
//             }
//         }
//     }
// }
